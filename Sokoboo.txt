------- FILE ./sokoboo.asm LEVEL 1 PASS 4
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	xsegtime
     89  0000 ????			   {1}	      SET	{2}-1
     90  0000 ????			   TEST_{1}   =	1
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????				      MAC	segtime_c
     94  0000 ????			   {1}	      SET	({2}+32)/64 + 1
     95  0000 ????			   TEST_{1}   =	0
     96  0000 ????				      ENDM
     97  0000 ????
     98  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     99  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
    100  0000 ????						; No other action required.  All code enables/disables automatically.
    101  0000 ????
    102  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
    103  0000 ????						; due to separation of timeslice overhead to separate check
    104  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_DIRECT, 323	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	(323+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_QUICK, 348	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_QUICK SET	(348+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_SLOW, 579	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_SLOW SET	(579+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_PF0, 88	; @ 4/8/2019 ??
      1  0000 ????			   SEGTIME_SCD_PF0 SET	(88+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0+1	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0+1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
    110  0000 ????
    111  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    112  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
    113  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,35	;41			  ; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	35
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
    115  0000 ????				      ENDIF
    116  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,2	;4			 ; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,3	;5			  ; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
    119  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SORT_TIME, 157	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	(157+32)/64 + 1
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
    121  0000 ????
    122  0000 ????
    123  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,2	;4		    ; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIMEBLANK, 993	; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	(993+32)/64 + 1
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    127  0000 ????
    128  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    129  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    130  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    131  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    132  0000 ????						; uses ...
    133  0000 ????
    134  0000 ????
    135  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    136  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    137  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    138  0000 ????
    139  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    140  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    141  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    145  0000 ????
    146  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get TARGET)
    147  0000 ????
    148  0000 ????						; push BOX is slowest (besides get TARGET which has an extra timer check)
    149  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    150  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SWITCHOBJECTS,74	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	(74+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????	       00 00	   DEBUG      =	NO
     55  0000 ????
     56  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     57  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     58  0000 ????
     59  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     60  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     61  0000 ????			  -	      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????
     65  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     66  0000 ????
     67  0000 ????
     68  0000 ????						;===================================
     69  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     70  0000 ????						;===================================
     71  0000 ????
     72  0000 ????						;-------------------------------------------------------------------------------
     73  0000 ????						; The following should be YES for the final or DEMO version
     74  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     75  0000 ????
     76  0000 ????						;-------------------------------------------------------------------------------
     77  0000 ????						; The following are optional YES/NO depending on phase of the moon
     78  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????
     81  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     82  0000 ????	       00 05	   NUM_LEVELS =	5
     83  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     87  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     88  0000 ????			  -	      IF	FINAL_VERSION = YES
     89  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     90  0000 ????			  -
     91  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
     92  0000 ????				      ENDIF
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     97  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     98  0000 ????
     99  0000 ????
    100  0000 ????	       00 01	   PUSH_LIMIT =	1	; slowdown when pushing on a BOX
    101  0000 ????
    102  0000 ????						; time bonus countdown constants:
    103  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    104  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    105  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    106  0000 ????
    107  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    108  0000 ????
    109  0000 ????	       00 03	   FACE_LEFT  =	3
    110  0000 ????
    111  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    112  0000 ????
    113  0000 ????						;scoring flags contants:
    114  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    115  0000 ????	       00 00	   DISPLAY_TIME =	%00
    116  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    117  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    118  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    119  0000 ????
    120  0000 ????						;------------------------------------------------------------------------------
    121  0000 ????
    122  0000 ????	       00 01	   MIRRORED_BOX =	YES
    123  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    124  0000 ????	       00 01	   MIRRORED_WALL =	YES
    125  0000 ????
    126  0000 ????						;------------------------------------------------------------------------------
    127  0000 ????
    128  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    129  0000 ????
    130  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    131  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    132  0000 ????
    133  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    134  0000 ????
    135  0000 ????
    136  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    137  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    138  0000 ????
    139  0000 ????
    140  0000 ????						; color constants:
    141  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    142  0000 ????
    143  0000 ????	       00 10	   YELLOW_NTSC =	$10
    144  0000 ????	       00 20	   YELLOW_PAL =	$20
    145  0000 ????
    146  0000 ????
    147  0000 ????	       10 00	   RAM_3E     =	$1000
    148  0000 ????	       04 00	   RAM_SIZE   =	$400
    149  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    150  0000 ????
    151  0000 ????
    152  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    153  0000 ????
    154  0000 ????
    155  0000 ????						; Platform constants:
    156  0000 ????	       00 02	   PAL	      =	%10
    157  0000 ????	       00 02	   PAL_50     =	PAL|0
    158  0000 ????	       00 03	   PAL_60     =	PAL|1
    159  0000 ????
    160  0000 ????
    161  0000 ????				      IF	L276
    162  0000 ????	       00 32	   VBLANK_TIM_NTSC =	50	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    163  0000 ????			  -	      ELSE
    164  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    165  0000 ????				      ENDIF
    166  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    167  0000 ????
    168  0000 ????				      IF	L276
    169  0000 ????	       00 3c	   OVERSCAN_TIM_NTSC =	60	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    170  0000 ????			  -	      ELSE
    171  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    172  0000 ????				      ENDIF
    173  0000 ????	       00 43	   OVERSCAN_TIM_PAL =	67	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    174  0000 ????
    175  0000 ????				      IF	L276
    176  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    177  0000 ????			  -	      ELSE
    178  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    179  0000 ????				      ENDIF
    180  0000 ????	       01 38	   SCANLINES_PAL =	312
    181  0000 ????
    182  0000 ????
    183  0000 ????						;------------------------------------------------------------------------------
    184  0000 ????						; MACRO definitions
    185  0000 ????
    186  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    187  0000 ????
    188  0000 ????				      MAC	newbank
    189  0000 ????				      SEG	{1}
    190  0000 ????				      ORG	ORIGIN
    191  0000 ????				      RORG	$F000
    192  0000 ????			   BANK_START SET	*
    193  0000 ????			   {1}	      SET	ORIGIN / 2048
    194  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    195  0000 ????			   _CURRENT_BANK SET	{1}
    196  0000 ????				      ENDM		; bank name
    197  0000 ????
    198  0000 ????				      MAC	define_1k_segment
    199  0000 ????				      ALIGN	$400
    200  0000 ????			   SEGMENT_{1} SET	*
    201  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    202  0000 ????				      ENDM		; {seg name}
    203  0000 ????
    204  0000 ????				      MAC	check_bank_size
    205  0000 ????			   .TEMP      =	* - BANK_START
    206  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    207  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    208  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    209  0000 ????				      ERR
    210  0000 ????				      endif
    211  0000 ????				      ENDM		; name
    212  0000 ????
    213  0000 ????
    214  0000 ????				      MAC	check_half_bank_size
    215  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    216  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    217  0000 ????			   .TEMP      =	* - BANK_START
    218  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    219  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    220  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    221  0000 ????				      ERR
    222  0000 ????				      endif
    223  0000 ????				      ENDM		; name
    224  0000 ????
    225  0000 ????
    226  0000 ????				      MAC	overlay
    227  0000 ????				      SEG.U	OVERLAY_{1}
    228  0000 ????				      org	Overlay
    229  0000 ????				      ENDM		; {name}
    230  0000 ????
    231  0000 ????						;--------------------------------------------------------------------------
    232  0000 ????
    233  0000 ????				      MAC	validate_overlay
    234  0000 ????				      LIST	OFF
    235  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    236  0000 ????				      ERR
    237  0000 ????				      endif
    238  0000 ????				      LIST	ON
    239  0000 ????				      ENDM
    240  0000 ????
    241  0000 ????						;--------------------------------------------------------------------------
    242  0000 ????						; Macro inserts a page break if the object would overlap a page
    243  0000 ????
    244  0000 ????				      MAC	optional_pagebreak
    245  0000 ????				      LIST	OFF
    246  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    247  0000 ????			   EARLY_LOCATION SET	*
    248  0000 ????				      ALIGN	256
    249  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    250  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    251  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    252  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    253  0000 ????				      ENDIF
    254  0000 ????				      LIST	ON
    255  0000 ????				      ENDM		; { string, size }
    256  0000 ????
    257  0000 ????
    258  0000 ????				      MAC	check_page_crossing
    259  0000 ????				      LIST	OFF
    260  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    261  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    262  0000 ????				      endif
    263  0000 ????				      LIST	ON
    264  0000 ????				      ENDM
    265  0000 ????
    266  0000 ????				      MAC	checkpage
    267  0000 ????				      LIST	OFF
    268  0000 ????				      IF	>. != >{1}
    269  0000 ????				      ECHO	""
    270  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    271  0000 ????				      ECHO	""
    272  0000 ????				      ERR
    273  0000 ????				      ENDIF
    274  0000 ????				      LIST	ON
    275  0000 ????				      ENDM
    276  0000 ????
    277  0000 ????				      MAC	checkpagex
    278  0000 ????				      LIST	OFF
    279  0000 ????				      IF	>. != >{1}
    280  0000 ????				      ECHO	""
    281  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    282  0000 ????				      ECHO	{2}
    283  0000 ????				      ECHO	""
    284  0000 ????				      ERR
    285  0000 ????				      ENDIF
    286  0000 ????				      LIST	ON
    287  0000 ????				      ENDM
    288  0000 ????
    289  0000 ????
    290  0000 ????				      MAC	checkpage_bne
    291  0000 ????				      LIST	OFF
    292  0000 ????				      IF	0	;>(. + 2) != >{1}
    293  0000 ????				      ECHO	""
    294  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    295  0000 ????				      ECHO	""
    296  0000 ????				      ERR
    297  0000 ????				      ENDIF
    298  0000 ????				      LIST	ON
    299  0000 ????				      bne	{1}
    300  0000 ????				      ENDM
    301  0000 ????
    302  0000 ????				      MAC	checkpage_bpl
    303  0000 ????				      LIST	OFF
    304  0000 ????				      IF	(>(.+2 )) != >{1}
    305  0000 ????				      ECHO	""
    306  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    307  0000 ????				      ECHO	""
    308  0000 ????				      ERR
    309  0000 ????				      ENDIF
    310  0000 ????				      LIST	ON
    311  0000 ????				      bpl	{1}
    312  0000 ????				      ENDM
    313  0000 ????
    314  0000 ????				      MAC	align_free
    315  0000 ????			   FREE       SET	FREE - .
    316  0000 ????				      align	{1}
    317  0000 ????			   FREE       SET	FREE + .
    318  0000 ????				      echo	"@", ., ":", FREE
    319  0000 ????				      ENDM
    320  0000 ????
    321  0000 ????				      MAC	stress_time
    322  0000 ????				      IF	TEST_{1} = 1
    323  0000 ????
    324  0000 ????
    325  0000 ????						;LIST OFF
    326  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    327  0000 ????						;LIST ON
    328  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    329  0000 ????				      bne	. - 7	; branches to lda INTIM
    330  0000 ????				      ENDIF
    331  0000 ????				      ENDM
    332  0000 ????
    333  0000 ????			   IDENTITY   SET	0
    334  0000 ????				      MAC	ident
    335  0000 ????				      if	DEBUG=YES
    336  0000 ????				      lda	#IDENTITY
    337  0000 ????				      sta	debug_ident
    338  0000 ????				      lda	{1}
    339  0000 ????				      sta	debug_object
    340  0000 ????				      endif
    341  0000 ????			   IDENTITY   SET	IDENTITY + 1
    342  0000 ????				      ENDM		; {object}
    343  0000 ????
    344  0000 ????						;--------------------------------------------------------------------------
    345  0000 ????
    346  0000 ????				      MAC	vector
    347  0000 ????				      .word	{1}
    348  0000 ????				      ENDM		; just a word pointer to code
    349  0000 ????
    350  0000 ????
    351  0000 ????				      MAC	define_subroutine
    352  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    353  0000 ????				      SUBROUTINE		; keep everything local
    354  0000 ????			   {1}			; entry point
    355  0000 ????				      ENDM		; name of subroutine
    356  0000 ????
    357  0000 ????
    358  0000 ????
    359  0000 ????						;--------------------------------------------------------------------------
    360  0000 ????
    361  0000 ????				      MAC	newrambank
    362  0000 ????				      SEG.U	{1}
    363  0000 ????				      ORG	ORIGIN
    364  0000 ????				      RORG	RAM_3E
    365  0000 ????			   BANK_START SET	*
    366  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    367  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    368  0000 ????				      ENDM		; bank name
    369  0000 ????
    370  0000 ????				      MAC	validate_ram_size
    371  0000 ????				      if	* - RAM_3E > RAM_SIZE
    372  0000 ????				      ERR
    373  0000 ????				      endif
    374  0000 ????				      ENDM
    375  0000 ????
    376  0000 ????				      MAC	next_random
    377  0000 ????						; update random value:
    378  0000 ????				      lda	rnd	; 3
    379  0000 ????				      lsr		; 2
    380  0000 ????				      IFCONST	rndHi
    381  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    382  0000 ????				      ENDIF
    383  0000 ????				      bcc	.skipEOR	; 2/3
    384  0000 ????				      eor	#RND_EOR_VAL	; 2
    385  0000 ????			   .skipEOR
    386  0000 ????				      sta	rnd	; 3 = 14/19
    387  0000 ????				      ENDM
    388  0000 ????
    389  0000 ????				      MAC	resync
    390  0000 ????						; resync screen, X and Y == 0 afterwards
    391  0000 ????				      lda	#%10	; make sure VBLANK is ON
    392  0000 ????				      sta	VBLANK
    393  0000 ????
    394  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    395  0000 ????			   .loopResync
    396  0000 ????				      VERTICAL_SYNC
    397  0000 ????
    398  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    399  0000 ????				      lda	Platform
    400  0000 ????				      eor	#PAL_50	; PAL-50?
    401  0000 ????				      bne	.ntsc
    402  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    403  0000 ????			   .ntsc
    404  0000 ????			   .loopWait
    405  0000 ????				      sta	WSYNC
    406  0000 ????				      sta	WSYNC
    407  0000 ????				      dey
    408  0000 ????				      bne	.loopWait
    409  0000 ????				      dex
    410  0000 ????				      bne	.loopResync
    411  0000 ????				      ENDM
    412  0000 ????
    413  0000 ????				      MAC	set_platform
    414  0000 ????						; 00 = NTSC
    415  0000 ????						; 01 = NTSC
    416  0000 ????						; 10 = PAL-50
    417  0000 ????						; 11 = PAL-60
    418  0000 ????				      lda	SWCHB
    419  0000 ????				      rol
    420  0000 ????				      rol
    421  0000 ????				      rol
    422  0000 ????				      and	#%11
    423  0000 ????				      eor	#PAL
    424  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    425  0000 ????				      ENDM
    426  0000 ????
    427  0000 ????						;  IF TJ_MODE
    428  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    429  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    430  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    431  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    432  0000 ????						;    ENDM
    433  0000 ????						;
    434  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    435  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    436  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    437  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    438  0000 ????						;    ENDM
    439  0000 ????						;
    440  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    441  0000 ????						;	  ldx #<{1}			  ; 2
    442  0000 ????						;	  stx addressR			  ; 3
    443  0000 ????						;	  ldx #>{1}			  ; 2
    444  0000 ????						;	  stx addressR+1		  ; 3
    445  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    446  0000 ????						;    ENDM
    447  0000 ????						;
    448  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    449  0000 ????						;	  ldx #<{1}			  ; 2
    450  0000 ????						;	  stx addressW			  ; 3
    451  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    452  0000 ????						;	  stx addressW+1		  ; 3
    453  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    454  0000 ????						;    ENDM
    455  0000 ????						;  ENDIF
    456  0000 ????
    457  0000 ????				      MAC	nop_b
    458  0000 ????				      .byte	$82
    459  0000 ????				      ENDM		; unused
    460  0000 ????
    461  0000 ????				      MAC	nop_w
    462  0000 ????				      .byte	$0c
    463  0000 ????				      ENDM
    464  0000 ????
    465  0000 ????						;------------------------------------------------------------------------------
    466  0000 ????
    467  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00f6 ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00 40	   GAMEMODE_2600 =	64
     39 U0080		       00 80	   GAMEMODE_PAUSED =	128
     40 U0080
     41 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     42 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0082							; above variables are preserved ALL the time!
     44 U0082
     45 U0082		       00	   rnd	      ds	1
     46 U0083		       00	   rndHi      ds	1	; to get better random values
     47 U0084
     48 U0084		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     49 U0085		       00	   ObjStackNum ds	1	; which stack in use
     50 U0086		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     51 U0088		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     52 U0089		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     53 U008a
     54 U008a		       00	   POS_X      ds	1
     55 U008b		       00	   POS_Y      ds	1
     56 U008c		       00	   POS_X_NEW  ds	1
     57 U008d		       00	   POS_Y_NEW  ds	1
     58 U008e		       00	   POS_Type   ds	1
     59 U008f		       00	   POS_VAR    ds	1
     60 U0090
     61 U0090		       00 00	   BufferedJoystick ds	2	; player joystick input
     62 U0092		       00 00	   BufferedButton ds	2	; player button press
     63 U0094
     64 U0094							; Scrolling is limited to only show board within the following area...
     65 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     66 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     67 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     68 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     69 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     70 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     71 U0098		       00	   scrollBits ds	1
     72 U0099
     73 U0099		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     74 U009a		       00	   manAnimationIndex ds	1
     75 U009b		       00	   ManX       ds	1
     76 U009c		       00	   ManY       ds	1
     77 U009d		       00	   ManDrawX   ds	1
     78 U009e		       00	   ManDrawY   ds	1
     79 U009f		       00	   ManMode    ds	1
     80 U00a0		       00	   ManDelayCount ds	1
     81 U00a1		       00 00	   ManAnimation ds	2
     82 U00a3		       00	   ManAnimationFrameLO ds	1
     83 U00a4		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     84 U00a5		       00	   ManPushCounter ds	1
     85 U00a6		       00	   LookingAround ds	1
     86 U00a7		       00	   ManCount   ds	1	; player life counter
     87 U00a8		       00	   DelayEndOfLevel ds	1
     88 U00a9		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     89 U00aa		       00 00	   circle_d   ds	2
     90 U00ac		       00	   circ_x     ds	1
     91 U00ad		       00	   circ_y     ds	1
     92 U00ae		       00	   circ_char  ds	1
     93 U00af		       00	   circ_scratch ds	1
     94 U00b0		       00	   LEVEL_bank ds	1
     95 U00b1							;---------------------------------------------------------------------------
     96 U00b1							; 2 (shared) demo mode variables:
     97 U00b1		       00 a9	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     98 U00b1		       00 a9	   moveLen    =	jtoggle	; bits 0..6
     99 U00b1		       00 99	   moveIdx    =	whichPlayer
    100 U00b1
    101 U00b1		       00	   LastSpriteY ds	1
    102 U00b2
    103 U00b2		       00	   timer      ds	1
    104 U00b3
    105 U00b3		       00	   BGColour   ds	1
    106 U00b4
    107 U00b4							; levelx and level have to be consecutive variables!
    108 U00b4		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    109 U00b5		       00	   level      ds	1	; current player's level (other in scoring bank)
    110 U00b6		       00	   levelDisplay ds	1	; what to display as the level ID
    111 U00b7		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    112 U00b8		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
    113 U00b9
    114 U00b9		       00	   targetsRequired ds	1	; number of un-targeted left to go
    115 U00ba		       00	   moveCounter ds	1	; BCD seconds for level
    116 U00bb		       00	   moveCounterHi ds	1
    117 U00bc		       00	   moveCounterBinary ds	1
    118 U00bd		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
    119 U00c0		       00 00	   Board_AddressR ds	2
    120 U00c2		       00 00	   Board_AddressW ds	2
    121 U00c4		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    122 U00c5		       00	   RAM_Bank   ds	1
    123 U00c6
    124 U00c6		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    125 U00c7		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    126 U00c8
    127 U00c8							; extraLifeTimer:
    128 U00c8							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    129 U00c8
    130 U00c8		       00	   scoringTimer ds	1	; times the various score displays
    131 U00c9		       00	   scoringFlags ds	1	; scoring flags are stored here
    132 U00ca
    133 U00ca							; scoringFlags:
    134 U00ca							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    135 U00ca							; D6		 unused
    136 U00ca							; D5		 unused
    137 U00ca							; D4		 unused
    138 U00ca							; D3		 unused
    139 U00ca							; D2		 unused
    140 U00ca							; D1	 D1-D0	 Which display kernel to use for scoring
    141 U00ca							; D0		 0 = 2x4     used for TARGETs/time
    142 U00ca							;		 1 = 1x6     used for score
    143 U00ca							;		 2 = 3x2     used for level/lives/player
    144 U00ca
    145 U00ca		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    146 U00ca		       00 80	   BIT_NEXTLEVEL =	128
    147 U00ca		       00 40	   BIT_NEXTLIFE =	64
    148 U00cb
    149 U00cb							;---------------------------------------------------------------------------
    150 U00cb
    151 U00cb		       00	   sortRequired ds	1
    152 U00cc		       00	   sortPtr    ds	1
    153 U00cd
    154 U00cd							;------------------------------------------------------------------------------
    155 U00cd
    156 U00cd		       00	   ObjIterator ds	1	; count UP iterator over objects
    157 U00ce		       00	   DSL	      ds	1	; stack line counter
    158 U00cf
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 4
      0 U00cf					      include	"sound/intro1_variables.asm"
      1 U00cf							; TIATracker music player
      2 U00cf							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00cf							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00cf							; Email: andre.wichmann@gmx.de
      5 U00cf							;
      6 U00cf							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00cf							; you may not use this file except in compliance with the License.
      8 U00cf							; You may obtain a copy of the License at
      9 U00cf							;
     10 U00cf							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00cf							;
     12 U00cf							; Unless required by applicable law or agreed to in writing, software
     13 U00cf							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00cf							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00cf							; See the License for the specific language governing permissions and
     16 U00cf							; limitations under the License.
     17 U00cf
     18 U00cf							; Song author: 
     19 U00cf							; Song name: 
     20 U00cf
     21 U00cf							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00cf
     23 U00cf							; =====================================================================
     24 U00cf							; Flags
     25 U00cf							; =====================================================================
     26 U00cf
     27 U00cf							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00cf		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00cf							; duration (number of TV frames) of a note
     30 U00cf		       00 05	   TT_SPEED   =	5
     31 U00cf							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00cf		       00 04	   TT_ODD_SPEED =	4
     33 U00cf
     34 U00cf							; 1: Overlay percussion, +40 bytes
     35 U00cf		       00 01	   TT_USE_OVERLAY =	1
     36 U00cf							; 1: Melodic instrument slide, +9 bytes
     37 U00cf		       00 00	   TT_USE_SLIDE =	0
     38 U00cf							; 1: Goto pattern, +8 bytes
     39 U00cf		       00 01	   TT_USE_GOTO =	1
     40 U00cf							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00cf		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00cf							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00cf							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00cf							; this flag to 0 to save 2 bytes.
     45 U00cf							; 0: +2 bytes
     46 U00cf		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00cf
     48 U00cf
     49 U00cf							; =====================================================================
     50 U00cf							; Permanent variables. These are states needed by the player.
     51 U00cf							; =====================================================================
     52 U00cf		       00	   tt_timer   ds	1	; current music timer value
     53 U00d0		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d1		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d2		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d3		       00	   tt_cur_note_index_c1 ds	1
     57 U00d4		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d5		       00	   tt_envelope_index_c1 ds	1
     59 U00d6		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d7		       00	   tt_cur_ins_c1 ds	1
     61 U00d8
     62 U00d8
     63 U00d8							; =====================================================================
     64 U00d8							; Temporary variables. These will be overwritten during a call to the
     65 U00d8							; player routine, but can be used between calls for other things.
     66 U00d8							; =====================================================================
     67 U00d8		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    160 U00da
    161 U00da
    162 U00da
    163 U00da				   OVERLAY_SIZE SET	16
    164 U00da
    165 U00da
    166 U00da
    167 U00da							; This overlay variable is used for the overlay variables.  That's OK.
    168 U00da							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    169 U00da							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    170 U00da							; (especially the latter ones) are only used in rare occasions.
    171 U00da
    172 U00da							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    173 U00da							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    174 U00da
    175 U00da		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    177 U00ea
    178 U00ea
    179 U00ea		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    180 U00f6
 FREE BYTES IN ZERO PAGE =  $9
    181 U00f6					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    182 U00f6				  -	      IF	* > $FF
    183 U00f6				  -	      ERR
    184 U00f6					      ENDIF
------- FILE ./sokoboo.asm
    469 U00f6
    470 U00f6
    471 U00f6							;------------------------------------------------------------------------------
    472 U00f6							; OVERLAYS!
    473 U00f6							; These variables are overlays, and should be managed with care
    474 U00f6							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    475 U00f6
    476 U00f6							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    477 U00f6							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    478 U00f6
    479 U00f6							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    480 U00f6
    481 U00f6
    482 U00f6
    483 U00f6							;------------------------------------------------------------------------------
      0 U00f6					      OVERLAY	BuildDrawFlags
      1 U00e5 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00da					      org	Overlay
    485 U00da
    486 U00da		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    487 U00dc		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    488 U00de		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    489 U00e0		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    490 U00e2							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    491 U00e2		       00	   BDF_BoardBank ds	1	; holds bank of current line
    492 U00e3							;  ENDIF
    493 U00e3		       00	   DHS_Line   ds	1
    494 U00e4		       00	   DHS_Stack  ds	1	; for restoring SP
    495 U00e5							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    497 U00e5
    498 U00e5							;------------------------------------------------------------------------------
    499 U00e5
      0 U00e5					      OVERLAY	Process
      1 U00dd ????				      SEG.U	OVERLAY_Process
      2 U00da					      org	Overlay
    501 U00da
    502 U00da		       00	   BOXLeft    ds	1
    503 U00db		       00	   BOXRight   ds	1
    504 U00dc		       00	   restorationCharacter ds	1
    505 U00dd
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    507 U00dd
    508 U00dd							;------------------------------------------------------------------------------
    509 U00dd
      0 U00dd					      OVERLAY	Animate
      1 U00db ????				      SEG.U	OVERLAY_Animate
      2 U00da					      org	Overlay
    511 U00da		       00	   halftimer  ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    513 U00db
    514 U00db							;------------------------------------------------------------------------------
    515 U00db
      0 U00db					      OVERLAY	TitleScreen
      1 U00dc ????				      SEG.U	OVERLAY_TitleScreen
      2 U00da					      org	Overlay
    517 U00da		       00 00	   colour_table ds	2
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    519 U00dc
    520 U00dc							;------------------------------------------------------------------------------
    521 U00dc
      0 U00dc					      OVERLAY	TimeSlice
      1 U00dc ????				      SEG.U	OVERLAY_TimeSlice
      2 U00da					      org	Overlay
    523 U00da
    524 U00da		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    525 U00dc							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    527 U00dc
    528 U00dc							;------------------------------------------------------------------------------
    529 U00dc
      0 U00dc					      OVERLAY	CopyROMShadowToRAM
      1 U00dd ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00da					      org	Overlay
    531 U00da
    532 U00da		       00	   O_CopyCount ds	1
    533 U00db		       00	   O_ROM_Source_Bank ds	1
    534 U00dc		       00	   O_Index    ds	1
    535 U00dd							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    537 U00dd
    538 U00dd							;------------------------------------------------------------------------------
    539 U00dd
      0 U00dd					      OVERLAY	Scoring
      1 U00db ????				      SEG.U	OVERLAY_Scoring
      2 U00da					      org	Overlay
    541 U00da		       00	   tmpStack   ds	1
    542 U00da		       00 da	   newDisplay =	tmpStack
    543 U00db							; also for UpdateTimer
    544 U00db		       00 da	   tmpSound   =	tmpStack
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    546 U00db
    547 U00db
    548 U00db							;------------------------------------------------------------------------------
    549 U00db
      0 U00db					      OVERLAY	SaveKey
      1 U00e3 ????				      SEG.U	OVERLAY_SaveKey
      2 U00da					      org	Overlay
    551 U00da
    552 U00da		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    553 U00dd		       00 00 00    highScoreSK ds	3
    554 U00e0		       00	   startingLevel ds	1	; levelx * 5
    555 U00e1		       00	   startLevel ds	1
    556 U00e2		       00	   offsetSK   ds	1	; for calculating the SK slot address
    557 U00e3
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    559 U00e3
    560 U00e3							;------------------------------------------------------------------------------
    561 U00e3
      0 U00e3					      OVERLAY	DrawMan
      1 U00dc ????				      SEG.U	OVERLAY_DrawMan
      2 U00da					      org	Overlay
    563 U00da
    564 U00da		       00 00	   MAN_Move   ds	2
    565 U00dc
    566 U00dc							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    568 U00dc
    569 U00dc							;------------------------------------------------------------------------------
    570 U00dc
      0 U00dc					      OVERLAY	ProcessObjStack
      1 U00dc ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00da					      org	Overlay
    572 U00da
    573 U00da		       00 00	   POS_Vector ds	2
    574 U00dc
    575 U00dc							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    577 U00dc
    578 U00dc							;------------------------------------------------------------------------------
    579 U00dc
      0 U00dc					      OVERLAY	ScoreLineOverlay
      1 U00e9 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00da					      org	Overlay
    581 U00da
    582 U00da		       00 00	   S0	      ds	2	; used for addressing digits of score
    583 U00dc		       00 00	   S1	      ds	2
    584 U00de		       00 00	   S2	      ds	2
    585 U00e0		       00 00	   S3	      ds	2
    586 U00e2		       00 00	   S4	      ds	2
    587 U00e4		       00 00	   S5	      ds	2
    588 U00e6
    589 U00e6		       00	   stkp       ds	1
    590 U00e7		       00	   sreg       ds	1
    591 U00e8		       00	   loop       ds	1
    592 U00e9
    593 U00e9							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e9					      VALIDATE_OVERLAY
      5 U00e9					      LIST	ON
    595 U00e9
    596 U00e9							;------------------------------------------------------------------------------
    597 U00e9
    598 U00e9
      0 U00e9					      OVERLAY	UnpackLevelOverlay
      1 U00df ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00da					      org	Overlay
    600 U00da
    601 U00da		       00	   base_x     ds	1
    602 U00db		       00	   base_y     ds	1
    603 U00dc		       00	   upk_length ds	1
    604 U00dd		       00	   upk_column ds	1
    605 U00de		       00	   upk_temp   ds	1
    606 U00df
    607 U00df							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    609 U00df
    610 U00df							;------------------------------------------------------------------------------
    611 U00df
      0 U00df					      OVERLAY	ManProcessing
      1 U00dc ????				      SEG.U	OVERLAY_ManProcessing
      2 U00da					      org	Overlay
    613 U00da		       00 00	   actionVector ds	2
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    615 U00dc
      0 U00dc					      OVERLAY	SetPlatformColours
      1 U00db ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00da					      org	Overlay
    617 U00da		       00	   colorIdx   ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    619 U00db
      0 U00db					      OVERLAY	SwapPlayers
      1 U00db ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00da					      org	Overlay
    621 U00da		       00	   tmpX       ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    623 U00db
      0 U00db					      OVERLAY	DrawIntoStack
      1 U00db ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00da					      org	Overlay
    625 U00da		       00	   save_SP    ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    627 U00db
    628 U00db							;------------------------------------------------------------------------------
    629 U00db							;##############################################################################
    630 U00db							;------------------------------------------------------------------------------
    631 U00db
    632 U00db							; NOW THE VERY INTERESTING '3E' RAM BANKS
    633 U00db							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    634 U00db
    635 U00db				   ORIGIN     SET	0
      0 U00db					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    637 U0000
    638 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    639 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    640 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    641 U0000
    642 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    643 U0000
    644 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    645 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    646 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    647 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    648 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    649 U0000
    650 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    651 U0000							; is that we can use that code to switch between banks, and the system will happily
    652 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    653 U0000
    654 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    655 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    656 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    657 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    658 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    659 U0000
    660 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    661 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    662 U0000							; part of the draw routine *every* scanline (though the system currently uses
    663 U0000							; one colour shared between both players).
    664 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    666 U0000
    667 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    668 U0000							; accessed via the above labels but with the appropriate bank switched in.
    669 U0000
    670 U0000							;------------------------------------------------------------------------------
    671 U0000
    672 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    672 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    672 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    672 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    672 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    672 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    672 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    675 U1c00					      REPEND
    676 U1c00
    677 U1c00							;------------------------------------------------------------------------------
    678 U1c00							;##############################################################################
    679 U1c00							;------------------------------------------------------------------------------
    680 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    682 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    683 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    685 U2000
    686 U2000							;------------------------------------------------------------------------------
    687 U2000							;##############################################################################
    688 U2000							;------------------------------------------------------------------------------
    689 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    691 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    692 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    694 U2400
    695 U2400							;------------------------------------------------------------------------------
    696 U2400							;##############################################################################
    697 U2400							;------------------------------------------------------------------------------
    698 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    700 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    701 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    703 U2800
    704 U2800							;------------------------------------------------------------------------------
    705 U2800							;##############################################################################
    706 U2800							;------------------------------------------------------------------------------
    707 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    709 U2c00
    710 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    711 U2c00							; position of something that needs to be processed.  These things include anything
    712 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    713 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    714 U2c00							; one for the next processing iteration.
    715 U2c00
    716 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    717 U2c00
    718 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    719 U2c00
    720 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    721 U2c00
    722 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    723 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    724 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    725 U2d80
    726 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    727 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    728 U2e00
    729 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    730 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    731 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    732 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    734 U2e80
    735 U2e80							;------------------------------------------------------------------------------
    736 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    738 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    740 U3000
    741 U3000							;------------------------------------------------------------------------------
    742 U3000							;##############################################################################
    743 U3000							;------------------------------------------------------------------------------
    744 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    746 U3400
    747 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    748 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    749 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    750 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    751 U3400							; when accessing.
    752 U3400
    753 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    754 U3400							; automatically based on the sizes set in these constants. The board may overlay
    755 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    756 U3400							; we're doing OK.
    757 U3400
    758 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    759 U3400
    760 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    761 U3400
    762 U3400		       00 28	   SIZE_BOARD_X =	40
    763 U3400		       00 16	   SIZE_BOARD_Y =	22
    764 U3400				  -	      if	0
    765 U3400				  -			; have to precalculate it here, else DASM freaks out:
    766 U3400				  -.BOARD_SIZE SET	0
    767 U3400				  -.BOARD_LOCATION SET	0
    768 U3400				  -	      REPEAT	SIZE_BOARD_Y
    769 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    770 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    771 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    772 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    773 U3400				  -	      ENDIF
    774 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    775 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    776 U3400				  -	      REPEND
    777 U3400				  -
    778 U3400				  -SIZE_BOARD =	.BOARD_SIZE
    779 U3400					      endif
    780 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    781 U3400				  -MULTI_BANK_BOARD =	YES
    782 U3400					      ELSE
    783 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    784 U3400					      ENDIF
    785 U3400
    786 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    787 U37a0							; 1024 byte chunks, switching RAM
    788 U37a0							; banks as we go.  In other words,
    789 U37a0							; this overlaps multiple banks!
    790 U37a0
      0 U37a0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3b00 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN / RAM_SIZE
      6 U3800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    792 U3800		       00 00 00 00*TakeBackX  ds	256
    793 U3900		       00 00 00 00*TakeBackY  ds	256
    794 U3a00		       00 00 00 00*TakeBackA  ds	256
    795 U3b00
    796 U3b00							; free space here (but hard to use)
    797 U3b00							; So we need to calculate where the next free bank is!
    798 U3b00							; TODO: This looks dodgy.  Check..
    799 U3b00
    800 U3b00				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    801 U3b00				   ORIGIN     SET	ORIGIN * RAM_SIZE
    802 U3b00
    803 U3b00
    804 U3b00
    805 U3b00							;------------------------------------------------------------------------------
    806 U3b00							;##############################################################################
    807 U3b00							;------------------------------------------------------------------------------
    808 U3b00
    809 U3b00							;------------------------------------------------------------------------------
    810 U3b00
    811 U3b00							;    IFNCONST MAX_LEVEL_SIZE
    812 U3b00				   MAX_LEVEL_SIZE SET	0
    813 U3b00							;    ENDIF
    814 U3b00
    815 U3b00					      MAC	start_level
    816 U3b00				   LEVEL_START SET	*
    817 U3b00				   BANK_LEVEL_{1} =	_CURRENT_BANK
    818 U3b00				   LEVEL_{1}  SUBROUTINE
    819 U3b00				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    820 U3b00							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    821 U3b00					      ENDM		; {name}
    822 U3b00
    823 U3b00
    824 U3b00					      MAC	end_level
    825 U3b00					      .byte	0
    826 U3b00				   LEVEL_SIZE_{1} =	* - LEVEL_START
    827 U3b00					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    828 U3b00				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    829 U3b00					      ENDIF
    830 U3b00					      ENDM		; {name}
    831 U3b00
    832 U3b00
    833 U3b00					      MAC	defl
    834 U3b00					      START_LEVEL	{1}
    835 U3b00					      .byte	{2},0
    836 U3b00					      END_LEVEL	{1}
    837 U3b00					      ENDM
    838 U3b00
    839 U3b00							;--------------------------------------------------------------------------------
    840 U3b00
    841 U3b00				   ORIGIN     SET	$00000
    842 U3b00
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 4
      0 U3b00					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3b00							;    Sokoboo - a Sokoban implementation
      2 U3b00							;    using a generic tile-based display engine for the Atari 2600
      3 U3b00							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3b00							;
      5 U3b00							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3b00							;
      7 U3b00							;    Code related to the generic tile-based display engine was developed by
      8 U3b00							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3b00							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3b00							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3b00							;
     12 U3b00							;    Code related to music and sound effects uses the TIATracker music player
     13 U3b00							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3b00							;    directory for Apache licensing details.
     15 U3b00							;
     16 U3b00							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3b00							;    See the copyright notices in the License directory for a list of level
     18 U3b00							;    contributors.
     19 U3b00							;
     20 U3b00							;    Except where otherwise indicated, this software is released under the
     21 U3b00							;    following licensing arrangement...
     22 U3b00							;
     23 U3b00							;    This program is free software: you can redistribute it and/or modify
     24 U3b00							;    it under the terms of the GNU General Public License as published by
     25 U3b00							;    the Free Software Foundation, either version 3 of the License, or
     26 U3b00							;    (at your option) any later version.
     27 U3b00							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3b00
     29 U3b00							;    This program is distributed in the hope that it will be useful,
     30 U3b00							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3b00							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3b00							;    GNU General Public License for more details.
     33 U3b00
     34 U3b00							;------------------------------------------------------------------------------
     35 U3b00							;##############################################################################
     36 U3b00							;------------------------------------------------------------------------------
      0 U3b00					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  03f4 ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
     48  0000		       00 01	   _PROFILE_DRAW =	YES
     49  0000
     50  0000					      MAC	profile_draw
     51  0000					      IF	_PROFILE_DRAW
     52  0000					      inc	Profile{1}
     53  0000					      bne	$skip
     54  0000					      inc	Profile{1}+1
     55  0000				   $skip
     56  0000					      ENDIF
     57  0000					      ENDM		; {label}
     58  0000
     59  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     61  0000
     62  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     63  0000							; A refactor of the kernel to improve the timing.
     64  0000							; Experimental refactor to remove the blank line...
     65  0000
     66  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     67  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     68  0000
     69  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     70  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     72  0002
     73  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     74  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     75  0006
     76  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     78  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     79  000a
     80  000a				   ScanRED		;	     @60
     81  000a		       b9 bc f2    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     82  000d		       85 4d		      sta	PF0	; 3	     @67
     83  000f		       b9 3e f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     84  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     85  0014				   SELFMOD_PLAYERCOL_RED
     86  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     87  0017		       85 46		      sta	COLUP0	; 3	     @05
     88  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     89  001b
     90  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     91  001b
     92  001b				   SELFMOD_RED
     93  001b		       a9 00		      lda	#0	; 2
     94  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     95  001f
     96  001f				   SELFMOD_PLAYER0_RED
     97  001f		       b9 bc f2 	      lda	ShapePlayerRED,y	; 4
     98  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
     99  0024
    100  0024		       b9 53 f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
    101  0027		       85 4f		      sta	PF2	; 3 =	7    @27
    102  0029
    103  0029		       b9 bc f2    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
    104  002c		       85 4d		      sta	PF0	; 3	     @34
    105  002e		       b9 68 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
    106  0031		       85 4e		      sta	PF1	; 3	     @41
    107  0033		       b9 7d f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    108  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    109  0038
    110  0038				   SELFMOD_PLAYER1_RED
    111  0038		       b9 bc f2 	      lda	ShapePlayerRED,y	; 4
    112  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
    113  003e
    114  003e		       88		      dey		; 2
    115  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
    116  0041
    117  0041		       e8	   SELFMOD_X  inx		; 2
    118  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    119  0044							;EXIT_RETURN_HERE
    120  0044				   NextALineStart
    121  0044		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    122  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    123  0046
    124  0046							;------------------------------------------------------------------------------
    125  0046
    126  0046		       b9 bc f2    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    127  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    128  004b				   SELFMOD_PLAYERCOL_BLUE
    129  004b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
    130  004e		       85 47		      sta	COLUP1	; 3	     @05
    131  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    132  0052
    133  0052				   SELFMOD_BLUE
    134  0052		       a9 00		      lda	#0	; 2
    135  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    136  0056
    137  0056				   SELFMOD_PLAYER0_BLUE
    138  0056		       b9 bc f2 	      lda	ShapePlayerBLUE,y	; 4
    139  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    140  005b
    141  005b		       b9 4c f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    142  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    143  0060		       b9 61 f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    144  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    145  0065
    146  0065		       b9 bc f2    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    147  0068		       85 4d		      sta	PF0	; 3	     @41
    148  006a		       b9 76 f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    149  006d		       85 4e		      sta	PF1	; 3	     @48
    150  006f		       b9 8b f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    151  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    152  0074
    153  0074				   SELFMOD_PLAYER1_BLUE
    154  0074		       b9 bc f2 	      lda	ShapePlayerBLUE,y	; 4
    155  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    156  0079
    157  0079							;------------------------------------------------------------------------------
    158  0079
    159  0079				   ScanGREEN		;	     @62
    160  0079		       b9 bc f2    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    161  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    162  007e				   SELFMOD_PLAYERCOL_GREEN
    163  007e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    164  0081		       85 47		      sta	COLUP1	; 3	     @00
    165  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    166  0085
    167  0085				   SELFMOD_GREEN
    168  0085		       a9 00		      lda	#0	; 2
    169  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    170  0089
    171  0089				   SELFMOD_PLAYER0_GREEN
    172  0089		       b9 bc f2 	      lda	ShapePlayerGREEN,y	; 4
    173  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    174  008e
    175  008e		       b9 45 f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    176  0091		       85 4e		      sta	PF1	; 3	     @22
    177  0093		       b9 5a f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    178  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    179  0098
    180  0098		       b9 bc f2    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    181  009b		       85 4d		      sta	PF0	; 3	     @36
    182  009d		       b9 6f f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    183  00a0		       85 4e		      sta	PF1	; 3	     @43
    184  00a2		       b9 84 f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    185  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    186  00a7
    187  00a7				   SELFMOD_PLAYER1_GREEN
    188  00a7		       b9 bc f2 	      lda	ShapePlayerGREEN,y	; 4
    189  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    190  00ac
    191  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    192  00af
    193  00af							;------------------------------------------------------------------------------
    194  00af
    195  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    196  00af
    197  00af		       f2 bc	   ShapePlayer =	PLAYER_BLANK
    198  00af		       f2 bc	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    199  00af		       f2 bc	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    200  00af		       f2 bc	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    201  00af
    202  00af		       f2 bc	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    203  00af		       f2 bc	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    204  00af
------- FILE playerColour.asm LEVEL 3 PASS 4
      0  00af					      include	"playerColour.asm"	; 1 * LINES_PER_CHAR bytes
      1  00af							;;    Sokoboo - a Sokoban implementation
      2  00af							;    using a generic tile-based display engine for the Atari 2600
      3  00af							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  00af							;
      5  00af							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  00af							;
      7  00af							;    Code related to the generic tile-based display engine was developed by
      8  00af							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  00af							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  00af							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  00af							;
     12  00af							;    Code related to music and sound effects uses the TIATracker music player
     13  00af							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  00af							;    directory for Apache licensing details.
     15  00af							;
     16  00af							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  00af							;    See the copyright notices in the License directory for a list of level
     18  00af							;    contributors.
     19  00af							;
     20  00af							;    Except where otherwise indicated, this software is released under the
     21  00af							;    following licensing arrangement...
     22  00af							;
     23  00af							;    This program is free software: you can redistribute it and/or modify
     24  00af							;    it under the terms of the GNU General Public License as published by
     25  00af							;    the Free Software Foundation, either version 3 of the License, or
     26  00af							;    (at your option) any later version.
     27  00af							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  00af
     29  00af							;    This program is distributed in the hope that it will be useful,
     30  00af							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  00af							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  00af							;    GNU General Public License for more details.
     33  00af
      0  00af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  00af					      LIST	ON
     35  00af
     36  00af		       00 10	   YELLOW_NTSC =	$10	; hair
     37  00af		       00 30	   ORANGE_NTSC =	$30	; skin
     38  00af		       00 40	   RED_NTSC   =	$40	; shirt
     39  00af		       00 a4	   BLUE_NTSC  =	$A4
     40  00af
     41  00af		       00 20	   YELLOW_PAL =	$20
     42  00af		       00 40	   ORANGE_PAL =	$40
     43  00af		       00 60	   RED_PAL    =	$60
     44  00af
     45  00af				   SpriteColour
     46  00af							; NTSC
     47  00af							;SpriteColourRED
     48  00af							;    .byte RED_NTSC|$6       ; 0 feet
     49  00af							;    .byte WHITE	      ; 3
     50  00af							;    .byte RED_NTSC|$4       ; 6
     51  00af							;    .byte RED_NTSC|$4       ; 9
     52  00af							;    .byte ORANGE_NTSC|$6    ;12
     53  00af							;    .byte ORANGE_NTSC|$8    ;15
     54  00af							;    .byte WHITE	      ;18
     55  00af							;SpriteColourGREEN
     56  00af							;    .byte RED_NTSC|$4       ; 1
     57  00af							;    .byte WHITE	      ; 4
     58  00af							;    .byte WHITE	      ; 7
     59  00af							;    .byte WHITE	      ;10
     60  00af							;    .byte ORANGE_NTSC|$8    ;13
     61  00af							;    .byte ORANGE_NTSC|$6    ;16
     62  00af							;    .byte WHITE	      ;19
     63  00af							;SpriteColourBLUE
     64  00af							;    .byte WHITE	      ; 2
     65  00af							;    .byte RED_NTSC|$4       ; 5
     66  00af							;    .byte RED_NTSC|$4       ; 8
     67  00af							;    .byte ORANGE_NTSC|$4    ;11 neck
     68  00af							;    .byte ORANGE_NTSC|$a    ;14
     69  00af							;    .byte YELLOW_NTSC|$c    ;17 hair
     70  00af							;    .byte WHITE	      ;20
     71  00af
     72  00af				   SpriteColourRED
     73  00af		       76		      .byte.b	$76
     74  00b0		       76		      .byte.b	$76
     75  00b1		       76		      .byte.b	$76
     76  00b2		       76		      .byte.b	$76
     77  00b3		       76		      .byte.b	$76
     78  00b4		       76		      .byte.b	$76
     79  00b5		       76		      .byte.b	$76
     80  00b6
     81  00b6							;  .byte #$1C;0
     82  00b6							;  .byte #$78;3
     83  00b6							;  .byte #$52;6
     84  00b6							;  .byte #$52;9
     85  00b6							;  .byte #$0C;12
     86  00b6							;  .byte #$4A;15
     87  00b6							;  .byte #$1A;18
     88  00b6				   SpriteColourGREEN
     89  00b6		       7a		      .byte.b	$7A
     90  00b7		       7a		      .byte.b	$7A
     91  00b8		       7a		      .byte.b	$7A
     92  00b9		       7a		      .byte.b	$7A
     93  00ba		       7a		      .byte.b	$7A
     94  00bb		       7a		      .byte.b	$7A
     95  00bc		       7a		      .byte.b	$7A
     96  00bd				   SpriteColourBLUE
     97  00bd		       2a		      .byte.b	$2A
     98  00be		       2a		      .byte.b	$2A
     99  00bf		       2a		      .byte.b	$2A
    100  00c0		       2a		      .byte.b	$2A
    101  00c1		       2a		      .byte.b	$2A
    102  00c2		       2a		      .byte.b	$2A
    103  00c3		       2a		      .byte.b	$2A
    104  00c4
    105  00c4					      REPEAT	21
    106  00c4		       26		      .byte.b	$20|$6	; 2
    105  00c4					      REPEND
    106  00c5		       26		      .byte.b	$20|$6	; 2
    105  00c5					      REPEND
    106  00c6		       26		      .byte.b	$20|$6	; 2
    105  00c6					      REPEND
    106  00c7		       26		      .byte.b	$20|$6	; 2
    105  00c7					      REPEND
    106  00c8		       26		      .byte.b	$20|$6	; 2
    105  00c8					      REPEND
    106  00c9		       26		      .byte.b	$20|$6	; 2
    105  00c9					      REPEND
    106  00ca		       26		      .byte.b	$20|$6	; 2
    105  00ca					      REPEND
    106  00cb		       26		      .byte.b	$20|$6	; 2
    105  00cb					      REPEND
    106  00cc		       26		      .byte.b	$20|$6	; 2
    105  00cc					      REPEND
    106  00cd		       26		      .byte.b	$20|$6	; 2
    105  00cd					      REPEND
    106  00ce		       26		      .byte.b	$20|$6	; 2
    105  00ce					      REPEND
    106  00cf		       26		      .byte.b	$20|$6	; 2
    105  00cf					      REPEND
    106  00d0		       26		      .byte.b	$20|$6	; 2
    105  00d0					      REPEND
    106  00d1		       26		      .byte.b	$20|$6	; 2
    105  00d1					      REPEND
    106  00d2		       26		      .byte.b	$20|$6	; 2
    105  00d2					      REPEND
    106  00d3		       26		      .byte.b	$20|$6	; 2
    105  00d3					      REPEND
    106  00d4		       26		      .byte.b	$20|$6	; 2
    105  00d4					      REPEND
    106  00d5		       26		      .byte.b	$20|$6	; 2
    105  00d5					      REPEND
    106  00d6		       26		      .byte.b	$20|$6	; 2
    105  00d6					      REPEND
    106  00d7		       26		      .byte.b	$20|$6	; 2
    105  00d7					      REPEND
    106  00d8		       26		      .byte.b	$20|$6	; 2
    107  00d9					      REPEND
    108  00d9
    109  00d9							; PAL
    110  00d9							;    .byte RED_PAL|$6	      ; 0 feet
    111  00d9							;    .byte WHITE	      ; 3
    112  00d9							;    .byte RED_PAL|$4	      ; 6
    113  00d9							;    .byte RED_PAL|$4	      ; 9
    114  00d9							;    .byte ORANGE_PAL|$4     ;12
    115  00d9							;    .byte ORANGE_PAL|$6     ;15
    116  00d9							;    .byte WHITE	      ;18
    117  00d9							;
    118  00d9							;    .byte RED_PAL|$4	      ; 1
    119  00d9							;    .byte WHITE	      ; 4
    120  00d9							;    .byte WHITE	      ; 7
    121  00d9							;    .byte WHITE	      ;10
    122  00d9							;    .byte ORANGE_PAL|$6     ;13
    123  00d9							;    .byte ORANGE_PAL|$4     ;16
    124  00d9							;    .byte WHITE	      ;19
    125  00d9							;
    126  00d9							;    .byte WHITE	      ; 2
    127  00d9							;    .byte RED_PAL|$4	      ; 5
    128  00d9							;    .byte RED_PAL|$4	      ; 8
    129  00d9							;    .byte ORANGE_PAL|$2     ;11 neck
    130  00d9							;    .byte ORANGE_PAL|$8     ;14
    131  00d9							;    .byte YELLOW_PAL|$c     ;17 hair
    132  00d9							;    .byte WHITE	      ;20
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    206  00d9
    207  00d9
    208  00d9							;------------------------------------------------------------------------------
    209  00d9
    210  00d9							;*** Ideas: ***
    211  00d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    212  00d9							;   13.5% on average), also unrolling would be more effective than now
    213  00d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    214  00d9							;   see EXPERIMENTAL)
    215  00d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    216  00d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    217  00d9							;   bidirectional linked list instead)
    218  00d9							; - calculate mirrored gfx data into RAM (saves ROM)
    219  00d9
    220  00d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    221  00d9							;currently:
    222  00d9							; 72%*539 (!unrolled)
    223  00d9							;+ 8%*304 (unrolled)
    224  00d9							;+20%*269 (unrolled)
    225  00d9							;--------
    226  00d9							;=   ~466.2 cycles on average
    227  00d9
    228  00d9							;alternative #1:
    229  00d9							; 72%*522 (unrolled)
    230  00d9							;+ 8%*352 (!unrolled)
    231  00d9							;+20%*307 (!unrolled)
    232  00d9							;--------
    233  00d9							;=   ~465.4 cycles on average
    234  00d9
    235  00d9
    236  00d9		       00 01	   MIRROR     =	1
    237  00d9		       00 80	   DIRECT     =	$80
    238  00d9
    239  00d9							;------------------------------------------------------------------------------
    240  00d9							; Here we don't draw into a buffer, but directly patch the kernel
    241  00d9							; VERY fast!
    242  00d9							;
    243  00d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    244  00d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    245  00d9
    246  00d9				   PF0Draw		; 25 cycles until here
    247  00d9
    248  00d9		       ae 84 02 	      ldx	INTIM	; 4
    249  00dc		       e0 02		      cpx	#SEGTIME_SCD_PF0	; 2
    250  00de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  00e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  00e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  00e0				  -
      3  00e0				  -
      4  00e0				  -
      5  00e0				  -
      6  00e0				  -
      7  00e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00e0				  -	      bne	. - 7
      9  00e0					      ENDIF
    252  00e0
    253  00e0		       29 7f		      and	#<(~DIRECT)	; 2
    254  00e2		       aa		      tax		; 2 =	4
    255  00e3
    256  00e3		       98		      tya		; 2
    257  00e4		       0a		      asl		; 2	     no mirrored chars in PF0
    258  00e5		       a8		      tay		; 2 =	6
    259  00e6							;		  clc				  ; 2
    260  00e6
    261  00e6		       b9 fa f2 	      lda	CharacterDataVecHI,y	; 4
    262  00e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    263  00ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    264  00ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    265  00f2
    266  00f2		       b9 e6 f2 	      lda	CharacterDataVecLO,y	; 4
    267  00f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    268  00f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    269  00fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    270  00fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    271  00ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    272  0102
    273  0102		       4c 32 fa 	      jmp	DrawAnother	; 3 =	3
    274  0105
    275  0105							; Timing for PF0Draw
    276  0105							; 7+63 = 70
    277  0105							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    278  0105
    279  0105
    280  0105							;------------------------------------------------------------------------------
    281  0105							; Direct draw draws to PF0, which only has one active member of the character
    282  0105							; pair -- so it can be a direct copy.	Quicker still!
    283  0105
    284  0105				   DirectDraw		; 37 cycles until here
    285  0105
    286  0105							;ldy #16
    287  0105		       ad 84 02 	      lda	INTIM	; 4
    288  0108		       c9 06		      cmp	#SEGTIME_SCD_DIRECT	; 2
    289  010a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  010c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  010c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  010c				  -
      3  010c				  -
      4  010c				  -
      5  010c				  -
      6  010c				  -
      7  010c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  010c				  -	      bne	. - 7
      9  010c					      ENDIF
    291  010c
    292  010c							; TIME REQUIRED FROM HERE (9/JAN)
    293  010c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    294  010c							; = 323 --> /64 = 5.04 USE 7
    295  010c
    296  010c		       b9 fa f2 	      lda	CharacterDataVecHI,y	; 4
    297  010f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    298  0112		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    299  0115		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    300  0118
    301  0118		       b9 e6 f2 	      lda	CharacterDataVecLO,y	; 4
    302  011b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    303  011e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    304  0120		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    305  0123		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    306  0125		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    307  0128
    308  0128		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    309  012b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    310  012e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    311  0130		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    312  0133		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    313  0135		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    314  0138
    315  0138		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    316  013a				   TSFill3
    317  013a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    318  013d		       99 3e f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    319  0140		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    320  0143		       99 3e f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    321  0146		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    322  0149		       99 3e f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    323  014c
    324  014c		       88		      dey		; 2
      0  014d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  014d					      LIST	ON
      9  014d		       10 eb		      bpl	TSFill3
    326  014f
    327  014f		       4c 32 fa 	      jmp	DrawAnother	; 3
    328  0152
    329  0152							; Timing for DirectDraw
    330  0152							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    331  0152							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    332  0152
    333  0152				   ExitDraw
    334  0152		       60		      rts
    335  0153
    336  0153							;------------------------------------------------------------------------------
      0  0153					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  0153		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0153					      SUBROUTINE
      3  0153				   StealPart3
    338  0153
    339  0153		       bd ee f1 	      lda	MOD10,x	; 4
    340  0156		       30 81		      bmi	PF0Draw	; 2/3
    341  0158		       4a		      lsr		; 2
    342  0159		       aa		      tax		; 2
    343  015a		       98		      tya		; 2
    344  015b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    345  015c		       a8		      tay		; 2
    346  015d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    347  015f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    348  015f
    349  015f		       b9 fa f2 	      lda	CharacterDataVecHI,y	; 4
    350  0162		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    351  0164							;	     => 42 starting QuickDraw
    352  0164		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    353  0167
    354  0167		       ad 84 02 	      lda	INTIM	; 4
    355  016a		       c9 0a		      cmp	#SEGTIME_SCD_SLOW	; 2
    356  016c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  016e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  016e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  016e				  -
      3  016e				  -
      4  016e				  -
      5  016e				  -
      6  016e				  -
      7  016e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  016e				  -	      bne	. - 7
      9  016e					      ENDIF
    358  016e
    359  016e							; TIME REQUIRED FROM HERE (9/JAN)
    360  016e							; 8 + 16 + 8 + 2 + (21 * 24) -1 + (42 OVERHEAD WHEN RETURNING)
    361  016e							; = 579 --> /64 = 9.04 INTIM --> USE 10
    362  016e
    363  016e		       b9 e6 f2 	      lda	CharacterDataVecLO,y	; 4
    364  0171		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    365  0174
    366  0174		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    367  0177		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    368  017a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    369  017d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    370  0180
    371  0180		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    372  0183		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    373  0186
    374  0186		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    375  0188
    376  0188							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    377  0188							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    378  0188
    379  0188				   TSFill
    380  0188
    381  0188		       b9 3e f2    SMLOAD     lda	ScreenBitmap,y	; 4
    382  018b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    383  018e		       29 00	   SMMASK     and	#0	; 2
    384  0190		       59 3e f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    385  0193		       99 3e f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    386  0196
    387  0196		       88		      dey		; 2
      0  0197					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  0197					      LIST	ON
      9  0197		       10 ef		      bpl	TSFill
    389  0199
    390  0199		       4c 32 fa 	      jmp	DrawAnother	; 3
    391  019c
    392  019c							; Timing for "SLOW" draw
    393  019c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    394  019c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    395  019c
    396  019c
    397  019c							;------------------------------------------------------------------------------
    398  019c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    399  019c							; existing character data, so can be special-cased from the normal character
    400  019c							; draw, saving roughly 230 cycles.
    401  019c
    402  019c				   QuickDraw		; 42 cycles until here
    403  019c
    404  019c		       ad 84 02 	      lda	INTIM	; 4
    405  019f		       c9 06		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    406  01a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  01a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  01a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  01a3				  -
      3  01a3				  -
      4  01a3				  -
      5  01a3				  -
      6  01a3				  -
      7  01a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  01a3				  -	      bne	. - 7
      9  01a3					      ENDIF
    408  01a3
    409  01a3							; TIME REQUIRED FROM HERE (9/JAN)
    410  01a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    411  01a3							;   = 348 --> /64 = 5.43. USE 7
    412  01a3
    413  01a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    414  01a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    415  01a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    416  01ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    417  01ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    418  01b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    419  01b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    420  01b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    421  01b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    422  01bc
    423  01bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    424  01bf
    425  01bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    426  01c1				   TSFill2
    427  01c1		       98		      tya		; 2
    428  01c2		       3d 3e f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    429  01c5		       9d 3e f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    430  01c8		       98		      tya		; 2
    431  01c9		       3d 3e f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    432  01cc		       9d 3e f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    433  01cf		       98		      tya		; 2
    434  01d0		       3d 3e f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    435  01d3		       9d 3e f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    436  01d6
    437  01d6		       ca		      dex		; 2
      0  01d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  01d7					      LIST	ON
      9  01d7		       10 e8		      bpl	TSFill2
    439  01d9
    440  01d9		       4c 32 fa 	      jmp	DrawAnother	; 3
    441  01dc
    442  01dc							; Timing for QuickDraw
    443  01dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    444  01dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    445  01dc
    446  01dc
    447  01dc							;------------------------------------------------------------------------------
    448  01dc
    449  01dc
    450  01dc				   CharAddressLO		;[abs char location % 10]
    451  01dc
    452  01dc							; Gives the absolute screen buffer address of the first line of the given character
    453  01dc							; Where character number is 0-9
    454  01dc
    455  01dc		       3e		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    456  01dd		       3e		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    457  01de		       53		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    458  01df		       53		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    459  01e0		       68		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    460  01e1		       68		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    461  01e2		       7d		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    462  01e3		       7d		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    463  01e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    464  01e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    465  01e4
    466  01e4				   CharMask		; [abs char location % 10]
    467  01e4
    468  01e4							; Gives the mask for any char of the screen (per row)
    469  01e4							; Note, this is hardwired to the screen format of 6 bytes/line
    470  01e4
    471  01e4		       0f		      .byte.b	$0F	; 1
    472  01e5		       f0		      .byte.b	$F0	; 2
    473  01e6				   CharMaskNeg
    474  01e6		       f0		      .byte.b	$F0	; 3/1
    475  01e7		       0f		      .byte.b	$0F	; 4/2
    476  01e8		       0f		      .byte.b	$0F	; 6/3
    477  01e9		       f0		      .byte.b	$F0	; 7/4
    478  01ea		       f0		      .byte.b	$F0	; 8/6
    479  01eb		       0f		      .byte.b	$0F	; 9/7
    480  01ec		       0f		      .byte.b	$0F	; -/8
    481  01ed		       f0		      .byte.b	$F0	; -/9
    482  01ee				   MOD10
    483  01ee					      REPEAT	SCREEN_LINES
    484  01ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01ee		       80		      .byte.b	DIRECT
    487  01ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01f4					      REPEND
    484  01f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01f8		       80		      .byte.b	DIRECT
    487  01f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01fe					      REPEND
    484  0202							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0202							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0202		       80		      .byte.b	DIRECT
    487  0203		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0207		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0208		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0208					      REPEND
    484  020c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  020c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  020c		       80		      .byte.b	DIRECT
    487  020d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0211		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0212		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0212					      REPEND
    484  0216							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0216							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0216		       80		      .byte.b	DIRECT
    487  0217		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  021b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  021c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  021c					      REPEND
    484  0220							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0220							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0220		       80		      .byte.b	DIRECT
    487  0221		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0225		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0226		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0226					      REPEND
    484  022a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  022a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  022a		       80		      .byte.b	DIRECT
    487  022b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  022f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0230		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0230					      REPEND
    484  0234							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0234							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0234		       80		      .byte.b	DIRECT
    487  0235		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0239		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  023a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  023e					      REPEND
    491  023e
    492  023e							;------------------------------------------------------------------------------
    493  023e
      0  023e					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  023e					      LIST	ON
    495  023e
    496  023e		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,0	; character bitmap row (10 chars wide)
    497  023e		       f2 3e	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    498  023e		       f2 45	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    499  023e		       f2 4c	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    500  0292
      0  0292					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  0292					      LIST	ON
    502  0292
    503  0292
    504  0292							;--------------------------------------------------------------------------
    505  0292
      0  0292					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  0292		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  0292					      SUBROUTINE
      3  0292				   SelfModDrawPlayers
    507  0292
    508  0292							; Now the player(s) have animated, update the appropriate shape pointers
    509  0292							; in the draw code.
    510  0292
    511  0292							; Sets the shapes to a blank player -- effectively erasing
    512  0292		       a5 b1		      lda	LastSpriteY
    513  0294		       a2 bc		      ldx	#<PLAYER_BLANK
    514  0296		       20 a5 f2 	      jsr	SetSelfModPlayer
    515  0299
    516  0299							; Now we've erased, we write the new shape
    517  0299
    518  0299							;		  sec
    519  0299							;		  lda ManDrawX
    520  0299							;		  sbc BoardScrollX
    521  0299							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    522  0299							;		  bcs NoMod				  ; skip if off visible screen
    523  0299
    524  0299		       a5 9d		      lda	ManDrawX
    525  029b		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    526  029d		       b0 1c		      bcs	NoMod	; skip if off visible screen
    527  029f
    528  029f							;lda LookingAround
    529  029f							;bne NoMod
    530  029f
    531  029f		       a5 9e		      lda	ManDrawY
    532  02a1		       85 b1		      sta	LastSpriteY
    533  02a3
    534  02a3		       a6 a3		      ldx	ManAnimationFrameLO
    535  02a5
    536  02a5				   SetSelfModPlayer
    537  02a5		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    538  02a7		       b0 12		      bcs	NoMod
    539  02a9		       69 00		      adc	#BANK_SCREENMARKII1
    540  02ab		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    541  02ad
    542  02ad		       8a		      txa
    543  02ae		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    544  02b1		       69 07		      adc	#LINES_PER_CHAR/3
    545  02b3		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    546  02b6		       69 07		      adc	#LINES_PER_CHAR/3
    547  02b8		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    548  02bb
    549  02bb		       60	   NoMod      rts
    550  02bc
      0  02bc					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  02bc
      2  02bc
      3  02bc		       02 bc	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $2bc , FREE= $144
      4  02bc					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  02bc				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  02bc				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  02bc				  -	      ERR
      8  02bc					      endif
    552  02bc
------- FILE player.asm LEVEL 3 PASS 4
      0  02bc					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  02bc							;    Sokoboo - a Sokoban implementation
      2  02bc							;    using a generic tile-based display engine for the Atari 2600
      3  02bc							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  02bc							;
      5  02bc							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  02bc							;
      7  02bc							;    Code related to the generic tile-based display engine was developed by
      8  02bc							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  02bc							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  02bc							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  02bc							;
     12  02bc							;    Code related to music and sound effects uses the TIATracker music player
     13  02bc							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  02bc							;    directory for Apache licensing details.
     15  02bc							;
     16  02bc							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  02bc							;    See the copyright notices in the License directory for a list of level
     18  02bc							;    contributors.
     19  02bc							;
     20  02bc							;    Except where otherwise indicated, this software is released under the
     21  02bc							;    following licensing arrangement...
     22  02bc							;
     23  02bc							;    This program is free software: you can redistribute it and/or modify
     24  02bc							;    it under the terms of the GNU General Public License as published by
     25  02bc							;    the Free Software Foundation, either version 3 of the License, or
     26  02bc							;    (at your option) any later version.
     27  02bc							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  02bc
     29  02bc							;    This program is distributed in the hope that it will be useful,
     30  02bc							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  02bc							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  02bc							;    GNU General Public License for more details.
     33  02bc
     34  02bc							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
     35  02bc
     36  02bc
     37  02bc		       f2 bc	   PLAYER_BLANK =	.
     38  02bc					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
     39  02bc		       00		      .byte.b	0
     38  02bc					      REPEND
     39  02bd		       00		      .byte.b	0
     38  02bd					      REPEND
     39  02be		       00		      .byte.b	0
     38  02be					      REPEND
     39  02bf		       00		      .byte.b	0
     38  02bf					      REPEND
     39  02c0		       00		      .byte.b	0
     38  02c0					      REPEND
     39  02c1		       00		      .byte.b	0
     38  02c1					      REPEND
     39  02c2		       00		      .byte.b	0
     38  02c2					      REPEND
     39  02c3		       00		      .byte.b	0
     38  02c3					      REPEND
     39  02c4		       00		      .byte.b	0
     38  02c4					      REPEND
     39  02c5		       00		      .byte.b	0
     38  02c5					      REPEND
     39  02c6		       00		      .byte.b	0
     38  02c6					      REPEND
     39  02c7		       00		      .byte.b	0
     38  02c7					      REPEND
     39  02c8		       00		      .byte.b	0
     38  02c8					      REPEND
     39  02c9		       00		      .byte.b	0
     38  02c9					      REPEND
     39  02ca		       00		      .byte.b	0
     38  02ca					      REPEND
     39  02cb		       00		      .byte.b	0
     38  02cb					      REPEND
     39  02cc		       00		      .byte.b	0
     38  02cc					      REPEND
     39  02cd		       00		      .byte.b	0
     38  02cd					      REPEND
     39  02ce		       00		      .byte.b	0
     38  02ce					      REPEND
     39  02cf		       00		      .byte.b	0
     38  02cf					      REPEND
     39  02d0		       00		      .byte.b	0
     40  02d1					      REPEND
     41  02d1
     42  02d1				   PLAYER_RIGHT0
     43  02d1
     44  02d1					      if	1
     45  02d1		       18		      .byte.b	%00011000	;20
     46  02d2		       18		      .byte.b	%00011000	;20
     47  02d3		       7e		      .byte.b	%01111110	;20
     48  02d4		       7e		      .byte.b	%01111110	;20
     49  02d5		       7e		      .byte.b	%01111110	;20
     50  02d6		       18		      .byte.b	%00011000	;20
     51  02d7		       18		      .byte.b	%00011000	;20
     52  02d8
     53  02d8		       18		      .byte.b	%00011000	;20
     54  02d9		       18		      .byte.b	%00011000	;20
     55  02da		       7e		      .byte.b	%01111110	;20
     56  02db		       7e		      .byte.b	%01111110	;20
     57  02dc		       7e		      .byte.b	%01111110	;20
     58  02dd		       18		      .byte.b	%00011000	;20
     59  02de		       18		      .byte.b	%00011000	;20
     60  02df
     61  02df		       18		      .byte.b	%00011000	;20
     62  02e0		       18		      .byte.b	%00011000	;20
     63  02e1		       7e		      .byte.b	%01111110	;20
     64  02e2		       7e		      .byte.b	%01111110	;20
     65  02e3		       7e		      .byte.b	%01111110	;20
     66  02e4		       18		      .byte.b	%00011000	;20
     67  02e5		       18		      .byte.b	%00011000	;20
     68  02e6
     69  02e6				  -	      else
     70  02e6				  -			;push
     71  02e6				  -	      .byte	#%01110000	;$1C 0
     72  02e6				  -	      .byte	#%01110000	;$78 3
     73  02e6				  -	      .byte	#%00010000	;$52 6
     74  02e6				  -	      .byte	#%00111100	;$52 9
     75  02e6				  -	      .byte	#%00011001	;$0C 12
     76  02e6				  -	      .byte	#%00001100	;$4A 15
     77  02e6				  -	      .byte	#%00001111	;$1A18
     78  02e6				  -
     79  02e6				  -	      .byte	#%10100000	;$1C 1
     80  02e6				  -	      .byte	#%00111000	;$78 4
     81  02e6				  -	      .byte	#%00111000	;$52 7
     82  02e6				  -	      .byte	#%00111100	;$56 10
     83  02e6				  -	      .byte	#%00001000	;$4A 13
     84  02e6				  -	      .byte	#%00001100	;$4A 16
     85  02e6				  -	      .byte	#%00001100	;$1C 19
     86  02e6				  -
     87  02e6				  -	      .byte	#%11010000	;$78 2
     88  02e6				  -	      .byte	#%00101000	;$78 5
     89  02e6				  -	      .byte	#%00111000	;$52 8
     90  02e6				  -	      .byte	#%00011111	;$56 11
     91  02e6				  -	      .byte	#%00001000	;$4A 14
     92  02e6				  -	      .byte	#%00011010	;$4A 17
     93  02e6				  -	      .byte	#%00001100	;$1C 20
     94  02e6				  -
     95  02e6					      endif
     96  02e6
     97  02e6				  -	      IF	0
     98  02e6				  -			;---Graphics Data from PlayerPal 2600---
     99  02e6				  -
    100  02e6				  -Frame0
    101  02e6				  -	      .byte	#%01110011	;$1C
    102  02e6				  -	      .byte	#%00100110	;$1C
    103  02e6				  -	      .byte	#%00110100	;$78
    104  02e6				  -	      .byte	#%00010100	;$78
    105  02e6				  -	      .byte	#%00011100	;$78
    106  02e6				  -	      .byte	#%00001000	;$78
    107  02e6				  -	      .byte	#%00010000	;$52
    108  02e6				  -	      .byte	#%00111000	;$52
    109  02e6				  -	      .byte	#%00111000	;$52
    110  02e6				  -	      .byte	#%10111000	;$52
    111  02e6				  -	      .byte	#%01111000	;$56
    112  02e6				  -	      .byte	#%00110000	;$56
    113  02e6				  -	      .byte	#%00111100	;$0C
    114  02e6				  -	      .byte	#%00110010	;$4A
    115  02e6				  -	      .byte	#%00010000	;$4A
    116  02e6				  -	      .byte	#%00011000	;$4A
    117  02e6				  -	      .byte	#%00011000	;$4A
    118  02e6				  -	      .byte	#%00110100	;$4A
    119  02e6				  -	      .byte	#%00011110	;$1A
    120  02e6				  -	      .byte	#%00011000	;$1C
    121  02e6				  -	      .byte	#%00011000	;$1C
    122  02e6				  -Frame1
    123  02e6				  -	      .byte	#%00110110	;$1C
    124  02e6				  -	      .byte	#%00100100	;$1C
    125  02e6				  -	      .byte	#%00010100	;$78
    126  02e6				  -	      .byte	#%00010100	;$78
    127  02e6				  -	      .byte	#%00011100	;$78
    128  02e6				  -	      .byte	#%00001000	;$78
    129  02e6				  -	      .byte	#%00010000	;$52
    130  02e6				  -	      .byte	#%00111000	;$52
    131  02e6				  -	      .byte	#%00011000	;$52
    132  02e6				  -	      .byte	#%01111000	;$52
    133  02e6				  -	      .byte	#%00111000	;$56
    134  02e6				  -	      .byte	#%00110110	;$56
    135  02e6				  -	      .byte	#%00111100	;$0C
    136  02e6				  -	      .byte	#%00010000	;$4A
    137  02e6				  -	      .byte	#%00010000	;$4A
    138  02e6				  -	      .byte	#%00011000	;$4A
    139  02e6				  -	      .byte	#%00011000	;$4A
    140  02e6				  -	      .byte	#%00110100	;$4A
    141  02e6				  -	      .byte	#%00011110	;$1A
    142  02e6				  -	      .byte	#%00011000	;$1C
    143  02e6				  -	      .byte	#%00011000	;$1C
    144  02e6				  -Frame2
    145  02e6				  -	      .byte	#%00011000	;$1C
    146  02e6				  -	      .byte	#%00110000	;$1C
    147  02e6				  -	      .byte	#%01010000	;$78
    148  02e6				  -	      .byte	#%00111000	;$78
    149  02e6				  -	      .byte	#%00011000	;$78
    150  02e6				  -	      .byte	#%00001000	;$78
    151  02e6				  -	      .byte	#%00010000	;$52
    152  02e6				  -	      .byte	#%00111000	;$52
    153  02e6				  -	      .byte	#%00111000	;$52
    154  02e6				  -	      .byte	#%00111100	;$52
    155  02e6				  -	      .byte	#%00110100	;$56
    156  02e6				  -	      .byte	#%00111100	;$56
    157  02e6				  -	      .byte	#%00111000	;$0C
    158  02e6				  -	      .byte	#%00010000	;$4A
    159  02e6				  -	      .byte	#%00010000	;$4A
    160  02e6				  -	      .byte	#%00011000	;$4A
    161  02e6				  -	      .byte	#%00011000	;$4A
    162  02e6				  -	      .byte	#%00110100	;$4A
    163  02e6				  -	      .byte	#%00011110	;$1A
    164  02e6				  -	      .byte	#%00011000	;$1C
    165  02e6				  -	      .byte	#%00011000	;$1C
    166  02e6				  -Frame3
    167  02e6				  -	      .byte	#%01110000	;$1C
    168  02e6				  -	      .byte	#%10100000	;$1C
    169  02e6				  -	      .byte	#%11010000	;$78
    170  02e6				  -	      .byte	#%01110000	;$78
    171  02e6				  -	      .byte	#%00111000	;$78
    172  02e6				  -	      .byte	#%00101000	;$78
    173  02e6				  -	      .byte	#%00010000	;$52
    174  02e6				  -	      .byte	#%00111000	;$52
    175  02e6				  -	      .byte	#%00111000	;$52
    176  02e6				  -	      .byte	#%00111100	;$52
    177  02e6				  -	      .byte	#%00111100	;$56
    178  02e6				  -	      .byte	#%00011111	;$56
    179  02e6				  -	      .byte	#%00011001	;$0C
    180  02e6				  -	      .byte	#%00001000	;$4A
    181  02e6				  -	      .byte	#%00001000	;$4A
    182  02e6				  -	      .byte	#%00001100	;$4A
    183  02e6				  -	      .byte	#%00001100	;$4A
    184  02e6				  -	      .byte	#%00011010	;$4A
    185  02e6				  -	      .byte	#%00001111	;$1A
    186  02e6				  -	      .byte	#%00001100	;$1C
    187  02e6				  -	      .byte	#%00001100	;$1C
    188  02e6				  -Frame4
    189  02e6				  -	      .byte	#%00110110	;$1C
    190  02e6				  -	      .byte	#%00010100	;$1C
    191  02e6				  -	      .byte	#%00010100	;$78
    192  02e6				  -	      .byte	#%00010100	;$78
    193  02e6				  -	      .byte	#%00011100	;$78
    194  02e6				  -	      .byte	#%00001100	;$78
    195  02e6				  -	      .byte	#%00010000	;$52
    196  02e6				  -	      .byte	#%00011000	;$52
    197  02e6				  -	      .byte	#%00011100	;$52
    198  02e6				  -	      .byte	#%00111100	;$52
    199  02e6				  -	      .byte	#%00111100	;$56
    200  02e6				  -	      .byte	#%00111100	;$56
    201  02e6				  -	      .byte	#%00111110	;$0C
    202  02e6				  -	      .byte	#%01011010	;$4A
    203  02e6				  -	      .byte	#%10010001	;$4A
    204  02e6				  -	      .byte	#%10011001	;$4A
    205  02e6				  -	      .byte	#%00011000	;$4A
    206  02e6				  -	      .byte	#%00011000	;$4A
    207  02e6				  -	      .byte	#%00011100	;$1A
    208  02e6				  -	      .byte	#%00011000	;$1C
    209  02e6				  -	      .byte	#%00010000	;$1C
    210  02e6				  -Frame5
    211  02e6				  -	      .byte	#%00110110	;$1C
    212  02e6				  -	      .byte	#%00010100	;$1C
    213  02e6				  -	      .byte	#%00010100	;$78
    214  02e6				  -	      .byte	#%00010100	;$78
    215  02e6				  -	      .byte	#%00011100	;$78
    216  02e6				  -	      .byte	#%01001101	;$78
    217  02e6				  -	      .byte	#%01010001	;$52
    218  02e6				  -	      .byte	#%01011011	;$52
    219  02e6				  -	      .byte	#%01011110	;$52
    220  02e6				  -	      .byte	#%00111100	;$52
    221  02e6				  -	      .byte	#%00111100	;$56
    222  02e6				  -	      .byte	#%00011100	;$56
    223  02e6				  -	      .byte	#%00011000	;$0C
    224  02e6				  -	      .byte	#%00011000	;$4A
    225  02e6				  -	      .byte	#%00011000	;$4A
    226  02e6				  -	      .byte	#%00111000	;$4A
    227  02e6				  -	      .byte	#%00001000	;$4A
    228  02e6				  -	      .byte	#%00000000	;$4A
    229  02e6				  -	      .byte	#%00000000	;$1A
    230  02e6				  -	      .byte	#%00000000	;$1C
    231  02e6				  -	      .byte	#%00000000	;$1C
    232  02e6				  -			;---End Graphics Data---
    233  02e6				  -
    234  02e6				  -
    235  02e6				  -			;---Color Data from PlayerPal 2600---
    236  02e6				  -
    237  02e6				  -ColorFrame0
    238  02e6				  -	      .byte	#$1C	;
    239  02e6				  -	      .byte	#$1C	;
    240  02e6				  -	      .byte	#$78	;
    241  02e6				  -	      .byte	#$78	;
    242  02e6				  -	      .byte	#$78	;
    243  02e6				  -	      .byte	#$78	;
    244  02e6				  -	      .byte	#$52	;
    245  02e6				  -	      .byte	#$52	;
    246  02e6				  -	      .byte	#$52	;
    247  02e6				  -	      .byte	#$52	;
    248  02e6				  -	      .byte	#$56	;
    249  02e6				  -	      .byte	#$56	;
    250  02e6				  -	      .byte	#$0C	;
    251  02e6				  -	      .byte	#$4A	;
    252  02e6				  -	      .byte	#$4A	;
    253  02e6				  -	      .byte	#$4A	;
    254  02e6				  -	      .byte	#$4A	;
    255  02e6				  -	      .byte	#$4A	;
    256  02e6				  -	      .byte	#$1A	;
    257  02e6				  -	      .byte	#$1C	;
    258  02e6				  -	      .byte	#$1C	;
    259  02e6				  -ColorFrame1
    260  02e6				  -	      .byte	#$1C	;
    261  02e6				  -	      .byte	#$1C	;
    262  02e6				  -	      .byte	#$78	;
    263  02e6				  -	      .byte	#$78	;
    264  02e6				  -	      .byte	#$78	;
    265  02e6				  -	      .byte	#$78	;
    266  02e6				  -	      .byte	#$52	;
    267  02e6				  -	      .byte	#$52	;
    268  02e6				  -	      .byte	#$52	;
    269  02e6				  -	      .byte	#$52	;
    270  02e6				  -	      .byte	#$56	;
    271  02e6				  -	      .byte	#$56	;
    272  02e6				  -	      .byte	#$0C	;
    273  02e6				  -	      .byte	#$4A	;
    274  02e6				  -	      .byte	#$4A	;
    275  02e6				  -	      .byte	#$4A	;
    276  02e6				  -	      .byte	#$4A	;
    277  02e6				  -	      .byte	#$4A	;
    278  02e6				  -	      .byte	#$1A	;
    279  02e6				  -	      .byte	#$1C	;
    280  02e6				  -	      .byte	#$1C	;
    281  02e6				  -ColorFrame2
    282  02e6				  -	      .byte	#$1C	;
    283  02e6				  -	      .byte	#$1C	;
    284  02e6				  -	      .byte	#$78	;
    285  02e6				  -	      .byte	#$78	;
    286  02e6				  -	      .byte	#$78	;
    287  02e6				  -	      .byte	#$78	;
    288  02e6				  -	      .byte	#$52	;
    289  02e6				  -	      .byte	#$52	;
    290  02e6				  -	      .byte	#$52	;
    291  02e6				  -	      .byte	#$52	;
    292  02e6				  -	      .byte	#$56	;
    293  02e6				  -	      .byte	#$56	;
    294  02e6				  -	      .byte	#$0C	;
    295  02e6				  -	      .byte	#$4A	;
    296  02e6				  -	      .byte	#$4A	;
    297  02e6				  -	      .byte	#$4A	;
    298  02e6				  -	      .byte	#$4A	;
    299  02e6				  -	      .byte	#$4A	;
    300  02e6				  -	      .byte	#$1A	;
    301  02e6				  -	      .byte	#$1C	;
    302  02e6				  -	      .byte	#$1C	;
    303  02e6				  -ColorFrame3
    304  02e6				  -	      .byte	#$1C	;
    305  02e6				  -	      .byte	#$1C	;
    306  02e6				  -	      .byte	#$78	;
    307  02e6				  -	      .byte	#$78	;
    308  02e6				  -	      .byte	#$78	;
    309  02e6				  -	      .byte	#$78	;
    310  02e6				  -	      .byte	#$52	;
    311  02e6				  -	      .byte	#$52	;
    312  02e6				  -	      .byte	#$52	;
    313  02e6				  -	      .byte	#$52	;
    314  02e6				  -	      .byte	#$56	;
    315  02e6				  -	      .byte	#$56	;
    316  02e6				  -	      .byte	#$0C	;
    317  02e6				  -	      .byte	#$4A	;
    318  02e6				  -	      .byte	#$4A	;
    319  02e6				  -	      .byte	#$4A	;
    320  02e6				  -	      .byte	#$4A	;
    321  02e6				  -	      .byte	#$4A	;
    322  02e6				  -	      .byte	#$1A	;
    323  02e6				  -	      .byte	#$1C	;
    324  02e6				  -	      .byte	#$1C	;
    325  02e6				  -ColorFrame4
    326  02e6				  -	      .byte	#$1C	;
    327  02e6				  -	      .byte	#$1C	;
    328  02e6				  -	      .byte	#$78	;
    329  02e6				  -	      .byte	#$78	;
    330  02e6				  -	      .byte	#$78	;
    331  02e6				  -	      .byte	#$78	;
    332  02e6				  -	      .byte	#$52	;
    333  02e6				  -	      .byte	#$52	;
    334  02e6				  -	      .byte	#$52	;
    335  02e6				  -	      .byte	#$52	;
    336  02e6				  -	      .byte	#$56	;
    337  02e6				  -	      .byte	#$56	;
    338  02e6				  -	      .byte	#$0C	;
    339  02e6				  -	      .byte	#$4A	;
    340  02e6				  -	      .byte	#$4A	;
    341  02e6				  -	      .byte	#$4A	;
    342  02e6				  -	      .byte	#$4A	;
    343  02e6				  -	      .byte	#$4A	;
    344  02e6				  -	      .byte	#$1A	;
    345  02e6				  -	      .byte	#$1C	;
    346  02e6				  -	      .byte	#$1C	;
    347  02e6				  -ColorFrame5
    348  02e6				  -	      .byte	#$1C	;
    349  02e6				  -	      .byte	#$1C	;
    350  02e6				  -	      .byte	#$78	;
    351  02e6				  -	      .byte	#$78	;
    352  02e6				  -	      .byte	#$78	;
    353  02e6				  -	      .byte	#$78	;
    354  02e6				  -	      .byte	#$52	;
    355  02e6				  -	      .byte	#$52	;
    356  02e6				  -	      .byte	#$52	;
    357  02e6				  -	      .byte	#$52	;
    358  02e6				  -	      .byte	#$56	;
    359  02e6				  -	      .byte	#$56	;
    360  02e6				  -	      .byte	#$0C	;
    361  02e6				  -	      .byte	#$4A	;
    362  02e6				  -	      .byte	#$4A	;
    363  02e6				  -	      .byte	#$4A	;
    364  02e6				  -	      .byte	#$4A	;
    365  02e6				  -	      .byte	#$4A	;
    366  02e6				  -	      .byte	#$1A	;
    367  02e6				  -	      .byte	#$1C	;
    368  02e6				  -	      .byte	#$1C	;
    369  02e6				  -			;---End Color Data---
    370  02e6					      ENDIF
    371  02e6
    372  02e6
    373  02e6							;.byte %00011000  ;  XXX   ; 0
    374  02e6							;.byte %00111100  ;XXXXXX  ; 1
    375  02e6							;.byte %01110100  ;XXXX X  ; 2 etc.
    376  02e6							;.byte %01111100  ;XXXXXX  ; 3
    377  02e6							;.byte %00111000  ;XXXXX   ;4
    378  02e6							;.byte %01111100  ; XXXXX  ;5
    379  02e6							;.byte %00111000  ;  XXX   ;6
    380  02e6							;.byte %11111000  ;XXXXX   ;7
    381  02e6							;.byte %11111100  ;XXXXXX  ;8
    382  02e6							;.byte %11111100  ;XXXXXX  ;9 etc.
    383  02e6							;.byte %10000100  ;X	 X  ;10
    384  02e6							;.byte %11111100  ;XXXXXX  ;11
    385  02e6							;.byte %00001100  ;	XX  ;12
    386  02e6							;.byte %01111100  ; XXXXX  ;13
    387  02e6							;.byte %01111100  ; XXXXX  ;14
    388  02e6							;.byte %01111000  ; XXXX   ;15
    389  02e6							;.byte %01111000  ; XXXX   ;16 etc.
    390  02e6							;.byte %11111000  ;XXXXX   ;17
    391  02e6							;.byte %11101100  ;XXX XX  ;18
    392  02e6							;.byte %10111100  ;X XXXX  ;19
    393  02e6							;.byte %11001100  ;XX	XX   20
    394  02e6
    395  02e6							;---Graphics Data from PlayerPal 2600---
    396  02e6
    397  02e6				   PLAYER_RIGHT1
    398  02e6				   PLAYER_STAND
    399  02e6				   PLAYER_BLINK
    400  02e6				   PLAYER_TAP0
    401  02e6				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    554  02e6
    555  02e6							;------------------------------------------------------------------------------
    556  02e6
    557  02e6							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    558  02e6
    559  02e6							;------------------------------------------------------------------------------
    560  02e6
    561  02e6
    562  02e6
    563  02e6
    564  02e6				   OBJTYPE    SET	0
    565  02e6					      MAC	define_character
    566  02e6				   CHARACTER_{1} =	OBJTYPE
    567  02e6				   OBJTYPE    .SET	OBJTYPE + 1
    568  02e6					      ENDM
    569  02e6
    570  02e6							; Modifications to character #/order must also ensure the following are correct...
    571  02e6							;   CharacterDataVecLO/HI	   in this file
    572  02e6							;   MoveVecLO/HI		   in BANK_INITBANK
    573  02e6							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    574  02e6
      0  02e6					      DEFINE_CHARACTER	BLANK
      1  02e6		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	SOIL
      1  02e6		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	BOX
      1  02e6		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	TARGET
      1  02e6		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	TARGET2
      1  02e6		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	MANOCCUPIED
      1  02e6		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	STEEL
      1  02e6		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	WALL
      1  02e6		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  02e6		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	NOGO
      1  02e6		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
    585  02e6
      0  02e6					      DEFINE_CHARACTER	MAXIMUM
      1  02e6		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
    587  02e6
    588  02e6
    589  02e6				   CharacterDataVecLO
    590  02e6
    591  02e6							; Two entries per character.  2nd is ptr to mirrored character
    592  02e6							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    593  02e6
    594  02e6		       bc		      .byte.b	<CHARACTERSHAPE_BLANK
    595  02e7		       bc		      .byte.b	<CHARACTERSHAPE_BLANK
    596  02e8		       61		      .byte.b	<CHARACTERSHAPE_SOIL
    597  02e9		       61		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    598  02ea		       76		      .byte.b	<CHARACTERSHAPE_BOX
    599  02eb		       8b		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    600  02ec		       0e		      .byte.b	<CHARACTERSHAPE_TARGET
    601  02ed		       0e		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    602  02ee		       22		      .byte.b	<CHARACTERSHAPE_TARGET2
    603  02ef		       22		      .byte.b	<CHARACTERSHAPE_TARGET2_MIRRORED
    604  02f0		       bc		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    605  02f1		       bc		      .byte.b	<CHARACTERSHAPE_BLANK
    606  02f2		       37		      .byte.b	<CHARACTERSHAPE_STEEL
    607  02f3		       4c		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    608  02f4		       ca		      .byte.b	<CHARACTERSHAPE_WALL
    609  02f5		       df		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    610  02f6		       a0		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    611  02f7		       b5		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    612  02f8		       bc		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    613  02f9		       bc		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    614  02fa
    615  02fa				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    616  02fa				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    617  02fa				  -	      ERR
    618  02fa					      ENDIF
    619  02fa
    620  02fa							;---------------------------------------------------------------------------
    621  02fa
    622  02fa				   CharacterDataVecHI
    623  02fa
    624  02fa		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    625  02fb		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    626  02fc		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
    627  02fd		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    628  02fe		       f3		      .byte.b	>CHARACTERSHAPE_BOX
    629  02ff		       f3		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    630  0300		       f3		      .byte.b	>CHARACTERSHAPE_TARGET
    631  0301		       f3		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    632  0302		       f3		      .byte.b	>CHARACTERSHAPE_TARGET2
    633  0303		       f3		      .byte.b	>CHARACTERSHAPE_TARGET2_MIRRORED
    634  0304		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    635  0305		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    636  0306		       f3		      .byte.b	>CHARACTERSHAPE_STEEL
    637  0307		       f3		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    638  0308		       f3		      .byte.b	>CHARACTERSHAPE_WALL
    639  0309		       f3		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    640  030a		       f3		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    641  030b		       f3		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    642  030c		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    643  030d		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    644  030e
    645  030e				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    646  030e				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    647  030e				  -	      ERR
    648  030e					      ENDIF
    649  030e
    650  030e							; Here there's another 1K of usable ROM....
    651  030e							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    652  030e
    653  030e							;--------------------------------------------------------------------------
    654  030e							;    CHARACTER_SET
    655  030e
------- FILE characterset/character_TARGET.asm LEVEL 3 PASS 4
      0  030e					      include	"characterset/character_TARGET.asm"
      1  030e							;    Sokoboo - a Sokoban implementation
      2  030e							;    using a generic tile-based display engine for the Atari 2600
      3  030e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  030e							;
      5  030e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  030e							;
      7  030e							;    Code related to the generic tile-based display engine was developed by
      8  030e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  030e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  030e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  030e							;
     12  030e							;    Code related to music and sound effects uses the TIATracker music player
     13  030e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  030e							;    directory for Apache licensing details.
     15  030e							;
     16  030e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  030e							;    See the copyright notices in the License directory for a list of level
     18  030e							;    contributors.
     19  030e							;
     20  030e							;    Except where otherwise indicated, this software is released under the
     21  030e							;    following licensing arrangement...
     22  030e							;
     23  030e							;    This program is free software: you can redistribute it and/or modify
     24  030e							;    it under the terms of the GNU General Public License as published by
     25  030e							;    the Free Software Foundation, either version 3 of the License, or
     26  030e							;    (at your option) any later version.
     27  030e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  030e
     29  030e							;    This program is distributed in the hope that it will be useful,
     30  030e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  030e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  030e							;    GNU General Public License for more details.
     33  030e
     34  030e		       00 02	   TARGET_DEF =	2
     35  030e
     36  030e					      if	TARGET_DEF = 2
     37  030e
      0  030e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  030e					      LIST	ON
     39  030e							;CHARACTERSHAPE_TARGET2_MIRRORED
     40  030e							;    .byte %00000000
     41  030e				   CHARACTERSHAPE_TARGET
     42  030e				   CHARACTERSHAPE_TARGET_MIRRORED
     43  030e		       00		      .byte.b	%00000000
     44  030f		       66		      .byte.b	%01100110
     45  0310		       66		      .byte.b	%01100110
     46  0311		       66		      .byte.b	%01100110
     47  0312		       66		      .byte.b	%01100110
     48  0313		       00		      .byte.b	%00000000
     49  0314		       00		      .byte.b	%00000000	;R
     50  0315		       00		      .byte.b	%00000000
     51  0316		       66		      .byte.b	%01100110
     52  0317		       66		      .byte.b	%01100110
     53  0318		       66		      .byte.b	%01100110
     54  0319		       66		      .byte.b	%01100110
     55  031a		       00		      .byte.b	%00000000
     56  031b		       00		      .byte.b	%00000000	;B
     57  031c		       00		      .byte.b	%00000000
     58  031d		       66		      .byte.b	%01100110
     59  031e		       66		      .byte.b	%01100110
     60  031f		       66		      .byte.b	%01100110
     61  0320		       66		      .byte.b	%01100110
     62  0321		       00		      .byte.b	%00000000
     63  0322							;    .byte %00000000 ;G
     64  0322
     65  0322							;--------------------------------------------------------------------------
     66  0322							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     67  0322
     68  0322				   CHARACTERSHAPE_TARGET2
     69  0322				   CHARACTERSHAPE_TARGET2_MIRRORED
     70  0322		       00 00 00 00*	      ds	21,0
     71  0337
      0  0337					      CHECKPAGE	CHARACTERSHAPE_TARGET2	; since we share one byte!
      8  0337					      LIST	ON
     73  0337
     74  0337					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/character_STEEL.asm LEVEL 3 PASS 4
      0  0337					      include	"characterset/character_STEEL.asm"
      1  0337							;    Sokoboo - a Sokoban implementation
      2  0337							;    using a generic tile-based display engine for the Atari 2600
      3  0337							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0337							;
      5  0337							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0337							;
      7  0337							;    Code related to the generic tile-based display engine was developed by
      8  0337							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0337							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0337							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0337							;
     12  0337							;    Code related to music and sound effects uses the TIATracker music player
     13  0337							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0337							;    directory for Apache licensing details.
     15  0337							;
     16  0337							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0337							;    See the copyright notices in the License directory for a list of level
     18  0337							;    contributors.
     19  0337							;
     20  0337							;    Except where otherwise indicated, this software is released under the
     21  0337							;    following licensing arrangement...
     22  0337							;
     23  0337							;    This program is free software: you can redistribute it and/or modify
     24  0337							;    it under the terms of the GNU General Public License as published by
     25  0337							;    the Free Software Foundation, either version 3 of the License, or
     26  0337							;    (at your option) any later version.
     27  0337							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0337
     29  0337							;    This program is distributed in the hope that it will be useful,
     30  0337							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0337							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0337							;    GNU General Public License for more details.
     33  0337
     34  0337							;--------------------------------------------------------------------------
      0  0337					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  0337					      LIST	ON
     36  0337				   CHARACTERSHAPE_STEEL
     37  0337		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     38  033e		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     39  0345		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     40  034c
     41  034c							;--------------------------------------------------------------------------
      0  034c					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  034c					      LIST	ON
     43  034c				   CHARACTERSHAPE_STEEL_MIRRORED
     44  034c		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     45  0353		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     46  035a		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/character_SOIL.asm LEVEL 3 PASS 4
      0  0361					      include	"characterset/character_SOIL.asm"
      1  0361							;    Sokoboo - a Sokoban implementation
      2  0361							;    using a generic tile-based display engine for the Atari 2600
      3  0361							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0361							;
      5  0361							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0361							;
      7  0361							;    Code related to the generic tile-based display engine was developed by
      8  0361							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0361							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0361							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0361							;
     12  0361							;    Code related to music and sound effects uses the TIATracker music player
     13  0361							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0361							;    directory for Apache licensing details.
     15  0361							;
     16  0361							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0361							;    See the copyright notices in the License directory for a list of level
     18  0361							;    contributors.
     19  0361							;
     20  0361							;    Except where otherwise indicated, this software is released under the
     21  0361							;    following licensing arrangement...
     22  0361							;
     23  0361							;    This program is free software: you can redistribute it and/or modify
     24  0361							;    it under the terms of the GNU General Public License as published by
     25  0361							;    the Free Software Foundation, either version 3 of the License, or
     26  0361							;    (at your option) any later version.
     27  0361							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0361
     29  0361							;    This program is distributed in the hope that it will be useful,
     30  0361							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0361							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0361							;    GNU General Public License for more details.
     33  0361
      0  0361					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  0361					      LIST	ON
     35  0361				   CHARACTERSHAPE_SOIL
     36  0361				   CHARACTERSHAPE_SOIL_MIRRORED
     37  0361		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
     38  0368		       ff		      .byte.b	%11111111
     39  0369		       ff		      .byte.b	%11111111
     40  036a		       ff		      .byte.b	%11111111
     41  036b		       ff		      .byte.b	%11111111
     42  036c		       ff		      .byte.b	%11111111
     43  036d		       ff		      .byte.b	%11111111
     44  036e		       ff		      .byte.b	%11111111
     45  036f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/character_BOX.asm LEVEL 3 PASS 4
      0  0376					      include	"characterset/character_BOX.asm"
      1  0376							;    Sokoboo - a Sokoban implementation
      2  0376							;    using a generic tile-based display engine for the Atari 2600
      3  0376							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0376							;
      5  0376							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0376							;
      7  0376							;    Code related to the generic tile-based display engine was developed by
      8  0376							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0376							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0376							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0376							;
     12  0376							;    Code related to music and sound effects uses the TIATracker music player
     13  0376							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0376							;    directory for Apache licensing details.
     15  0376							;
     16  0376							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0376							;    See the copyright notices in the License directory for a list of level
     18  0376							;    contributors.
     19  0376							;
     20  0376							;    Except where otherwise indicated, this software is released under the
     21  0376							;    following licensing arrangement...
     22  0376							;
     23  0376							;    This program is free software: you can redistribute it and/or modify
     24  0376							;    it under the terms of the GNU General Public License as published by
     25  0376							;    the Free Software Foundation, either version 3 of the License, or
     26  0376							;    (at your option) any later version.
     27  0376							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0376
     29  0376							;    This program is distributed in the hope that it will be useful,
     30  0376							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0376							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0376							;    GNU General Public License for more details.
     33  0376
      0  0376					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  0376					      LIST	ON
     35  0376				   CHARACTERSHAPE_BOX
     36  0376				  -	      if	MIRRORED_BOX = NO
     37  0376				  -CHARACTERSHAPE_BOX_MIRRORED
     38  0376					      endif
     39  0376		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     40  037d		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     41  0384		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0	;B
     42  038b
     43  038b							;--------------------------------------------------------------------------
     44  038b					      if	MIRRORED_BOX = YES
      0  038b					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  038b					      LIST	ON
     46  038b				   CHARACTERSHAPE_BOX_MIRRORED
     47  038b		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     48  0392		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     49  0399		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0	;B
     50  03a0					      endif
     51  03a0
      0  03a0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  03a0					      LIST	ON
     53  03a0				   CHARACTERSHAPE_BOX_ON_TARGET
     54  03a0				  -	      if	MIRRORED_BOX = NO
     55  03a0				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     56  03a0					      endif
     57  03a0		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     58  03a7		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     59  03ae		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     60  03b5
     61  03b5							;--------------------------------------------------------------------------
     62  03b5					      if	MIRRORED_BOX = YES
      0  03b5					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  03b5					      LIST	ON
     64  03b5				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     65  03b5		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     66  03bc		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     67  03c3		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     68  03ca					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/character_WALL.asm LEVEL 3 PASS 4
      0  03ca					      include	"characterset/character_WALL.asm"
      1  03ca							;    Sokoboo - a Sokoban implementation
      2  03ca							;    using a generic tile-based display engine for the Atari 2600
      3  03ca							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  03ca							;
      5  03ca							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  03ca							;
      7  03ca							;    Code related to the generic tile-based display engine was developed by
      8  03ca							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  03ca							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  03ca							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  03ca							;
     12  03ca							;    Code related to music and sound effects uses the TIATracker music player
     13  03ca							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  03ca							;    directory for Apache licensing details.
     15  03ca							;
     16  03ca							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  03ca							;    See the copyright notices in the License directory for a list of level
     18  03ca							;    contributors.
     19  03ca							;
     20  03ca							;    Except where otherwise indicated, this software is released under the
     21  03ca							;    following licensing arrangement...
     22  03ca							;
     23  03ca							;    This program is free software: you can redistribute it and/or modify
     24  03ca							;    it under the terms of the GNU General Public License as published by
     25  03ca							;    the Free Software Foundation, either version 3 of the License, or
     26  03ca							;    (at your option) any later version.
     27  03ca							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  03ca
     29  03ca							;    This program is distributed in the hope that it will be useful,
     30  03ca							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  03ca							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  03ca							;    GNU General Public License for more details.
     33  03ca
      0  03ca					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  03ca					      LIST	ON
     35  03ca
     36  03ca		       00 00	   BRICK_WALL_DEF =	0
     37  03ca
     38  03ca				   CHARACTERSHAPE_WALL
     39  03ca				   CHARACTERSHAPE_WALL0
     40  03ca
     41  03ca
     42  03ca
     43  03ca				  -	      if	MIRRORED_WALL = NO
     44  03ca				  -CHARACTERSHAPE_WALL_MIRRORED
     45  03ca				  -CHARACTERSHAPE_WALL0_MIRRORED
     46  03ca					      endif
     47  03ca
     48  03ca					      if	BRICK_WALL_DEF = 0
     49  03ca		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
     50  03d1		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
     51  03d8		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     52  03df					      endif
     53  03df
     54  03df
     55  03df
     56  03df							;--------------------------------------------------------------------------
     57  03df					      if	MIRRORED_WALL = YES
      0  03df					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  03df					      LIST	ON
     59  03df				   CHARACTERSHAPE_WALL_MIRRORED
     60  03df				   CHARACTERSHAPE_WALL0_MIRRORED
     61  03df
     62  03df					      if	BRICK_WALL_DEF = 0
     63  03df		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     64  03e6		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     65  03ed		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     66  03f4					      endif
     67  03f4
     68  03f4
     69  03f4					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    661  03f4
    662  03f4							; TODO - ROOM FOR MORE CHARACTER DEFINITIONS HERE!
    663  03f4							; approx $400 free --> 24 character definitions (inc. mirrored chars)
    664  03f4							; characters can also live in BANK_FIXED.asm, and do not have to all be together
    665  03f4
      0  03f4					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  03f4		       03 f4	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $3f4 , FREE= $40c
      2  03f4					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  03f4				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  03f4				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  03f4				  -	      ERR
      6  03f4					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 4
      0  03f4					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  03f4							;    Sokoboo - a Sokoban implementation
      2  03f4							;    using a generic tile-based display engine for the Atari 2600
      3  03f4							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  03f4							;
      5  03f4							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  03f4							;
      7  03f4							;    Code related to the generic tile-based display engine was developed by
      8  03f4							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  03f4							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  03f4							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  03f4							;
     12  03f4							;    Code related to music and sound effects uses the TIATracker music player
     13  03f4							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  03f4							;    directory for Apache licensing details.
     15  03f4							;
     16  03f4							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  03f4							;    See the copyright notices in the License directory for a list of level
     18  03f4							;    contributors.
     19  03f4							;
     20  03f4							;    Except where otherwise indicated, this software is released under the
     21  03f4							;    following licensing arrangement...
     22  03f4							;
     23  03f4							;    This program is free software: you can redistribute it and/or modify
     24  03f4							;    it under the terms of the GNU General Public License as published by
     25  03f4							;    the Free Software Foundation, either version 3 of the License, or
     26  03f4							;    (at your option) any later version.
     27  03f4							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  03f4
     29  03f4							;    This program is distributed in the hope that it will be useful,
     30  03f4							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  03f4							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  03f4							;    GNU General Public License for more details.
     33  03f4
     34  03f4							;------------------------------------------------------------------------------
     35  03f4							;##############################################################################
     36  03f4							;------------------------------------------------------------------------------
     37  03f4
      0  03f4					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     58  08f0
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 02		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
      0  08f8					      STRESS_TIME	SEGTIME_BDS
      1  08f8				  -	      IF	TEST_SEGTIME_BDS = 1
      2  08f8				  -
      3  08f8				  -
      4  08f8				  -
      5  08f8				  -
      6  08f8				  -
      7  08f8				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  08f8				  -	      bne	. - 7
      9  08f8					      ENDIF
     94  08f8
     95  08f8
     96  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     97  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     98  08f8
     99  08f8							;		  sec		 already set
    100  08f8		       a5 9c		      lda	ManY	;3
    101  08fa		       e5 96		      sbc	BoardScrollY	;3
    102  08fc		       85 9e		      sta	ManDrawY	;3
    103  08fe
    104  08fe		       38		      sec		;2
    105  08ff		       a5 9b		      lda	ManX	;3
    106  0901		       e5 97		      sbc	BoardScrollX	;3
    107  0903		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    108  0905		       90 06		      bcc	onsc	;2/3
    109  0907
    110  0907							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    111  0907							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    112  0907							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    113  0907
    114  0907		       a9 08		      lda	#SCREEN_LINES	;2
    115  0909		       85 9e		      sta	ManDrawY	;3
    116  090b		       d0 02		      bne	skipsc	;3		  unconditional
    117  090d
    118  090d		       85 9d	   onsc       sta	ManDrawX	;3
    119  090f				   skipsc
    120  090f
    121  090f		       e6 b2		      inc	timer	;5
    122  0911		       20 d7 f1 	      jsr	AnimateCharReplacements2	;3+28
    123  0914
    124  0914		       e6 89		      inc	ScreenDrawPhase	;5
    125  0916
    126  0916		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    127  0918		       85 ce		      sta	DSL	;3
    128  091a
    129  091a							; fall through...
    130  091a							;---------------------------------------------------------------------------
    131  091a
      0  091a					      DEFINE_SUBROUTINE	DrawIntoStack
      1  091a		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  091a					      SUBROUTINE
      3  091a				   DrawIntoStack
    133  091a
    134  091a		       ba		      tsx		;2
    135  091b		       86 da		      stx	save_SP	;3
    136  091d		       a6 84		      ldx	DrawStackPointer	;3
    137  091f		       9a		      txs		;2 = 10
    138  0920
    139  0920		       a4 ce		      ldy	DSL	;3
    140  0922
    141  0922							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    142  0922							; + exit cost which is +10 cycles
    143  0922							; TJ: I count 63
    144  0922							;   + 14 for the wtf2 exit
    145  0922							;   + 22 for the end of loop exit
    146  0922
    147  0922							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    148  0922							; For 80 iterations that is 640 cycles, just for checking INTIM
    149  0922							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    150  0922							; it also will require a lot of CPU time for updating the screen data.
    151  0922
    152  0922							; TODO: optimize!
    153  0922							;
    154  0922							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    155  0922							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    156  0922							; costs some detection time here, but saves ~240 cylces for drawing the two
    157  0922
    158  0922		       ad 84 02    .loopDrawStack lda	INTIM	;4
    159  0925		       c9 03		      cmp	#SEGTIME_DSL	;2
    160  0927		       90 4b		      bcc	.exitDrawStack	;2/3= 8/9
      0  0929					      STRESS_TIME	SEGTIME_DSL
      1  0929				  -	      IF	TEST_SEGTIME_DSL = 1
      2  0929				  -
      3  0929				  -
      4  0929				  -
      5  0929				  -
      6  0929				  -
      7  0929				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  0929				  -	      bne	. - 7
      9  0929					      ENDIF
    162  0929
    163  0929		       b9 50 f0 	      lda	DrawFlag,y	;4
    164  092c		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    165  092f		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    166  0931
    167  0931							; Character is NOT the same. Figure out how it should be drawn.
    168  0931							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    169  0931							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    170  0931							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    171  0931
    172  0931		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    173  0934		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    174  0937		       d0 05		      bne	.notPaired0	;2/3=10/11
    175  0939
    176  0939							; Consider two 'paired' characters. Either A:A or A:B
    177  0939							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    178  0939							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    179  0939							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    180  0939							; on the comparison, so the character will not be added to the draw stack. So our first character will
    181  0939							; do the job of drawing BOTH characters to the screen.
    182  0939
    183  0939		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    184  093c		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    185  093e
    186  093e							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    187  093e							; the last write(below) marks the character as to be direct-drawn.
    188  093e
    189  093e		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    190  0941
    191  0941							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    192  0941
    193  0941		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    194  0942		       98		      tya		;2
    195  0943		       ba		      tsx		;2		 << now X holds drawstackpointer
    196  0944		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    197  0947
    198  0947		       88	   .next0     dey		;2
    199  0948		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    200  094a
    201  094a							; unrolled 2nd loop:
    202  094a		       b9 50 f0 	      lda	DrawFlag,y	;4
    203  094d		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    204  0950		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    205  0952
    206  0952		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    207  0955		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    208  0958		       d0 05		      bne	.notPaired1	;2/3=10/11
    209  095a
    210  095a		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    211  095d		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    212  095f
    213  095f		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    214  0962
    215  0962		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    216  0963		       98		      tya		;2
    217  0964		       ba		      tsx		;2
    218  0965		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    219  0968
    220  0968		       88	   .next1     dey		;2
    221  0969		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    222  096b							;worst case: 111-4
    223  096b							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    224  096b
    225  096b							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    226  096b
    227  096b				   .finishedDrawStack
    228  096b		       e6 89		      inc	ScreenDrawPhase	;5 =  5
    229  096d		       ba		      tsx		;2
    230  096e		       86 84		      stx	DrawStackPointer	;3
    231  0970		       a6 da		      ldx	save_SP	;3
    232  0972		       9a		      txs		;2 = 10
    233  0973
    234  0973							;jmp SwitchObjects
    235  0973
    236  0973		       60		      rts		;6 =  6
    237  0974
    238  0974				   .exitDrawStack
    239  0974		       84 ce		      sty	DSL	;3 =  3
    240  0976		       ba		      tsx		;2
    241  0977		       86 84		      stx	DrawStackPointer	;3
    242  0979		       a6 da		      ldx	save_SP	;3
    243  097b		       9a		      txs		;2 = 10
    244  097c		       60		      rts		;6 =  6
    245  097d
    246  097d				   PairedCharacter
    247  097d
    248  097d				   SOFF       SET	0
    249  097d					      REPEAT	SCREEN_LINES
    250  097d		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  097d				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  097d					      REPEND
    250  0987		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  0987				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  0987					      REPEND
    250  0991		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  0991				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  0991					      REPEND
    250  099b		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  099b				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  099b					      REPEND
    250  09a5		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09a5				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09a5					      REPEND
    250  09af		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09af				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09af					      REPEND
    250  09b9		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09b9				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09b9					      REPEND
    250  09c3		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09c3				   SOFF       SET	SOFF + SCREEN_WIDTH
    252  09cd					      REPEND
    253  09cd
    254  09cd							;------------------------------------------------------------------------------
    255  09cd							; Gives character replacements used during screen drawing.
    256  09cd							; The character from the board is morphed via this array into an actual character
    257  09cd							; to draw.  This allows global animation and replacment of characters without
    258  09cd							; individual objects needing to do this.  Note, the draw-time replacement happens,
    259  09cd							; not board-time.
    260  09cd
    261  09cd				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    262  09cd
    263  09cd							; Converts a character # to an animated creature type
    264  09cd							; The array is indexed by CHARACTER_...
    265  09cd
    266  09cd		       00		      .byte.b	CHARACTER_BLANK	;  0
    267  09ce		       01		      .byte.b	CHARACTER_SOIL	;  1
    268  09cf		       02		      .byte.b	CHARACTER_BOX	;  2
    269  09d0		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    270  09d1		       04		      .byte.b	CHARACTER_TARGET2	;  4
    271  09d2		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    272  09d3		       06		      .byte.b	CHARACTER_STEEL	;  6
    273  09d4		       07		      .byte.b	CHARACTER_WALL	;  7
    274  09d5		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    275  09d6		       00		      .byte.b	CHARACTER_BLANK	;  9
    276  09d7
    277  09d7				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    278  09d7				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    279  09d7				  -	      ERR
    280  09d7					      ENDIF
      0  09d7					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09d7					      LIST	ON
    282  09d7
      0  09d7					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  09d7		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  09d7					      SUBROUTINE
      3  09d7				   AnimateCharReplacements2
    284  09d7
    285  09d7							; This manages character animation on a per-object basis.  Morph/animate these
    286  09d7							; characters individually or as required.  Change will affect all characters
    287  09d7							; of the same type in the visible display.
    288  09d7
    289  09d7							; -------------------------------------------
    290  09d7
    291  09d7							; handle the non-mandatory animating things
    292  09d7
    293  09d7		       a5 b2		      lda	timer	;3
    294  09d9		       29 01		      and	#1	;2
    295  09db		       d0 0c		      bne	nothingAnimates	;2/3
    296  09dd
    297  09dd		       a5 98		      lda	scrollBits	;3
    298  09df		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
    299  09e1
    300  09e1		       ad d0 f1 	      lda	ANIM_TARGET	;4
    301  09e4		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
    302  09e6		       8d d0 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 22	 TARGET
    303  09e9
    304  09e9		       60	   nothingAnimates rts		;6 = 28 if animating, less if not
    305  09ea
    306  09ea							;------------------------------------------------------------------------------
    307  09ea
    308  09ea
      0  09ea					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $16
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    311  0a00
    312  0a00				   .BANK      SET	BANK_SCREENMARKII1
    313  0a00					      REPEAT	SCREEN_LINES
    314  0a00					      REPEAT	SCREEN_WIDTH
    315  0a00		       00		      .byte.b	.BANK
    314  0a00					      REPEND
    315  0a01		       00		      .byte.b	.BANK
    314  0a01					      REPEND
    315  0a02		       00		      .byte.b	.BANK
    314  0a02					      REPEND
    315  0a03		       00		      .byte.b	.BANK
    314  0a03					      REPEND
    315  0a04		       00		      .byte.b	.BANK
    314  0a04					      REPEND
    315  0a05		       00		      .byte.b	.BANK
    314  0a05					      REPEND
    315  0a06		       00		      .byte.b	.BANK
    314  0a06					      REPEND
    315  0a07		       00		      .byte.b	.BANK
    314  0a07					      REPEND
    315  0a08		       00		      .byte.b	.BANK
    314  0a08					      REPEND
    315  0a09		       00		      .byte.b	.BANK
    316  0a0a					      REPEND
    317  0a0a				   .BANK      SET	.BANK + 1
    313  0a0a					      REPEND
    314  0a0a					      REPEAT	SCREEN_WIDTH
    315  0a0a		       01		      .byte.b	.BANK
    314  0a0a					      REPEND
    315  0a0b		       01		      .byte.b	.BANK
    314  0a0b					      REPEND
    315  0a0c		       01		      .byte.b	.BANK
    314  0a0c					      REPEND
    315  0a0d		       01		      .byte.b	.BANK
    314  0a0d					      REPEND
    315  0a0e		       01		      .byte.b	.BANK
    314  0a0e					      REPEND
    315  0a0f		       01		      .byte.b	.BANK
    314  0a0f					      REPEND
    315  0a10		       01		      .byte.b	.BANK
    314  0a10					      REPEND
    315  0a11		       01		      .byte.b	.BANK
    314  0a11					      REPEND
    315  0a12		       01		      .byte.b	.BANK
    314  0a12					      REPEND
    315  0a13		       01		      .byte.b	.BANK
    316  0a14					      REPEND
    317  0a14				   .BANK      SET	.BANK + 1
    313  0a14					      REPEND
    314  0a14					      REPEAT	SCREEN_WIDTH
    315  0a14		       02		      .byte.b	.BANK
    314  0a14					      REPEND
    315  0a15		       02		      .byte.b	.BANK
    314  0a15					      REPEND
    315  0a16		       02		      .byte.b	.BANK
    314  0a16					      REPEND
    315  0a17		       02		      .byte.b	.BANK
    314  0a17					      REPEND
    315  0a18		       02		      .byte.b	.BANK
    314  0a18					      REPEND
    315  0a19		       02		      .byte.b	.BANK
    314  0a19					      REPEND
    315  0a1a		       02		      .byte.b	.BANK
    314  0a1a					      REPEND
    315  0a1b		       02		      .byte.b	.BANK
    314  0a1b					      REPEND
    315  0a1c		       02		      .byte.b	.BANK
    314  0a1c					      REPEND
    315  0a1d		       02		      .byte.b	.BANK
    316  0a1e					      REPEND
    317  0a1e				   .BANK      SET	.BANK + 1
    313  0a1e					      REPEND
    314  0a1e					      REPEAT	SCREEN_WIDTH
    315  0a1e		       03		      .byte.b	.BANK
    314  0a1e					      REPEND
    315  0a1f		       03		      .byte.b	.BANK
    314  0a1f					      REPEND
    315  0a20		       03		      .byte.b	.BANK
    314  0a20					      REPEND
    315  0a21		       03		      .byte.b	.BANK
    314  0a21					      REPEND
    315  0a22		       03		      .byte.b	.BANK
    314  0a22					      REPEND
    315  0a23		       03		      .byte.b	.BANK
    314  0a23					      REPEND
    315  0a24		       03		      .byte.b	.BANK
    314  0a24					      REPEND
    315  0a25		       03		      .byte.b	.BANK
    314  0a25					      REPEND
    315  0a26		       03		      .byte.b	.BANK
    314  0a26					      REPEND
    315  0a27		       03		      .byte.b	.BANK
    316  0a28					      REPEND
    317  0a28				   .BANK      SET	.BANK + 1
    313  0a28					      REPEND
    314  0a28					      REPEAT	SCREEN_WIDTH
    315  0a28		       04		      .byte.b	.BANK
    314  0a28					      REPEND
    315  0a29		       04		      .byte.b	.BANK
    314  0a29					      REPEND
    315  0a2a		       04		      .byte.b	.BANK
    314  0a2a					      REPEND
    315  0a2b		       04		      .byte.b	.BANK
    314  0a2b					      REPEND
    315  0a2c		       04		      .byte.b	.BANK
    314  0a2c					      REPEND
    315  0a2d		       04		      .byte.b	.BANK
    314  0a2d					      REPEND
    315  0a2e		       04		      .byte.b	.BANK
    314  0a2e					      REPEND
    315  0a2f		       04		      .byte.b	.BANK
    314  0a2f					      REPEND
    315  0a30		       04		      .byte.b	.BANK
    314  0a30					      REPEND
    315  0a31		       04		      .byte.b	.BANK
    316  0a32					      REPEND
    317  0a32				   .BANK      SET	.BANK + 1
    313  0a32					      REPEND
    314  0a32					      REPEAT	SCREEN_WIDTH
    315  0a32		       05		      .byte.b	.BANK
    314  0a32					      REPEND
    315  0a33		       05		      .byte.b	.BANK
    314  0a33					      REPEND
    315  0a34		       05		      .byte.b	.BANK
    314  0a34					      REPEND
    315  0a35		       05		      .byte.b	.BANK
    314  0a35					      REPEND
    315  0a36		       05		      .byte.b	.BANK
    314  0a36					      REPEND
    315  0a37		       05		      .byte.b	.BANK
    314  0a37					      REPEND
    315  0a38		       05		      .byte.b	.BANK
    314  0a38					      REPEND
    315  0a39		       05		      .byte.b	.BANK
    314  0a39					      REPEND
    315  0a3a		       05		      .byte.b	.BANK
    314  0a3a					      REPEND
    315  0a3b		       05		      .byte.b	.BANK
    316  0a3c					      REPEND
    317  0a3c				   .BANK      SET	.BANK + 1
    313  0a3c					      REPEND
    314  0a3c					      REPEAT	SCREEN_WIDTH
    315  0a3c		       06		      .byte.b	.BANK
    314  0a3c					      REPEND
    315  0a3d		       06		      .byte.b	.BANK
    314  0a3d					      REPEND
    315  0a3e		       06		      .byte.b	.BANK
    314  0a3e					      REPEND
    315  0a3f		       06		      .byte.b	.BANK
    314  0a3f					      REPEND
    315  0a40		       06		      .byte.b	.BANK
    314  0a40					      REPEND
    315  0a41		       06		      .byte.b	.BANK
    314  0a41					      REPEND
    315  0a42		       06		      .byte.b	.BANK
    314  0a42					      REPEND
    315  0a43		       06		      .byte.b	.BANK
    314  0a43					      REPEND
    315  0a44		       06		      .byte.b	.BANK
    314  0a44					      REPEND
    315  0a45		       06		      .byte.b	.BANK
    316  0a46					      REPEND
    317  0a46				   .BANK      SET	.BANK + 1
    313  0a46					      REPEND
    314  0a46					      REPEAT	SCREEN_WIDTH
    315  0a46		       07		      .byte.b	.BANK
    314  0a46					      REPEND
    315  0a47		       07		      .byte.b	.BANK
    314  0a47					      REPEND
    315  0a48		       07		      .byte.b	.BANK
    314  0a48					      REPEND
    315  0a49		       07		      .byte.b	.BANK
    314  0a49					      REPEND
    315  0a4a		       07		      .byte.b	.BANK
    314  0a4a					      REPEND
    315  0a4b		       07		      .byte.b	.BANK
    314  0a4b					      REPEND
    315  0a4c		       07		      .byte.b	.BANK
    314  0a4c					      REPEND
    315  0a4d		       07		      .byte.b	.BANK
    314  0a4d					      REPEND
    315  0a4e		       07		      .byte.b	.BANK
    314  0a4e					      REPEND
    315  0a4f		       07		      .byte.b	.BANK
    316  0a50					      REPEND
    317  0a50				   .BANK      SET	.BANK + 1
    318  0a50					      REPEND
    319  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    321  0a50
    322  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 4
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  139d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 f4 f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 da		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 da		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 f4 f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 9d		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190		       a5 b3		      lda	BGColour	; 3
    477  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    478  1194		       85 42		      sta	WSYNC	; 3
    479  1196		       85 42		      sta	WSYNC
    480  1198		       85 42		      sta	WSYNC
    481  119a							;---------------------------------------------------------------
    482  119a		       85 6a		      sta	HMOVE	; 3
    483  119c		       85 49		      sta	COLUBK
    484  119e		       60		      rts		; 6	     @09
    485  119f
    486  119f							;------------------------------------------------------------------------------
    487  119f				   Score3x2Fix SUBROUTINE
      0  119f					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  119f		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  119f					      SUBROUTINE
      3  119f				   DrawDigits3x2
    489  119f							;					     @07
    490  119f		       a9 16		      lda	#%010110	; 2
    491  11a1		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    492  11a3		       20 fa f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    493  11a6
    494  11a6		       a9 00		      lda	#0
    495  11a8		       85 66		      sta	VDELP1
    496  11aa				   LoopDraw3x2		;
    497  11aa		       85 42		      sta	WSYNC	; 3
    498  11ac							;---------------------------------------------------------------
    499  11ac		       85 6a		      sta	HMOVE	; 3 =	3
    500  11ae		       b9 ad f0 	      lda	CharP-1,y	; 4
    501  11b1		       85 5b		      sta	GRP0	; 3
    502  11b3				   SMPLAYER
    503  11b3		       b9 3f f3 	      lda	OneR-1,y	; 4
    504  11b6		       85 5c		      sta	GRP1	; 3 = 14    @17
    505  11b8		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    506  11bb				   SMMEN
    507  11bb		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11be					      SLEEP	5	;   =	5
      1  11be				   .CYCLES    SET	5
      2  11be
      3  11be				  -	      IF	.CYCLES < 2
      4  11be				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11be				  -	      ERR
      6  11be					      ENDIF
      7  11be
      8  11be					      IF	.CYCLES & 1
      9  11be					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11be		       04 00		      nop	0
     11  11c0				  -	      ELSE
     12  11c0				  -	      bit	VSYNC
     13  11c0					      ENDIF
     14  11c0				   .CYCLES    SET	.CYCLES - 3
     15  11c0					      ENDIF
     16  11c0
     17  11c0					      REPEAT	.CYCLES / 2
     18  11c0		       ea		      nop
     19  11c1					      REPEND
    509  11c1		       85 5b		      sta	GRP0	; 3
    510  11c3				   SMLEVELX
    511  11c3		       b9 ad f0 	      lda	CharA-1,y	; 4
    512  11c6		       85 6b		      sta	HMCLR	; 3 = 10    @40
    513  11c8		       86 5c		      stx	GRP1	; 3 =	3    @43
    514  11ca		       85 5b		      sta	GRP0	; 3
    515  11cc				   SMLEVEL
    516  11cc		       b9 3f f3 	      lda	OneR-1,y	; 4
    517  11cf		       85 5c		      sta	GRP1	; 3 = 10    @53
    518  11d1
    519  11d1		       88		      dey		; 2
      0  11d2					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11d2					      LIST	ON
      9  11d2		       d0 d6		      bne	LoopDraw3x2
    521  11d4							;					     @57
      0  11d4					      SLEEP	3	; 3
      1  11d4				   .CYCLES    SET	3
      2  11d4
      3  11d4				  -	      IF	.CYCLES < 2
      4  11d4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11d4				  -	      ERR
      6  11d4					      ENDIF
      7  11d4
      8  11d4					      IF	.CYCLES & 1
      9  11d4					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11d4		       04 00		      nop	0
     11  11d6				  -	      ELSE
     12  11d6				  -	      bit	VSYNC
     13  11d6					      ENDIF
     14  11d6				   .CYCLES    SET	.CYCLES - 3
     15  11d6					      ENDIF
     16  11d6
     17  11d6				  -	      REPEAT	.CYCLES / 2
     18  11d6				  -	      nop
     19  11d6					      REPEND
    523  11d6		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    524  11d9
    525  11d9
    526  11d9							;------------------------------------------------------------------------------
      0  11d9					      DEFINE_SUBROUTINE	DrawDigits
      1  11d9		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d9					      SUBROUTINE
      3  11d9				   DrawDigits
    528  11d9
    529  11d9				   VblankLoopGame
    530  11d9							;jsr StealCharDraw
    531  11d9		       ac 84 02 	      ldy	INTIM
    532  11dc		       d0 fb		      bne	VblankLoopGame
    533  11de
    534  11de		       84 41		      sty	VBLANK	; 3	     <-- 0
    535  11e0		       a5 c9		      lda	scoringFlags	; 3
    536  11e2		       29 03		      and	#DISPLAY_FLAGS	; 2
    537  11e4		       aa		      tax		; 2
    538  11e5
    539  11e5							;    DEFINE_SUBROUTINE DrawDigit2
    540  11e5							;
    541  11e5							;    ; Generic interface to scoring routine
    542  11e5
    543  11e5		       bd f0 f1 	      lda	ScoreKernelLo,x	; 4
    544  11e8
    545  11e8		       85 42		      sta	WSYNC	; 3
    546  11ea							;---------------------------------------------------------------
    547  11ea		       8d ee f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    548  11ed				   SMJUMP
    549  11ed		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    550  11f0
    551  11f0				   ScoreKernelLo
    552  11f0		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    553  11f1		       00		      .byte.b	<Score1x6Fix	; score
    554  11f2		       9f		      .byte.b	<Score3x2Fix	; player, lives, level
    555  11f3		       00		      .byte.b	<Score1x6Fix	; high score
    556  11f4
      0  11f4					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11f4					      LIST	ON
    558  11f4
    559  11f4							;------------------------------------------------------------------------------
      0  11f4					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11f4		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11f4					      SUBROUTINE
      3  11f4				   PrepareDrawDigits
    561  11f4							;					     @13
    562  11f4		       a0 d1		      ldy	#$d1	; 2
    563  11f6		       a9 13		      lda	#%010011	; 2
    564  11f8		       85 66		      sta	VDELP1	; 3 =	7
    565  11fa				   PrepareDrawDigits2		;	    @17/20
    566  11fa		       84 65		      sty	VDELP0	; 3 =	3
    567  11fc
    568  11fc		       85 45		      sta	NUSIZ1	; 3
    569  11fe		       85 44		      sta	NUSIZ0	; 3 =	6
    570  1200
    571  1200		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    572  1203		       85 50		      sta	RESP0	; 3	     @33/36
    573  1205		       85 51		      sta	RESP1	; 3 = 10    @36/39
    574  1207
    575  1207		       84 60		      sty	HMP0	; 3
    576  1209		       c8		      iny		; 2
    577  120a		       84 61		      sty	HMP1	; 3 =	8
    578  120c				   SMCOLOR
    579  120c		       a0 9a		      ldy	#SCORE_COL	; 2
    580  120e		       84 46		      sty	COLUP0	; 3
    581  1210		       84 47		      sty	COLUP1	; 3 =	8
    582  1212
    583  1212		       a0 07		      ldy	#DIGIT_H	; 2
    584  1214		       60		      rts		; 6 =	8
    585  1215							; total: 27
    586  1215
    587  1215
    588  1215							;------------------------------------------------------------------------------
      0  1215					      DEFINE_SUBROUTINE	UpdateScore
      1  1215		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  1215					      SUBROUTINE
      3  1215				   UpdateScore
    590  1215							; a = added score value
    591  1215
    592  1215							; initially switch to score:
    593  1215		       a0 01		      ldy	#DISPLAY_SCORE
    594  1217		       84 da		      sty	newDisplay
    595  1219
    596  1219		       18		      clc
    597  121a		       f8		      sed
    598  121b		       a0 04		      ldy	#SM_OFS_SCORE
    599  121d				   .loopScore
    600  121d		       79 8a f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    601  1220		       99 8a f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    602  1223		       08		      php
    603  1224							; *** bonus life every 500 points: ***
    604  1224							;	  cpy #SM_OFS_SCORE+1
    605  1224							;	  bne .skipBonusLife
    606  1224							;	  tax
    607  1224
    608  1224							;	  and #$0f
    609  1224							;	  beq .bonusLife		      ; 000?
    610  1224							;	  cmp #$05
    611  1224							;	  bne .noBonusLife		      ; 500?
    612  1224							;.bonusLife:
    613  1224							; add extra life, limited to 9
    614  1224
    615  1224							;	  lda ManCount
    616  1224							;	  and #$0f
    617  1224							;	  cmp #9
    618  1224							;	  bcs .noBonusLife
    619  1224							;	  inc ManCount
    620  1224
    621  1224							; bonus life has priority over score:
    622  1224							;	  lda #DISPLAY_LIVES
    623  1224							;	  sta newDisplay
    624  1224							;lda #EXTRA_LIFE_TIMER
    625  1224							;sta extraLifeTimer
    626  1224
    627  1224				   .noBonusLife
    628  1224		       8a		      txa
    629  1225				   .skipBonusLife
    630  1225		       20 da f2 	      jsr	SetupBCDPtr
    631  1228		       28		      plp
    632  1229		       a9 00		      lda	#0
    633  122b		       b0 f0		      bcs	.loopScore
    634  122d		       d8		      cld
    635  122e
    636  122e							; switch display
    637  122e		       a5 c9		      lda	scoringFlags
    638  1230		       29 03		      and	#DISPLAY_FLAGS
    639  1232		       c5 da		      cmp	newDisplay	; lower priority than current?
    640  1234		       f0 08		      beq	.restartTime
    641  1236		       b0 0a		      bcs	.skipNew
    642  1238		       45 c9		      eor	scoringFlags	; remove existing score mode
    643  123a		       05 da		      ora	newDisplay	; switch to new score mode
    644  123c		       85 c9		      sta	scoringFlags
    645  123e				   .restartTime
    646  123e		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    647  1240		       85 c8		      sta	scoringTimer
    648  1242				   .skipNew
    649  1242
    650  1242		       60		      rts
    651  1243
    652  1243							;---------------------------------------------------------------------------
    653  1243
      0  1243					      DEFINE_SUBROUTINE	SwapPlayers
      1  1243		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  1243					      SUBROUTINE
      3  1243				   SwapPlayers
    655  1243
    656  1243							; assume no new high score:
    657  1243		       a0 ff		      ldy	#-1
    658  1245		       84 dd		      sty	highScoreSK
    659  1247
    660  1247							; update highscore after last live:
    661  1247		       a5 a7		      lda	ManCount
    662  1249		       29 0f		      and	#$0f	; player has lives left?
    663  124b		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    664  124d
    665  124d							; check for a new high score:
    666  124d							;	  ldy #-1
    667  124d		       18		      clc		; score has to be at least 1 bigger!
    668  124e				   .loopCheckHighScore
    669  124e		       c8		      iny
    670  124f		       b9 8e f3 	      lda	ScoreCurrent,y
    671  1252		       f9 98 f3 	      sbc	HighScore,y
    672  1255		       98		      tya
    673  1256		       49 02		      eor	#2
    674  1258		       d0 f4		      bne	.loopCheckHighScore
    675  125a		       90 0d		      bcc	.noHighScore
    676  125c
    677  125c							; new high score, update:
    678  125c		       a2 04		      ldx	#5-1
    679  125e				   .loopSetHighScore
    680  125e		       bd 8e f3 	      lda	ScoreCurrent,x
    681  1261		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
    682  1264		       95 dd		      sta	highScoreSK,x
    683  1266		       ca		      dex
    684  1267		       10 f5		      bpl	.loopSetHighScore
    685  1269				   .noHighScore
    686  1269
    687  1269				   .playerAlive
    688  1269		       a5 a7		      lda	ManCount
    689  126b		       29 f0		      and	#$f0	; other player has lives left?
    690  126d		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    691  126f
    692  126f							; save the current player variables to the player's backup:
    693  126f		       a0 02		      ldy	#3-1
    694  1271				   .swapScore
    695  1271		       be 93 f3 	      ldx	PlayerScores,y
    696  1274		       b9 8e f3 	      lda	ScoreCurrent,y
    697  1277		       99 93 f7 	      sta	PlayerScores+RAM_WRITE,y
    698  127a		       8a		      txa
    699  127b		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
    700  127e		       88		      dey
    701  127f		       10 f0		      bpl	.swapScore
    702  1281
    703  1281							; swap levelx and level:
    704  1281		       a2 01		      ldx	#1
    705  1283				   .loopLevelXLevel
    706  1283		       bc 96 f3 	      ldy	PlayerLevelX,x
    707  1286		       b5 b4		      lda	levelX,x
    708  1288		       9d 96 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    709  128b		       94 b4		      sty	levelX,x
    710  128d		       ca		      dex
    711  128e		       10 f3		      bpl	.loopLevelXLevel
    712  1290
    713  1290				   .otherPlayerDead
    714  1290		       60		      rts
    715  1291
    716  1291							;---------------------------------------------------------------------------
    717  1291
    718  1291				   HighScoreColTbl
    719  1291		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    720  1293		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    721  1295
      0  1295					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  1295		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  1295					      SUBROUTINE
      3  1295				   GeneralScoringSetups
    723  1295
    724  1295		       a0 04		      ldy	#SM_OFS_SCORE
    725  1297				   .loopScore2
    726  1297		       a5 c9		      lda	scoringFlags
    727  1299		       29 03		      and	#DISPLAY_FLAGS
    728  129b		       c9 03		      cmp	#DISPLAY_HIGH
    729  129d		       a6 81		      ldx	Platform
    730  129f		       bd 91 f2 	      lda	HighScoreColTbl,x
    731  12a2		       aa		      tax
    732  12a3		       b9 94 f3 	      lda	HighScore-SM_OFS_SCORE,y
    733  12a6		       b0 05		      bcs	.showHighScore
    734  12a8		       a2 9a		      ldx	#SCORE_COL
    735  12aa		       b9 8a f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    736  12ad				   .showHighScore
    737  12ad		       8e 0d f6 	      stx	SMCOLOR+1+RAM_WRITE
    738  12b0		       20 da f2 	      jsr	SetupBCDPtr
    739  12b3		       c0 07		      cpy	#SM_OFS_SCORE+3
    740  12b5		       90 e0		      bcc	.loopScore2
    741  12b7
    742  12b7							; display number of lives in leftmost digit of middle score XX nX XX
    743  12b7
    744  12b7							;lda ManCount
    745  12b7							;and #$0f
    746  12b7							;tay
    747  12b7							;lda DigitVectorLOr,y
    748  12b7							;sta SMMEN+1+RAM_WRITE
    749  12b7
    750  12b7							; modify player number pointer (Xp XX XX)
    751  12b7
    752  12b7							;ldy whichPlayer
    753  12b7							;lda DigitVectorLOr+1,y
    754  12b7							;sta SMPLAYER+1+RAM_WRITE
    755  12b7
    756  12b7							; fall through
    757  12b7
    758  12b7							;    ;---------------------------------------------------------------------------
    759  12b7
    760  12b7							; modify levelx character pointer (XX XX cX)
    761  12b7
    762  12b7							;ldx #<charPlace-1
    763  12b7							;lda levelDisplay
    764  12b7							;cmp #$80
    765  12b7							;and #$1f
    766  12b7							;tay
    767  12b7							;bcs .intermission
    768  12b7							;ldx CharVectorLO,y
    769  12b7							;ldy level
    770  12b7							;.intermission
    771  12b7							;stx SMLEVELX+1+RAM_WRITE
    772  12b7
    773  12b7							; modify level number pointer (XX XX Xl)
    774  12b7
    775  12b7							;lda DigitVectorLOr+1,y
    776  12b7							;sta SMLEVEL+1+RAM_WRITE
    777  12b7
    778  12b7							;---------------------------------------------------------------------------
    779  12b7
    780  12b7		       4c d1 f2 	      jmp	SetupTimePtr	; modify time pointers
    781  12ba
    782  12ba							;------------------------------------------------------------------------------
    783  12ba							;    DEFINE_SUBROUTINE SetupGameOverPtr
    784  12ba
    785  12ba							;		  ldy #8-1
    786  12ba							;.loopGameOver:
    787  12ba							;		  ldx SMGameOverOfs,y
    788  12ba							;		  lda SMGameOverPtr,y
    789  12ba							;		  sta SM_BASE+1+RAM_WRITE,x
    790  12ba							;		  dey
    791  12ba							;		  bpl .loopGameOver
    792  12ba
    793  12ba							;		  rts
    794  12ba
    795  12ba							;SMGameOverOfs:
    796  12ba							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    797  12ba							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    798  12ba							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    799  12ba							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    800  12ba							;SMGameOverPtr:
    801  12ba							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    802  12ba							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    803  12ba
    804  12ba							;------------------------------------------------------------------------------
    805  12ba
      0  12ba					      DEFINE_SUBROUTINE	DrawTargetsRequired
      1  12ba		       00 02	   BANK_DrawTargetsRequired =	_CURRENT_BANK
      2  12ba					      SUBROUTINE
      3  12ba				   DrawTargetsRequired
    807  12ba							; Show current TARGET counter in the top left
    808  12ba
    809  12ba		       a0 00		      ldy	#SM_OFS_TARGETS
    810  12bc		       a5 b9		      lda	targetsRequired
    811  12be		       20 da f2 	      jsr	SetupBCDPtr
    812  12c1
    813  12c1		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    814  12c3		       24 c9		      bit	scoringFlags	;
    815  12c5		       10 13		      bpl	SetupBCDPtr
    816  12c7		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    817  12c9		       50 0f		      bvc	SetupBCDPtr
    818  12cb		       09 01		      ora	#1	; display 1xx targets
    819  12cd		       d0 0b		      bne	SetupBCDPtr	; unconditional
    820  12cf
    821  12cf							;------------------------------------------------------------------------------
      0  12cf					      DEFINE_SUBROUTINE	DrawTime
      1  12cf		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12cf					      SUBROUTINE
      3  12cf				   DrawTime
    823  12cf
    824  12cf							; mid-digit-change, but we may be required to flash/display
    825  12cf		       a0 02		      ldy	#SM_OFS_TIME
    826  12d1							;------------------------------------------------------------------------------
      0  12d1					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12d1		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12d1					      SUBROUTINE
      3  12d1				   SetupTimePtr
    828  12d1
    829  12d1		       a5 ba		      lda	moveCounter
    830  12d3		       20 da f2 	      jsr	SetupBCDPtr
    831  12d6		       a5 bb		      lda	moveCounter+1
    832  12d8		       09 d0		      ora	#ID_CLOCK<<4
    833  12da
    834  12da							; fall through
    835  12da
    836  12da							;------------------------------------------------------------------------------
      0  12da					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12da		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12da					      SUBROUTINE
      3  12da				   SetupBCDPtr
    838  12da
    839  12da							; a = BCD value
    840  12da							; y = SM table offset
    841  12da
    842  12da		       48		      pha
    843  12db		       29 0f		      and	#$0f
    844  12dd		       aa		      tax
    845  12de		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    846  12e1		       be 19 f0 	      ldx	SMTblLSB,y
    847  12e4		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    848  12e7		       68		      pla
    849  12e8		       4a		      lsr
    850  12e9		       4a		      lsr
    851  12ea		       4a		      lsr
    852  12eb		       4a		      lsr
    853  12ec		       aa		      tax
    854  12ed		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    855  12f0		       be 20 f0 	      ldx	SMTblMSB,y
    856  12f3		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    857  12f6
    858  12f6		       c8		      iny
    859  12f7
    860  12f7		       a5 c4		      lda	ROM_Bank
    861  12f9				   RTS
    862  12f9		       60		      rts
    863  12fa
      0  12fa					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $6
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    865  1300
    866  1300					      IF	<. = 0
    867  1300		       00		      .byte.b	0	; required!
    868  1301					      ENDIF
    869  1301
    870  1301				   BLANKR
    871  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    872  1308
    873  1308				   DequalsR
    874  1308		       00		      .byte.b	%00000000
    875  1309		       00		      .byte.b	%00000000
    876  130a		       f0		      .byte.b	%11110000
    877  130b		       00		      .byte.b	%00000000
    878  130c		       f0		      .byte.b	%11110000
    879  130d		       00		      .byte.b	%00000000
    880  130e		       f0		      .byte.b	%11110000
    881  130f				   DplusR
    882  130f		       10		      .byte.b	%00010000
    883  1310		       28		      .byte.b	%00101000
    884  1311		       6c		      .byte.b	%01101100
    885  1312		       c6		      .byte.b	%11000110
    886  1313		       6c		      .byte.b	%01101100
    887  1314		       28		      .byte.b	%00101000
    888  1315		       10		      .byte.b	%00010000
    889  1316
    890  1316				   ClockR
    891  1316		       00		      .byte.b	%00000000
    892  1317		       48		      .byte.b	%01001000
    893  1318		       fc		      .byte.b	%11111100
    894  1319		       48		      .byte.b	%01001000
    895  131a		       48		      .byte.b	%01001000
    896  131b		       fc		      .byte.b	%11111100
    897  131c		       48		      .byte.b	%01001000
    898  131d				   NineR
    899  131d		       0f		      .byte.b	%00001111
    900  131e		       01		      .byte.b	%00000001
    901  131f		       01		      .byte.b	%00000001
    902  1320		       7f		      .byte.b	%01111111
    903  1321		       41		      .byte.b	%01000001
    904  1322		       41		      .byte.b	%01000001
    905  1323		       7f		      .byte.b	%01111111
    906  1324				   SixR
    907  1324		       7f		      .byte.b	%01111111
    908  1325		       41		      .byte.b	%01000001
    909  1326		       41		      .byte.b	%01000001
    910  1327		       7f		      .byte.b	%01111111
    911  1328		       40		      .byte.b	%01000000
    912  1329		       40		      .byte.b	%01000000
    913  132a		       78		      .byte.b	%01111000
    914  132b				   EightR
    915  132b							;  .byte %00111110
    916  132b							;  .byte %01000011
    917  132b							;  .byte %01000011
    918  132b							;  .byte %00111110
    919  132b							;  .byte %00100011
    920  132b							;  .byte %00100011
    921  132b							;  .byte %00011110
    922  132b
    923  132b
    924  132b		       7f		      .byte.b	%01111111
    925  132c		       41		      .byte.b	%01000001
    926  132d		       41		      .byte.b	%01000001
    927  132e		       7f		      .byte.b	%01111111
    928  132f		       41		      .byte.b	%01000001
    929  1330		       41		      .byte.b	%01000001
    930  1331		       7f		      .byte.b	%01111111
    931  1332
    932  1332				   ZeroR
    933  1332		       7f		      .byte.b	%01111111
    934  1333		       41		      .byte.b	%01000001
    935  1334		       41		      .byte.b	%01000001
    936  1335		       41		      .byte.b	%01000001
    937  1336		       41		      .byte.b	%01000001
    938  1337		       41		      .byte.b	%01000001
    939  1338		       7f		      .byte.b	%01111111
    940  1339
    941  1339							;	  .byte %00111110
    942  1339							;	  .byte %01000011
    943  1339							;	  .byte %01000011
    944  1339							;	  .byte %01000011
    945  1339							;	  .byte %01000011
    946  1339							;	  .byte %00100011
    947  1339							;	  .byte %00011110
    948  1339				   ThreeR
    949  1339		       7f		      .byte.b	%01111111
    950  133a		       01		      .byte.b	%00000001
    951  133b		       01		      .byte.b	%00000001
    952  133c		       0f		      .byte.b	%00001111
    953  133d		       01		      .byte.b	%00000001
    954  133e		       01		      .byte.b	%00000001
    955  133f		       7f		      .byte.b	%01111111
    956  1340				   OneR
    957  1340		       08		      .byte.b	%00001000
    958  1341		       08		      .byte.b	%00001000
    959  1342		       08		      .byte.b	%00001000
    960  1343		       08		      .byte.b	%00001000
    961  1344		       08		      .byte.b	%00001000
    962  1345		       08		      .byte.b	%00001000
    963  1346		       08		      .byte.b	%00001000
    964  1347
    965  1347				   SevenR
    966  1347		       08		      .byte.b	%00001000
    967  1348		       08		      .byte.b	%00001000
    968  1349		       08		      .byte.b	%00001000
    969  134a		       0f		      .byte.b	%00001111
    970  134b		       01		      .byte.b	%00000001
    971  134c		       01		      .byte.b	%00000001
    972  134d		       7f		      .byte.b	%01111111
    973  134e
    974  134e				   TwoR
    975  134e		       7f		      .byte.b	%01111111
    976  134f		       40		      .byte.b	%01000000
    977  1350		       40		      .byte.b	%01000000
    978  1351		       7f		      .byte.b	%01111111
    979  1352		       01		      .byte.b	%00000001
    980  1353		       01		      .byte.b	%00000001
    981  1354		       7f		      .byte.b	%01111111
    982  1355				   FiveR
    983  1355		       7f		      .byte.b	%01111111
    984  1356		       01		      .byte.b	%00000001
    985  1357		       01		      .byte.b	%00000001
    986  1358		       7f		      .byte.b	%01111111
    987  1359		       40		      .byte.b	%01000000
    988  135a		       40		      .byte.b	%01000000
    989  135b		       78		      .byte.b	%01111000
    990  135c				   FourR
    991  135c		       08		      .byte.b	%00001000
    992  135d		       08		      .byte.b	%00001000
    993  135e		       08		      .byte.b	%00001000
    994  135f		       7f		      .byte.b	%01111111
    995  1360		       48		      .byte.b	%01001000
    996  1361		       48		      .byte.b	%01001000
    997  1362		       48		      .byte.b	%01001000
    998  1363
    999  1363							;CharAL:
   1000  1363							;    .byte %11100110
   1001  1363							;    .byte %11100110
   1002  1363							;    .byte %11111110
   1003  1363							;    .byte %11100110
   1004  1363							;    .byte %11100110
   1005  1363							;    .byte %01111100
   1006  1363							;    .byte %00111000
   1007  1363							;CharEL:
   1008  1363							;    .byte %11111110
   1009  1363							;    .byte %11111110
   1010  1363							;    .byte %11100000
   1011  1363							;    .byte %11100000
   1012  1363							;    .byte %11111100
   1013  1363							;    .byte %11100000
   1014  1363							;    .byte %11111110
   1015  1363							;CharRL:
   1016  1363							;    .byte %11100110
   1017  1363							;    .byte %11100110
   1018  1363							;    .byte %11111100
   1019  1363							;    .byte %11111100
   1020  1363							;    .byte %11100110
   1021  1363							;    .byte %11100110
   1022  1363							;    .byte %11111100
   1023  1363							;CharVL:
   1024  1363							;    .byte %00111000
   1025  1363							;    .byte %01111100
   1026  1363							;    .byte %11100110
   1027  1363							;    .byte %11100110
   1028  1363							;    .byte %11100110
   1029  1363							;    .byte %11100110
   1030  1363							;    .byte %11100110
   1031  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1033  1363
   1034  1363							;---------------------------------------------------------------------------
   1035  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1037  1363
   1038  1363							; copy loaded SK high score into scoring RAM:
   1039  1363		       a2 02		      ldx	#3-1
   1040  1365				   .loopCopyHighScore
   1041  1365		       b5 dd		      lda	highScoreSK,x
   1042  1367		       c9 ff		      cmp	#$ff
   1043  1369		       f0 06		      beq	.noSaveKey
   1044  136b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
   1045  136e		       ca		      dex
   1046  136f		       10 f4		      bpl	.loopCopyHighScore
   1047  1371				   .noSaveKey
   1048  1371
   1049  1371							; clear both players scores
   1050  1371		       a0 05		      ldy	#2*3-1
   1051  1373		       a9 00		      lda	#0
   1052  1375				   .loopClearScore
   1053  1375		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1054  1378		       88		      dey
   1055  1379		       10 fa		      bpl	.loopClearScore
   1056  137b
   1057  137b							; copy levelX and level for other player and SaveKey:
   1058  137b		       a5 b4		      lda	levelX
   1059  137d		       8d 96 f7 	      sta	PlayerLevelX+RAM_WRITE
   1060  1380		       a5 e0		      lda	startingLevel
   1061  1382		       8d 91 f7 	      sta	StartLevelX+RAM_WRITE
   1062  1385		       a5 b5		      lda	level
   1063  1387		       8d 97 f7 	      sta	PlayerLevel+RAM_WRITE
   1064  138a		       8d 92 f7 	      sta	StartLevel+RAM_WRITE
   1065  138d		       60		      rts
   1066  138e
   1067  138e							;---------------------------------------------------------------------------
   1068  138e
   1069  138e		       00 00 00    ScoreCurrent ds	3, 0
   1070  1391							; start levelx and level have to be after ScoreCurrent!
   1071  1391		       00	   StartLevelX .byte.b	0
   1072  1392		       00	   StartLevel .byte.b	0
   1073  1393		       00 00 00    PlayerScores ds	3, 0
   1074  1396							; levelx and level have to be consecutive variables!
   1075  1396		       00	   PlayerLevelX .byte.b	0
   1076  1397		       00	   PlayerLevel .byte.b	0
   1077  1398		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1078  139d
   1079  139d
   1080  139d
   1081  139d							;------------------------------------------------------------------------------
   1082  139d
      0  139d					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  139d
      2  139d
      3  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $39d , FREE= $63
      4  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  139d				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  139d				  -	      ERR
      8  139d					      endif
   1084  139d
   1085  139d							;------------------------------------------------------------------------------
   1086  139d
   1087  139d							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1088  139d							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1089  139d							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1090  139d							; this is defined before or after, as once the levels have processed it will be
   1091  139d							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1092  139d							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1093  139d							; TODO: verify above is still valid
   1094  139d
   1095  139d
      0  139d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $39d , FREE= $463
      2  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  139d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  139d				  -	      ERR
      6  139d					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 4
      0  139d					      include	"BANK_GENERIC.asm"
      1  139d							;    Sokoboo - a Sokoban implementation
      2  139d							;    using a generic tile-based display engine for the Atari 2600
      3  139d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  139d							;
      5  139d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  139d							;
      7  139d							;    Code related to the generic tile-based display engine was developed by
      8  139d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  139d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  139d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  139d							;
     12  139d							;    Code related to music and sound effects uses the TIATracker music player
     13  139d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  139d							;    directory for Apache licensing details.
     15  139d							;
     16  139d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  139d							;    See the copyright notices in the License directory for a list of level
     18  139d							;    contributors.
     19  139d							;
     20  139d							;    Except where otherwise indicated, this software is released under the
     21  139d							;    following licensing arrangement...
     22  139d							;
     23  139d							;    This program is free software: you can redistribute it and/or modify
     24  139d							;    it under the terms of the GNU General Public License as published by
     25  139d							;    the Free Software Foundation, either version 3 of the License, or
     26  139d							;    (at your option) any later version.
     27  139d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  139d
     29  139d							;    This program is distributed in the hope that it will be useful,
     30  139d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  139d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  139d							;    GNU General Public License for more details.
     33  139d
     34  139d							;------------------------------------------------------------------------------
     35  139d							;##############################################################################
     36  139d							;------------------------------------------------------------------------------
     37  139d
      0  139d					      NEWBANK	GENERIC_BANK_1
      1  1f1e ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 4
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800				   LEVELNUM   SET	0
     35  1800				   NUMBEROFLEVELS SET	0
     36  1800		       00 03	   LEVEL_DEFINITION_SIZE =	3
     37  1800
     38  1800					      MAC	add_level
     39  1800				   LEVEL_ACTIVE_{1} SET	1
     40  1800				   LEVEL_NAMED_{1} =	LEVELNUM
     41  1800					      .byte	<LEVEL_{1}
     42  1800					      .byte	>LEVEL_{1}
     43  1800					      .byte	BANK_LEVEL_{1}
     44  1800							;.byte LEVEL_SIZE_{1}
     45  1800				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
     46  1800				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     47  1800					      ENDM		; {name}
     48  1800
     49  1800				   LevelInformation
     50  1800
     51  1800							; The ordering here corresponds to the ordering when playing...
     52  1800
      0  1800					      ADD_LEVEL	_024_L
      1  1800				   LEVEL_ACTIVE__024_L SET	1
      2  1800		       00 00	   LEVEL_NAMED__024_L =	LEVELNUM
      3  1800		       16		      .byte.b	<LEVEL__024_L
      4  1801		       f2		      .byte.b	>LEVEL__024_L
      5  1802		       05		      .byte.b	BANK_LEVEL__024_L
      6  1803
      7  1803				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1803				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1803					      ADD_LEVEL	_024_R
      1  1803				   LEVEL_ACTIVE__024_R SET	1
      2  1803		       00 03	   LEVEL_NAMED__024_R =	LEVELNUM
      3  1803		       67		      .byte.b	<LEVEL__024_R
      4  1804		       f2		      .byte.b	>LEVEL__024_R
      5  1805		       05		      .byte.b	BANK_LEVEL__024_R
      6  1806
      7  1806				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1806				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1806					      ADD_LEVEL	_025_L
      1  1806				   LEVEL_ACTIVE__025_L SET	1
      2  1806		       00 06	   LEVEL_NAMED__025_L =	LEVELNUM
      3  1806		       b0		      .byte.b	<LEVEL__025_L
      4  1807		       f2		      .byte.b	>LEVEL__025_L
      5  1808		       05		      .byte.b	BANK_LEVEL__025_L
      6  1809
      7  1809				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1809				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1809					      ADD_LEVEL	_025_R
      1  1809				   LEVEL_ACTIVE__025_R SET	1
      2  1809		       00 09	   LEVEL_NAMED__025_R =	LEVELNUM
      3  1809		       f4		      .byte.b	<LEVEL__025_R
      4  180a		       f2		      .byte.b	>LEVEL__025_R
      5  180b		       05		      .byte.b	BANK_LEVEL__025_R
      6  180c
      7  180c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180c					      ADD_LEVEL	_026_L
      1  180c				   LEVEL_ACTIVE__026_L SET	1
      2  180c		       00 0c	   LEVEL_NAMED__026_L =	LEVELNUM
      3  180c		       34		      .byte.b	<LEVEL__026_L
      4  180d		       f3		      .byte.b	>LEVEL__026_L
      5  180e		       05		      .byte.b	BANK_LEVEL__026_L
      6  180f
      7  180f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180f					      ADD_LEVEL	_026_R
      1  180f				   LEVEL_ACTIVE__026_R SET	1
      2  180f		       00 0f	   LEVEL_NAMED__026_R =	LEVELNUM
      3  180f		       6e		      .byte.b	<LEVEL__026_R
      4  1810		       f3		      .byte.b	>LEVEL__026_R
      5  1811		       05		      .byte.b	BANK_LEVEL__026_R
      6  1812
      7  1812				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1812				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1812					      ADD_LEVEL	_027_L
      1  1812				   LEVEL_ACTIVE__027_L SET	1
      2  1812		       00 12	   LEVEL_NAMED__027_L =	LEVELNUM
      3  1812		       b0		      .byte.b	<LEVEL__027_L
      4  1813		       f3		      .byte.b	>LEVEL__027_L
      5  1814		       05		      .byte.b	BANK_LEVEL__027_L
      6  1815
      7  1815				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1815				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1815					      ADD_LEVEL	_027_R
      1  1815				   LEVEL_ACTIVE__027_R SET	1
      2  1815		       00 15	   LEVEL_NAMED__027_R =	LEVELNUM
      3  1815		       ef		      .byte.b	<LEVEL__027_R
      4  1816		       f3		      .byte.b	>LEVEL__027_R
      5  1817		       05		      .byte.b	BANK_LEVEL__027_R
      6  1818
      7  1818				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1818				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1818					      ADD_LEVEL	_028_L
      1  1818				   LEVEL_ACTIVE__028_L SET	1
      2  1818		       00 18	   LEVEL_NAMED__028_L =	LEVELNUM
      3  1818		       00		      .byte.b	<LEVEL__028_L
      4  1819		       f0		      .byte.b	>LEVEL__028_L
      5  181a		       06		      .byte.b	BANK_LEVEL__028_L
      6  181b
      7  181b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181b					      ADD_LEVEL	_028_R
      1  181b				   LEVEL_ACTIVE__028_R SET	1
      2  181b		       00 1b	   LEVEL_NAMED__028_R =	LEVELNUM
      3  181b		       4d		      .byte.b	<LEVEL__028_R
      4  181c		       f0		      .byte.b	>LEVEL__028_R
      5  181d		       06		      .byte.b	BANK_LEVEL__028_R
      6  181e
      7  181e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181e					      ADD_LEVEL	_029_L
      1  181e				   LEVEL_ACTIVE__029_L SET	1
      2  181e		       00 1e	   LEVEL_NAMED__029_L =	LEVELNUM
      3  181e		       9c		      .byte.b	<LEVEL__029_L
      4  181f		       f0		      .byte.b	>LEVEL__029_L
      5  1820		       06		      .byte.b	BANK_LEVEL__029_L
      6  1821
      7  1821				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1821				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1821					      ADD_LEVEL	_029_R
      1  1821				   LEVEL_ACTIVE__029_R SET	1
      2  1821		       00 21	   LEVEL_NAMED__029_R =	LEVELNUM
      3  1821		       e2		      .byte.b	<LEVEL__029_R
      4  1822		       f0		      .byte.b	>LEVEL__029_R
      5  1823		       06		      .byte.b	BANK_LEVEL__029_R
      6  1824
      7  1824				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1824				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1824					      ADD_LEVEL	_030_L
      1  1824				   LEVEL_ACTIVE__030_L SET	1
      2  1824		       00 24	   LEVEL_NAMED__030_L =	LEVELNUM
      3  1824		       27		      .byte.b	<LEVEL__030_L
      4  1825		       f1		      .byte.b	>LEVEL__030_L
      5  1826		       06		      .byte.b	BANK_LEVEL__030_L
      6  1827
      7  1827				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1827				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1827					      ADD_LEVEL	_030_R
      1  1827				   LEVEL_ACTIVE__030_R SET	1
      2  1827		       00 27	   LEVEL_NAMED__030_R =	LEVELNUM
      3  1827		       78		      .byte.b	<LEVEL__030_R
      4  1828		       f1		      .byte.b	>LEVEL__030_R
      5  1829		       06		      .byte.b	BANK_LEVEL__030_R
      6  182a
      7  182a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182a					      ADD_LEVEL	_031_L
      1  182a				   LEVEL_ACTIVE__031_L SET	1
      2  182a		       00 2a	   LEVEL_NAMED__031_L =	LEVELNUM
      3  182a		       cc		      .byte.b	<LEVEL__031_L
      4  182b		       f1		      .byte.b	>LEVEL__031_L
      5  182c		       06		      .byte.b	BANK_LEVEL__031_L
      6  182d
      7  182d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182d					      ADD_LEVEL	_031_R
      1  182d				   LEVEL_ACTIVE__031_R SET	1
      2  182d		       00 2d	   LEVEL_NAMED__031_R =	LEVELNUM
      3  182d		       13		      .byte.b	<LEVEL__031_R
      4  182e		       f2		      .byte.b	>LEVEL__031_R
      5  182f		       06		      .byte.b	BANK_LEVEL__031_R
      6  1830
      7  1830				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1830				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1830					      ADD_LEVEL	_032_L
      1  1830				   LEVEL_ACTIVE__032_L SET	1
      2  1830		       00 30	   LEVEL_NAMED__032_L =	LEVELNUM
      3  1830		       53		      .byte.b	<LEVEL__032_L
      4  1831		       f2		      .byte.b	>LEVEL__032_L
      5  1832		       06		      .byte.b	BANK_LEVEL__032_L
      6  1833
      7  1833				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1833				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1833					      ADD_LEVEL	_032_R
      1  1833				   LEVEL_ACTIVE__032_R SET	1
      2  1833		       00 33	   LEVEL_NAMED__032_R =	LEVELNUM
      3  1833		       8c		      .byte.b	<LEVEL__032_R
      4  1834		       f2		      .byte.b	>LEVEL__032_R
      5  1835		       06		      .byte.b	BANK_LEVEL__032_R
      6  1836
      7  1836				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1836				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1836					      ADD_LEVEL	_033_L
      1  1836				   LEVEL_ACTIVE__033_L SET	1
      2  1836		       00 36	   LEVEL_NAMED__033_L =	LEVELNUM
      3  1836		       d1		      .byte.b	<LEVEL__033_L
      4  1837		       f2		      .byte.b	>LEVEL__033_L
      5  1838		       06		      .byte.b	BANK_LEVEL__033_L
      6  1839
      7  1839				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1839				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1839					      ADD_LEVEL	_033_R
      1  1839				   LEVEL_ACTIVE__033_R SET	1
      2  1839		       00 39	   LEVEL_NAMED__033_R =	LEVELNUM
      3  1839		       1c		      .byte.b	<LEVEL__033_R
      4  183a		       f3		      .byte.b	>LEVEL__033_R
      5  183b		       06		      .byte.b	BANK_LEVEL__033_R
      6  183c
      7  183c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183c					      ADD_LEVEL	_034_L
      1  183c				   LEVEL_ACTIVE__034_L SET	1
      2  183c		       00 3c	   LEVEL_NAMED__034_L =	LEVELNUM
      3  183c		       5d		      .byte.b	<LEVEL__034_L
      4  183d		       f3		      .byte.b	>LEVEL__034_L
      5  183e		       06		      .byte.b	BANK_LEVEL__034_L
      6  183f
      7  183f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183f					      ADD_LEVEL	_034_R
      1  183f				   LEVEL_ACTIVE__034_R SET	1
      2  183f		       00 3f	   LEVEL_NAMED__034_R =	LEVELNUM
      3  183f		       ad		      .byte.b	<LEVEL__034_R
      4  1840		       f3		      .byte.b	>LEVEL__034_R
      5  1841		       06		      .byte.b	BANK_LEVEL__034_R
      6  1842
      7  1842				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1842				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1842					      ADD_LEVEL	_035_L
      1  1842				   LEVEL_ACTIVE__035_L SET	1
      2  1842		       00 42	   LEVEL_NAMED__035_L =	LEVELNUM
      3  1842		       f7		      .byte.b	<LEVEL__035_L
      4  1843		       f3		      .byte.b	>LEVEL__035_L
      5  1844		       06		      .byte.b	BANK_LEVEL__035_L
      6  1845
      7  1845				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1845				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1845					      ADD_LEVEL	_035_R
      1  1845				   LEVEL_ACTIVE__035_R SET	1
      2  1845		       00 45	   LEVEL_NAMED__035_R =	LEVELNUM
      3  1845		       3d		      .byte.b	<LEVEL__035_R
      4  1846		       f4		      .byte.b	>LEVEL__035_R
      5  1847		       06		      .byte.b	BANK_LEVEL__035_R
      6  1848
      7  1848				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1848				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1848					      ADD_LEVEL	_036_L
      1  1848				   LEVEL_ACTIVE__036_L SET	1
      2  1848		       00 48	   LEVEL_NAMED__036_L =	LEVELNUM
      3  1848		       7e		      .byte.b	<LEVEL__036_L
      4  1849		       f4		      .byte.b	>LEVEL__036_L
      5  184a		       06		      .byte.b	BANK_LEVEL__036_L
      6  184b
      7  184b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184b					      ADD_LEVEL	_036_R
      1  184b				   LEVEL_ACTIVE__036_R SET	1
      2  184b		       00 4b	   LEVEL_NAMED__036_R =	LEVELNUM
      3  184b		       b5		      .byte.b	<LEVEL__036_R
      4  184c		       f4		      .byte.b	>LEVEL__036_R
      5  184d		       06		      .byte.b	BANK_LEVEL__036_R
      6  184e
      7  184e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184e					      ADD_LEVEL	_037_L
      1  184e				   LEVEL_ACTIVE__037_L SET	1
      2  184e		       00 4e	   LEVEL_NAMED__037_L =	LEVELNUM
      3  184e		       fc		      .byte.b	<LEVEL__037_L
      4  184f		       f4		      .byte.b	>LEVEL__037_L
      5  1850		       06		      .byte.b	BANK_LEVEL__037_L
      6  1851
      7  1851				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1851				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1851					      ADD_LEVEL	_037_R
      1  1851				   LEVEL_ACTIVE__037_R SET	1
      2  1851		       00 51	   LEVEL_NAMED__037_R =	LEVELNUM
      3  1851		       3a		      .byte.b	<LEVEL__037_R
      4  1852		       f5		      .byte.b	>LEVEL__037_R
      5  1853		       06		      .byte.b	BANK_LEVEL__037_R
      6  1854
      7  1854				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1854				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1854					      ADD_LEVEL	_038_L
      1  1854				   LEVEL_ACTIVE__038_L SET	1
      2  1854		       00 54	   LEVEL_NAMED__038_L =	LEVELNUM
      3  1854		       84		      .byte.b	<LEVEL__038_L
      4  1855		       f5		      .byte.b	>LEVEL__038_L
      5  1856		       06		      .byte.b	BANK_LEVEL__038_L
      6  1857
      7  1857				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1857				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1857					      ADD_LEVEL	_038_R
      1  1857				   LEVEL_ACTIVE__038_R SET	1
      2  1857		       00 57	   LEVEL_NAMED__038_R =	LEVELNUM
      3  1857		       cd		      .byte.b	<LEVEL__038_R
      4  1858		       f5		      .byte.b	>LEVEL__038_R
      5  1859		       06		      .byte.b	BANK_LEVEL__038_R
      6  185a
      7  185a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185a					      ADD_LEVEL	_039_L
      1  185a				   LEVEL_ACTIVE__039_L SET	1
      2  185a		       00 5a	   LEVEL_NAMED__039_L =	LEVELNUM
      3  185a		       1d		      .byte.b	<LEVEL__039_L
      4  185b		       f6		      .byte.b	>LEVEL__039_L
      5  185c		       06		      .byte.b	BANK_LEVEL__039_L
      6  185d
      7  185d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185d					      ADD_LEVEL	_039_R
      1  185d				   LEVEL_ACTIVE__039_R SET	1
      2  185d		       00 5d	   LEVEL_NAMED__039_R =	LEVELNUM
      3  185d		       6d		      .byte.b	<LEVEL__039_R
      4  185e		       f6		      .byte.b	>LEVEL__039_R
      5  185f		       06		      .byte.b	BANK_LEVEL__039_R
      6  1860
      7  1860				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1860				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1860					      ADD_LEVEL	_040_L
      1  1860				   LEVEL_ACTIVE__040_L SET	1
      2  1860		       00 60	   LEVEL_NAMED__040_L =	LEVELNUM
      3  1860		       c8		      .byte.b	<LEVEL__040_L
      4  1861		       f6		      .byte.b	>LEVEL__040_L
      5  1862		       06		      .byte.b	BANK_LEVEL__040_L
      6  1863
      7  1863				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1863				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1863					      ADD_LEVEL	_040_R
      1  1863				   LEVEL_ACTIVE__040_R SET	1
      2  1863		       00 63	   LEVEL_NAMED__040_R =	LEVELNUM
      3  1863		       10		      .byte.b	<LEVEL__040_R
      4  1864		       f7		      .byte.b	>LEVEL__040_R
      5  1865		       06		      .byte.b	BANK_LEVEL__040_R
      6  1866
      7  1866				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1866				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     87  1866
      0  1866					      ADD_LEVEL	_001_L
      1  1866				   LEVEL_ACTIVE__001_L SET	1
      2  1866		       00 66	   LEVEL_NAMED__001_L =	LEVELNUM
      3  1866		       00		      .byte.b	<LEVEL__001_L
      4  1867		       f0		      .byte.b	>LEVEL__001_L
      5  1868		       04		      .byte.b	BANK_LEVEL__001_L
      6  1869
      7  1869				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1869				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1869					      ADD_LEVEL	_001_R
      1  1869				   LEVEL_ACTIVE__001_R SET	1
      2  1869		       00 69	   LEVEL_NAMED__001_R =	LEVELNUM
      3  1869		       13		      .byte.b	<LEVEL__001_R
      4  186a		       f0		      .byte.b	>LEVEL__001_R
      5  186b		       04		      .byte.b	BANK_LEVEL__001_R
      6  186c
      7  186c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186c					      ADD_LEVEL	_002_L
      1  186c				   LEVEL_ACTIVE__002_L SET	1
      2  186c		       00 6c	   LEVEL_NAMED__002_L =	LEVELNUM
      3  186c		       20		      .byte.b	<LEVEL__002_L
      4  186d		       f0		      .byte.b	>LEVEL__002_L
      5  186e		       04		      .byte.b	BANK_LEVEL__002_L
      6  186f
      7  186f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186f					      ADD_LEVEL	_002_R
      1  186f				   LEVEL_ACTIVE__002_R SET	1
      2  186f		       00 6f	   LEVEL_NAMED__002_R =	LEVELNUM
      3  186f		       3a		      .byte.b	<LEVEL__002_R
      4  1870		       f0		      .byte.b	>LEVEL__002_R
      5  1871		       04		      .byte.b	BANK_LEVEL__002_R
      6  1872
      7  1872				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1872				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1872					      ADD_LEVEL	_003_L
      1  1872				   LEVEL_ACTIVE__003_L SET	1
      2  1872		       00 72	   LEVEL_NAMED__003_L =	LEVELNUM
      3  1872		       63		      .byte.b	<LEVEL__003_L
      4  1873		       f0		      .byte.b	>LEVEL__003_L
      5  1874		       04		      .byte.b	BANK_LEVEL__003_L
      6  1875
      7  1875				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1875				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1875					      ADD_LEVEL	_003_R
      1  1875				   LEVEL_ACTIVE__003_R SET	1
      2  1875		       00 75	   LEVEL_NAMED__003_R =	LEVELNUM
      3  1875		       90		      .byte.b	<LEVEL__003_R
      4  1876		       f0		      .byte.b	>LEVEL__003_R
      5  1877		       04		      .byte.b	BANK_LEVEL__003_R
      6  1878
      7  1878				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1878				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1878					      ADD_LEVEL	_004_L
      1  1878				   LEVEL_ACTIVE__004_L SET	1
      2  1878		       00 78	   LEVEL_NAMED__004_L =	LEVELNUM
      3  1878		       bb		      .byte.b	<LEVEL__004_L
      4  1879		       f0		      .byte.b	>LEVEL__004_L
      5  187a		       04		      .byte.b	BANK_LEVEL__004_L
      6  187b
      7  187b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187b					      ADD_LEVEL	_004_R
      1  187b				   LEVEL_ACTIVE__004_R SET	1
      2  187b		       00 7b	   LEVEL_NAMED__004_R =	LEVELNUM
      3  187b		       df		      .byte.b	<LEVEL__004_R
      4  187c		       f0		      .byte.b	>LEVEL__004_R
      5  187d		       04		      .byte.b	BANK_LEVEL__004_R
      6  187e
      7  187e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187e					      ADD_LEVEL	_005_L
      1  187e				   LEVEL_ACTIVE__005_L SET	1
      2  187e		       00 7e	   LEVEL_NAMED__005_L =	LEVELNUM
      3  187e		       fc		      .byte.b	<LEVEL__005_L
      4  187f		       f0		      .byte.b	>LEVEL__005_L
      5  1880		       04		      .byte.b	BANK_LEVEL__005_L
      6  1881
      7  1881				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1881				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1881					      ADD_LEVEL	_005_R
      1  1881				   LEVEL_ACTIVE__005_R SET	1
      2  1881		       00 81	   LEVEL_NAMED__005_R =	LEVELNUM
      3  1881		       2f		      .byte.b	<LEVEL__005_R
      4  1882		       f1		      .byte.b	>LEVEL__005_R
      5  1883		       04		      .byte.b	BANK_LEVEL__005_R
      6  1884
      7  1884				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1884				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1884					      ADD_LEVEL	_006_L
      1  1884				   LEVEL_ACTIVE__006_L SET	1
      2  1884		       00 84	   LEVEL_NAMED__006_L =	LEVELNUM
      3  1884		       6f		      .byte.b	<LEVEL__006_L
      4  1885		       f1		      .byte.b	>LEVEL__006_L
      5  1886		       04		      .byte.b	BANK_LEVEL__006_L
      6  1887
      7  1887				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1887				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1887					      ADD_LEVEL	_006_R
      1  1887				   LEVEL_ACTIVE__006_R SET	1
      2  1887		       00 87	   LEVEL_NAMED__006_R =	LEVELNUM
      3  1887		       ab		      .byte.b	<LEVEL__006_R
      4  1888		       f1		      .byte.b	>LEVEL__006_R
      5  1889		       04		      .byte.b	BANK_LEVEL__006_R
      6  188a
      7  188a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  188a					      ADD_LEVEL	_007_L
      1  188a				   LEVEL_ACTIVE__007_L SET	1
      2  188a		       00 8a	   LEVEL_NAMED__007_L =	LEVELNUM
      3  188a		       ea		      .byte.b	<LEVEL__007_L
      4  188b		       f1		      .byte.b	>LEVEL__007_L
      5  188c		       04		      .byte.b	BANK_LEVEL__007_L
      6  188d
      7  188d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  188d					      ADD_LEVEL	_007_R
      1  188d				   LEVEL_ACTIVE__007_R SET	1
      2  188d		       00 8d	   LEVEL_NAMED__007_R =	LEVELNUM
      3  188d		       18		      .byte.b	<LEVEL__007_R
      4  188e		       f2		      .byte.b	>LEVEL__007_R
      5  188f		       04		      .byte.b	BANK_LEVEL__007_R
      6  1890
      7  1890				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1890				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1890					      ADD_LEVEL	_008_L
      1  1890				   LEVEL_ACTIVE__008_L SET	1
      2  1890		       00 90	   LEVEL_NAMED__008_L =	LEVELNUM
      3  1890		       4c		      .byte.b	<LEVEL__008_L
      4  1891		       f2		      .byte.b	>LEVEL__008_L
      5  1892		       04		      .byte.b	BANK_LEVEL__008_L
      6  1893
      7  1893				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1893				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1893					      ADD_LEVEL	_008_R
      1  1893				   LEVEL_ACTIVE__008_R SET	1
      2  1893		       00 93	   LEVEL_NAMED__008_R =	LEVELNUM
      3  1893		       83		      .byte.b	<LEVEL__008_R
      4  1894		       f2		      .byte.b	>LEVEL__008_R
      5  1895		       04		      .byte.b	BANK_LEVEL__008_R
      6  1896
      7  1896				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1896				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1896					      ADD_LEVEL	_009_L
      1  1896				   LEVEL_ACTIVE__009_L SET	1
      2  1896		       00 96	   LEVEL_NAMED__009_L =	LEVELNUM
      3  1896		       b5		      .byte.b	<LEVEL__009_L
      4  1897		       f2		      .byte.b	>LEVEL__009_L
      5  1898		       04		      .byte.b	BANK_LEVEL__009_L
      6  1899
      7  1899				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1899				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1899					      ADD_LEVEL	_009_R
      1  1899				   LEVEL_ACTIVE__009_R SET	1
      2  1899		       00 99	   LEVEL_NAMED__009_R =	LEVELNUM
      3  1899		       e8		      .byte.b	<LEVEL__009_R
      4  189a		       f2		      .byte.b	>LEVEL__009_R
      5  189b		       04		      .byte.b	BANK_LEVEL__009_R
      6  189c
      7  189c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189c					      ADD_LEVEL	_010_L
      1  189c				   LEVEL_ACTIVE__010_L SET	1
      2  189c		       00 9c	   LEVEL_NAMED__010_L =	LEVELNUM
      3  189c		       19		      .byte.b	<LEVEL__010_L
      4  189d		       f3		      .byte.b	>LEVEL__010_L
      5  189e		       04		      .byte.b	BANK_LEVEL__010_L
      6  189f
      7  189f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189f					      ADD_LEVEL	_010_R
      1  189f				   LEVEL_ACTIVE__010_R SET	1
      2  189f		       00 9f	   LEVEL_NAMED__010_R =	LEVELNUM
      3  189f		       54		      .byte.b	<LEVEL__010_R
      4  18a0		       f3		      .byte.b	>LEVEL__010_R
      5  18a1		       04		      .byte.b	BANK_LEVEL__010_R
      6  18a2
      7  18a2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a2					      ADD_LEVEL	_011_L
      1  18a2				   LEVEL_ACTIVE__011_L SET	1
      2  18a2		       00 a2	   LEVEL_NAMED__011_L =	LEVELNUM
      3  18a2		       88		      .byte.b	<LEVEL__011_L
      4  18a3		       f3		      .byte.b	>LEVEL__011_L
      5  18a4		       04		      .byte.b	BANK_LEVEL__011_L
      6  18a5
      7  18a5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a5					      ADD_LEVEL	_011_R
      1  18a5				   LEVEL_ACTIVE__011_R SET	1
      2  18a5		       00 a5	   LEVEL_NAMED__011_R =	LEVELNUM
      3  18a5		       bc		      .byte.b	<LEVEL__011_R
      4  18a6		       f3		      .byte.b	>LEVEL__011_R
      5  18a7		       04		      .byte.b	BANK_LEVEL__011_R
      6  18a8
      7  18a8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a8					      ADD_LEVEL	_012_L
      1  18a8				   LEVEL_ACTIVE__012_L SET	1
      2  18a8		       00 a8	   LEVEL_NAMED__012_L =	LEVELNUM
      3  18a8		       f7		      .byte.b	<LEVEL__012_L
      4  18a9		       f3		      .byte.b	>LEVEL__012_L
      5  18aa		       04		      .byte.b	BANK_LEVEL__012_L
      6  18ab
      7  18ab				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ab				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ab					      ADD_LEVEL	_012_R
      1  18ab				   LEVEL_ACTIVE__012_R SET	1
      2  18ab		       00 ab	   LEVEL_NAMED__012_R =	LEVELNUM
      3  18ab		       28		      .byte.b	<LEVEL__012_R
      4  18ac		       f4		      .byte.b	>LEVEL__012_R
      5  18ad		       04		      .byte.b	BANK_LEVEL__012_R
      6  18ae
      7  18ae				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ae				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ae					      ADD_LEVEL	_013_L
      1  18ae				   LEVEL_ACTIVE__013_L SET	1
      2  18ae		       00 ae	   LEVEL_NAMED__013_L =	LEVELNUM
      3  18ae		       65		      .byte.b	<LEVEL__013_L
      4  18af		       f4		      .byte.b	>LEVEL__013_L
      5  18b0		       04		      .byte.b	BANK_LEVEL__013_L
      6  18b1
      7  18b1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b1					      ADD_LEVEL	_013_R
      1  18b1				   LEVEL_ACTIVE__013_R SET	1
      2  18b1		       00 b1	   LEVEL_NAMED__013_R =	LEVELNUM
      3  18b1		       a5		      .byte.b	<LEVEL__013_R
      4  18b2		       f4		      .byte.b	>LEVEL__013_R
      5  18b3		       04		      .byte.b	BANK_LEVEL__013_R
      6  18b4
      7  18b4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b4					      ADD_LEVEL	_014_L
      1  18b4				   LEVEL_ACTIVE__014_L SET	1
      2  18b4		       00 b4	   LEVEL_NAMED__014_L =	LEVELNUM
      3  18b4		       d9		      .byte.b	<LEVEL__014_L
      4  18b5		       f4		      .byte.b	>LEVEL__014_L
      5  18b6		       04		      .byte.b	BANK_LEVEL__014_L
      6  18b7
      7  18b7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b7					      ADD_LEVEL	_014_R
      1  18b7				   LEVEL_ACTIVE__014_R SET	1
      2  18b7		       00 b7	   LEVEL_NAMED__014_R =	LEVELNUM
      3  18b7		       1d		      .byte.b	<LEVEL__014_R
      4  18b8		       f5		      .byte.b	>LEVEL__014_R
      5  18b9		       04		      .byte.b	BANK_LEVEL__014_R
      6  18ba
      7  18ba				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ba				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ba					      ADD_LEVEL	_015_L
      1  18ba				   LEVEL_ACTIVE__015_L SET	1
      2  18ba		       00 ba	   LEVEL_NAMED__015_L =	LEVELNUM
      3  18ba		       61		      .byte.b	<LEVEL__015_L
      4  18bb		       f5		      .byte.b	>LEVEL__015_L
      5  18bc		       04		      .byte.b	BANK_LEVEL__015_L
      6  18bd
      7  18bd				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18bd				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18bd					      ADD_LEVEL	_015_R
      1  18bd				   LEVEL_ACTIVE__015_R SET	1
      2  18bd		       00 bd	   LEVEL_NAMED__015_R =	LEVELNUM
      3  18bd		       97		      .byte.b	<LEVEL__015_R
      4  18be		       f5		      .byte.b	>LEVEL__015_R
      5  18bf		       04		      .byte.b	BANK_LEVEL__015_R
      6  18c0
      7  18c0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c0					      ADD_LEVEL	_016_L
      1  18c0				   LEVEL_ACTIVE__016_L SET	1
      2  18c0		       00 c0	   LEVEL_NAMED__016_L =	LEVELNUM
      3  18c0		       dd		      .byte.b	<LEVEL__016_L
      4  18c1		       f5		      .byte.b	>LEVEL__016_L
      5  18c2		       04		      .byte.b	BANK_LEVEL__016_L
      6  18c3
      7  18c3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c3					      ADD_LEVEL	_016_R
      1  18c3				   LEVEL_ACTIVE__016_R SET	1
      2  18c3		       00 c3	   LEVEL_NAMED__016_R =	LEVELNUM
      3  18c3		       15		      .byte.b	<LEVEL__016_R
      4  18c4		       f6		      .byte.b	>LEVEL__016_R
      5  18c5		       04		      .byte.b	BANK_LEVEL__016_R
      6  18c6
      7  18c6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c6					      ADD_LEVEL	_017_L
      1  18c6				   LEVEL_ACTIVE__017_L SET	1
      2  18c6		       00 c6	   LEVEL_NAMED__017_L =	LEVELNUM
      3  18c6		       49		      .byte.b	<LEVEL__017_L
      4  18c7		       f6		      .byte.b	>LEVEL__017_L
      5  18c8		       04		      .byte.b	BANK_LEVEL__017_L
      6  18c9
      7  18c9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c9					      ADD_LEVEL	_017_R
      1  18c9				   LEVEL_ACTIVE__017_R SET	1
      2  18c9		       00 c9	   LEVEL_NAMED__017_R =	LEVELNUM
      3  18c9		       94		      .byte.b	<LEVEL__017_R
      4  18ca		       f6		      .byte.b	>LEVEL__017_R
      5  18cb		       04		      .byte.b	BANK_LEVEL__017_R
      6  18cc
      7  18cc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cc					      ADD_LEVEL	_018_L
      1  18cc				   LEVEL_ACTIVE__018_L SET	1
      2  18cc		       00 cc	   LEVEL_NAMED__018_L =	LEVELNUM
      3  18cc		       d8		      .byte.b	<LEVEL__018_L
      4  18cd		       f6		      .byte.b	>LEVEL__018_L
      5  18ce		       04		      .byte.b	BANK_LEVEL__018_L
      6  18cf
      7  18cf				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cf				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cf					      ADD_LEVEL	_018_R
      1  18cf				   LEVEL_ACTIVE__018_R SET	1
      2  18cf		       00 cf	   LEVEL_NAMED__018_R =	LEVELNUM
      3  18cf		       0d		      .byte.b	<LEVEL__018_R
      4  18d0		       f7		      .byte.b	>LEVEL__018_R
      5  18d1		       04		      .byte.b	BANK_LEVEL__018_R
      6  18d2
      7  18d2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d2					      ADD_LEVEL	_019_L
      1  18d2				   LEVEL_ACTIVE__019_L SET	1
      2  18d2		       00 d2	   LEVEL_NAMED__019_L =	LEVELNUM
      3  18d2		       4a		      .byte.b	<LEVEL__019_L
      4  18d3		       f7		      .byte.b	>LEVEL__019_L
      5  18d4		       04		      .byte.b	BANK_LEVEL__019_L
      6  18d5
      7  18d5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d5					      ADD_LEVEL	_019_R
      1  18d5				   LEVEL_ACTIVE__019_R SET	1
      2  18d5		       00 d5	   LEVEL_NAMED__019_R =	LEVELNUM
      3  18d5		       86		      .byte.b	<LEVEL__019_R
      4  18d6		       f7		      .byte.b	>LEVEL__019_R
      5  18d7		       04		      .byte.b	BANK_LEVEL__019_R
      6  18d8
      7  18d8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d8					      ADD_LEVEL	_020_L
      1  18d8				   LEVEL_ACTIVE__020_L SET	1
      2  18d8		       00 d8	   LEVEL_NAMED__020_L =	LEVELNUM
      3  18d8		       00		      .byte.b	<LEVEL__020_L
      4  18d9		       f0		      .byte.b	>LEVEL__020_L
      5  18da		       05		      .byte.b	BANK_LEVEL__020_L
      6  18db
      7  18db				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18db				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18db					      ADD_LEVEL	_020_R
      1  18db				   LEVEL_ACTIVE__020_R SET	1
      2  18db		       00 db	   LEVEL_NAMED__020_R =	LEVELNUM
      3  18db		       40		      .byte.b	<LEVEL__020_R
      4  18dc		       f0		      .byte.b	>LEVEL__020_R
      5  18dd		       05		      .byte.b	BANK_LEVEL__020_R
      6  18de
      7  18de				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18de				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18de					      ADD_LEVEL	_021_L
      1  18de				   LEVEL_ACTIVE__021_L SET	1
      2  18de		       00 de	   LEVEL_NAMED__021_L =	LEVELNUM
      3  18de		       81		      .byte.b	<LEVEL__021_L
      4  18df		       f0		      .byte.b	>LEVEL__021_L
      5  18e0		       05		      .byte.b	BANK_LEVEL__021_L
      6  18e1
      7  18e1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e1					      ADD_LEVEL	_021_R
      1  18e1				   LEVEL_ACTIVE__021_R SET	1
      2  18e1		       00 e1	   LEVEL_NAMED__021_R =	LEVELNUM
      3  18e1		       d8		      .byte.b	<LEVEL__021_R
      4  18e2		       f0		      .byte.b	>LEVEL__021_R
      5  18e3		       05		      .byte.b	BANK_LEVEL__021_R
      6  18e4
      7  18e4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e4					      ADD_LEVEL	_022_L
      1  18e4				   LEVEL_ACTIVE__022_L SET	1
      2  18e4		       00 e4	   LEVEL_NAMED__022_L =	LEVELNUM
      3  18e4		       0d		      .byte.b	<LEVEL__022_L
      4  18e5		       f1		      .byte.b	>LEVEL__022_L
      5  18e6		       05		      .byte.b	BANK_LEVEL__022_L
      6  18e7
      7  18e7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e7					      ADD_LEVEL	_022_R
      1  18e7				   LEVEL_ACTIVE__022_R SET	1
      2  18e7		       00 e7	   LEVEL_NAMED__022_R =	LEVELNUM
      3  18e7		       54		      .byte.b	<LEVEL__022_R
      4  18e8		       f1		      .byte.b	>LEVEL__022_R
      5  18e9		       05		      .byte.b	BANK_LEVEL__022_R
      6  18ea
      7  18ea				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ea				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ea					      ADD_LEVEL	_023_L
      1  18ea				   LEVEL_ACTIVE__023_L SET	1
      2  18ea		       00 ea	   LEVEL_NAMED__023_L =	LEVELNUM
      3  18ea		       91		      .byte.b	<LEVEL__023_L
      4  18eb		       f1		      .byte.b	>LEVEL__023_L
      5  18ec		       05		      .byte.b	BANK_LEVEL__023_L
      6  18ed
      7  18ed				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ed				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ed					      ADD_LEVEL	_023_R
      1  18ed				   LEVEL_ACTIVE__023_R SET	1
      2  18ed		       00 ed	   LEVEL_NAMED__023_R =	LEVELNUM
      3  18ed		       d3		      .byte.b	<LEVEL__023_R
      4  18ee		       f1		      .byte.b	>LEVEL__023_R
      5  18ef		       05		      .byte.b	BANK_LEVEL__023_R
      6  18f0
      7  18f0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    134  18f0
      0  18f0					      ADD_LEVEL	_050_L
      1  18f0				   LEVEL_ACTIVE__050_L SET	1
      2  18f0		       00 f0	   LEVEL_NAMED__050_L =	LEVELNUM
      3  18f0		       00		      .byte.b	<LEVEL__050_L
      4  18f1		       f0		      .byte.b	>LEVEL__050_L
      5  18f2		       07		      .byte.b	BANK_LEVEL__050_L
      6  18f3
      7  18f3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f3					      ADD_LEVEL	_050_R
      1  18f3				   LEVEL_ACTIVE__050_R SET	1
      2  18f3		       00 f3	   LEVEL_NAMED__050_R =	LEVELNUM
      3  18f3		       4e		      .byte.b	<LEVEL__050_R
      4  18f4		       f0		      .byte.b	>LEVEL__050_R
      5  18f5		       07		      .byte.b	BANK_LEVEL__050_R
      6  18f6
      7  18f6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f6					      ADD_LEVEL	_051_L
      1  18f6				   LEVEL_ACTIVE__051_L SET	1
      2  18f6		       00 f6	   LEVEL_NAMED__051_L =	LEVELNUM
      3  18f6		       88		      .byte.b	<LEVEL__051_L
      4  18f7		       f0		      .byte.b	>LEVEL__051_L
      5  18f8		       07		      .byte.b	BANK_LEVEL__051_L
      6  18f9
      7  18f9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f9					      ADD_LEVEL	_051_R
      1  18f9				   LEVEL_ACTIVE__051_R SET	1
      2  18f9		       00 f9	   LEVEL_NAMED__051_R =	LEVELNUM
      3  18f9		       dc		      .byte.b	<LEVEL__051_R
      4  18fa		       f0		      .byte.b	>LEVEL__051_R
      5  18fb		       07		      .byte.b	BANK_LEVEL__051_R
      6  18fc
      7  18fc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18fc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18fc					      ADD_LEVEL	_052_L
      1  18fc				   LEVEL_ACTIVE__052_L SET	1
      2  18fc		       00 fc	   LEVEL_NAMED__052_L =	LEVELNUM
      3  18fc		       2e		      .byte.b	<LEVEL__052_L
      4  18fd		       f1		      .byte.b	>LEVEL__052_L
      5  18fe		       07		      .byte.b	BANK_LEVEL__052_L
      6  18ff
      7  18ff				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ff				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ff					      ADD_LEVEL	_052_R
      1  18ff				   LEVEL_ACTIVE__052_R SET	1
      2  18ff		       00 ff	   LEVEL_NAMED__052_R =	LEVELNUM
      3  18ff		       69		      .byte.b	<LEVEL__052_R
      4  1900		       f1		      .byte.b	>LEVEL__052_R
      5  1901		       07		      .byte.b	BANK_LEVEL__052_R
      6  1902
      7  1902				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1902				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1902					      ADD_LEVEL	_053_L
      1  1902				   LEVEL_ACTIVE__053_L SET	1
      2  1902		       01 02	   LEVEL_NAMED__053_L =	LEVELNUM
      3  1902		       b2		      .byte.b	<LEVEL__053_L
      4  1903		       f1		      .byte.b	>LEVEL__053_L
      5  1904		       07		      .byte.b	BANK_LEVEL__053_L
      6  1905
      7  1905				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1905				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1905					      ADD_LEVEL	_053_R
      1  1905				   LEVEL_ACTIVE__053_R SET	1
      2  1905		       01 05	   LEVEL_NAMED__053_R =	LEVELNUM
      3  1905		       08		      .byte.b	<LEVEL__053_R
      4  1906		       f2		      .byte.b	>LEVEL__053_R
      5  1907		       07		      .byte.b	BANK_LEVEL__053_R
      6  1908
      7  1908				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1908				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1908					      ADD_LEVEL	_054_L
      1  1908				   LEVEL_ACTIVE__054_L SET	1
      2  1908		       01 08	   LEVEL_NAMED__054_L =	LEVELNUM
      3  1908		       56		      .byte.b	<LEVEL__054_L
      4  1909		       f2		      .byte.b	>LEVEL__054_L
      5  190a		       07		      .byte.b	BANK_LEVEL__054_L
      6  190b
      7  190b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190b					      ADD_LEVEL	_054_R
      1  190b				   LEVEL_ACTIVE__054_R SET	1
      2  190b		       01 0b	   LEVEL_NAMED__054_R =	LEVELNUM
      3  190b		       a3		      .byte.b	<LEVEL__054_R
      4  190c		       f2		      .byte.b	>LEVEL__054_R
      5  190d		       07		      .byte.b	BANK_LEVEL__054_R
      6  190e
      7  190e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190e					      ADD_LEVEL	_055_L
      1  190e				   LEVEL_ACTIVE__055_L SET	1
      2  190e		       01 0e	   LEVEL_NAMED__055_L =	LEVELNUM
      3  190e		       ed		      .byte.b	<LEVEL__055_L
      4  190f		       f2		      .byte.b	>LEVEL__055_L
      5  1910		       07		      .byte.b	BANK_LEVEL__055_L
      6  1911
      7  1911				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1911				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1911					      ADD_LEVEL	_055_R
      1  1911				   LEVEL_ACTIVE__055_R SET	1
      2  1911		       01 11	   LEVEL_NAMED__055_R =	LEVELNUM
      3  1911		       48		      .byte.b	<LEVEL__055_R
      4  1912		       f3		      .byte.b	>LEVEL__055_R
      5  1913		       07		      .byte.b	BANK_LEVEL__055_R
      6  1914
      7  1914				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1914				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1914					      ADD_LEVEL	_056_L
      1  1914				   LEVEL_ACTIVE__056_L SET	1
      2  1914		       01 14	   LEVEL_NAMED__056_L =	LEVELNUM
      3  1914		       9e		      .byte.b	<LEVEL__056_L
      4  1915		       f3		      .byte.b	>LEVEL__056_L
      5  1916		       07		      .byte.b	BANK_LEVEL__056_L
      6  1917
      7  1917				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1917				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1917					      ADD_LEVEL	_056_R
      1  1917				   LEVEL_ACTIVE__056_R SET	1
      2  1917		       01 17	   LEVEL_NAMED__056_R =	LEVELNUM
      3  1917		       f9		      .byte.b	<LEVEL__056_R
      4  1918		       f3		      .byte.b	>LEVEL__056_R
      5  1919		       07		      .byte.b	BANK_LEVEL__056_R
      6  191a
      7  191a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  191a					      ADD_LEVEL	_057_L
      1  191a				   LEVEL_ACTIVE__057_L SET	1
      2  191a		       01 1a	   LEVEL_NAMED__057_L =	LEVELNUM
      3  191a		       55		      .byte.b	<LEVEL__057_L
      4  191b		       f4		      .byte.b	>LEVEL__057_L
      5  191c		       07		      .byte.b	BANK_LEVEL__057_L
      6  191d
      7  191d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    150  191d
      0  191d					      ADD_LEVEL	_060_R
      1  191d				   LEVEL_ACTIVE__060_R SET	1
      2  191d		       01 1d	   LEVEL_NAMED__060_R =	LEVELNUM
      3  191d		       ac		      .byte.b	<LEVEL__060_R
      4  191e		       f4		      .byte.b	>LEVEL__060_R
      5  191f		       07		      .byte.b	BANK_LEVEL__060_R
      6  1920
      7  1920				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1920				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1920					      ADD_LEVEL	_061_R
      1  1920				   LEVEL_ACTIVE__061_R SET	1
      2  1920		       01 20	   LEVEL_NAMED__061_R =	LEVELNUM
      3  1920		       4a		      .byte.b	<LEVEL__061_R
      4  1921		       f5		      .byte.b	>LEVEL__061_R
      5  1922		       07		      .byte.b	BANK_LEVEL__061_R
      6  1923
      7  1923				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1923				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1923					      ADD_LEVEL	_061_L
      1  1923				   LEVEL_ACTIVE__061_L SET	1
      2  1923		       01 23	   LEVEL_NAMED__061_L =	LEVELNUM
      3  1923		       f5		      .byte.b	<LEVEL__061_L
      4  1924		       f4		      .byte.b	>LEVEL__061_L
      5  1925		       07		      .byte.b	BANK_LEVEL__061_L
      6  1926
      7  1926				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1926				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1926					      ADD_LEVEL	_062_L
      1  1926				   LEVEL_ACTIVE__062_L SET	1
      2  1926		       01 26	   LEVEL_NAMED__062_L =	LEVELNUM
      3  1926		       94		      .byte.b	<LEVEL__062_L
      4  1927		       f5		      .byte.b	>LEVEL__062_L
      5  1928		       07		      .byte.b	BANK_LEVEL__062_L
      6  1929
      7  1929				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1929				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1929					      ADD_LEVEL	_062_R
      1  1929				   LEVEL_ACTIVE__062_R SET	1
      2  1929		       01 29	   LEVEL_NAMED__062_R =	LEVELNUM
      3  1929		       ec		      .byte.b	<LEVEL__062_R
      4  192a		       f5		      .byte.b	>LEVEL__062_R
      5  192b		       07		      .byte.b	BANK_LEVEL__062_R
      6  192c
      7  192c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  192c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  192c					      ADD_LEVEL	_063_L
      1  192c				   LEVEL_ACTIVE__063_L SET	1
      2  192c		       01 2c	   LEVEL_NAMED__063_L =	LEVELNUM
      3  192c		       39		      .byte.b	<LEVEL__063_L
      4  192d		       f6		      .byte.b	>LEVEL__063_L
      5  192e		       07		      .byte.b	BANK_LEVEL__063_L
      6  192f
      7  192f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  192f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  192f					      ADD_LEVEL	_063_R
      1  192f				   LEVEL_ACTIVE__063_R SET	1
      2  192f		       01 2f	   LEVEL_NAMED__063_R =	LEVELNUM
      3  192f		       8a		      .byte.b	<LEVEL__063_R
      4  1930		       f6		      .byte.b	>LEVEL__063_R
      5  1931		       07		      .byte.b	BANK_LEVEL__063_R
      6  1932
      7  1932				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1932				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1932					      ADD_LEVEL	_064_R
      1  1932				   LEVEL_ACTIVE__064_R SET	1
      2  1932		       01 32	   LEVEL_NAMED__064_R =	LEVELNUM
      3  1932		       39		      .byte.b	<LEVEL__064_R
      4  1933		       f7		      .byte.b	>LEVEL__064_R
      5  1934		       07		      .byte.b	BANK_LEVEL__064_R
      6  1935
      7  1935				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1935				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1935					      ADD_LEVEL	_064_L
      1  1935				   LEVEL_ACTIVE__064_L SET	1
      2  1935		       01 35	   LEVEL_NAMED__064_L =	LEVELNUM
      3  1935		       dd		      .byte.b	<LEVEL__064_L
      4  1936		       f6		      .byte.b	>LEVEL__064_L
      5  1937		       07		      .byte.b	BANK_LEVEL__064_L
      6  1938
      7  1938				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1938				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1938					      ADD_LEVEL	_065_R
      1  1938				   LEVEL_ACTIVE__065_R SET	1
      2  1938		       01 38	   LEVEL_NAMED__065_R =	LEVELNUM
      3  1938		       59		      .byte.b	<LEVEL__065_R
      4  1939		       f0		      .byte.b	>LEVEL__065_R
      5  193a		       08		      .byte.b	BANK_LEVEL__065_R
      6  193b
      7  193b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  193b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  193b					      ADD_LEVEL	_065_L
      1  193b				   LEVEL_ACTIVE__065_L SET	1
      2  193b		       01 3b	   LEVEL_NAMED__065_L =	LEVELNUM
      3  193b		       00		      .byte.b	<LEVEL__065_L
      4  193c		       f0		      .byte.b	>LEVEL__065_L
      5  193d		       08		      .byte.b	BANK_LEVEL__065_L
      6  193e
      7  193e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  193e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  193e					      ADD_LEVEL	_066_R
      1  193e				   LEVEL_ACTIVE__066_R SET	1
      2  193e		       01 3e	   LEVEL_NAMED__066_R =	LEVELNUM
      3  193e		       fd		      .byte.b	<LEVEL__066_R
      4  193f		       f0		      .byte.b	>LEVEL__066_R
      5  1940		       08		      .byte.b	BANK_LEVEL__066_R
      6  1941
      7  1941				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1941				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1941					      ADD_LEVEL	_066_L
      1  1941				   LEVEL_ACTIVE__066_L SET	1
      2  1941		       01 41	   LEVEL_NAMED__066_L =	LEVELNUM
      3  1941		       a2		      .byte.b	<LEVEL__066_L
      4  1942		       f0		      .byte.b	>LEVEL__066_L
      5  1943		       08		      .byte.b	BANK_LEVEL__066_L
      6  1944
      7  1944				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1944				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1944					      ADD_LEVEL	_067_R
      1  1944				   LEVEL_ACTIVE__067_R SET	1
      2  1944		       01 44	   LEVEL_NAMED__067_R =	LEVELNUM
      3  1944		       a2		      .byte.b	<LEVEL__067_R
      4  1945		       f1		      .byte.b	>LEVEL__067_R
      5  1946		       08		      .byte.b	BANK_LEVEL__067_R
      6  1947
      7  1947				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1947				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1947					      ADD_LEVEL	_067_L
      1  1947				   LEVEL_ACTIVE__067_L SET	1
      2  1947		       01 47	   LEVEL_NAMED__067_L =	LEVELNUM
      3  1947		       54		      .byte.b	<LEVEL__067_L
      4  1948		       f1		      .byte.b	>LEVEL__067_L
      5  1949		       08		      .byte.b	BANK_LEVEL__067_L
      6  194a
      7  194a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  194a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  194a					      ADD_LEVEL	_068_R
      1  194a				   LEVEL_ACTIVE__068_R SET	1
      2  194a		       01 4a	   LEVEL_NAMED__068_R =	LEVELNUM
      3  194a		       5d		      .byte.b	<LEVEL__068_R
      4  194b		       f2		      .byte.b	>LEVEL__068_R
      5  194c		       08		      .byte.b	BANK_LEVEL__068_R
      6  194d
      7  194d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  194d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  194d					      ADD_LEVEL	_068_L
      1  194d				   LEVEL_ACTIVE__068_L SET	1
      2  194d		       01 4d	   LEVEL_NAMED__068_L =	LEVELNUM
      3  194d		       08		      .byte.b	<LEVEL__068_L
      4  194e		       f2		      .byte.b	>LEVEL__068_L
      5  194f		       08		      .byte.b	BANK_LEVEL__068_L
      6  1950
      7  1950				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1950				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1950					      ADD_LEVEL	_069_R
      1  1950				   LEVEL_ACTIVE__069_R SET	1
      2  1950		       01 50	   LEVEL_NAMED__069_R =	LEVELNUM
      3  1950		       03		      .byte.b	<LEVEL__069_R
      4  1951		       f3		      .byte.b	>LEVEL__069_R
      5  1952		       08		      .byte.b	BANK_LEVEL__069_R
      6  1953
      7  1953				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1953				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1953					      ADD_LEVEL	_069_L
      1  1953				   LEVEL_ACTIVE__069_L SET	1
      2  1953		       01 53	   LEVEL_NAMED__069_L =	LEVELNUM
      3  1953		       b4		      .byte.b	<LEVEL__069_L
      4  1954		       f2		      .byte.b	>LEVEL__069_L
      5  1955		       08		      .byte.b	BANK_LEVEL__069_L
      6  1956
      7  1956				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1956				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    170  1956
      0  1956					      ADD_LEVEL	_103_Arielle
      1  1956				   LEVEL_ACTIVE__103_Arielle SET	1
      2  1956		       01 56	   LEVEL_NAMED__103_Arielle =	LEVELNUM
      3  1956		       ef		      .byte.b	<LEVEL__103_Arielle
      4  1957		       f1		      .byte.b	>LEVEL__103_Arielle
      5  1958		       09		      .byte.b	BANK_LEVEL__103_Arielle
      6  1959
      7  1959				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1959				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1959					      ADD_LEVEL	_103_Ajalae
      1  1959				   LEVEL_ACTIVE__103_Ajalae SET	1
      2  1959		       01 59	   LEVEL_NAMED__103_Ajalae =	LEVELNUM
      3  1959		       a7		      .byte.b	<LEVEL__103_Ajalae
      4  195a		       f1		      .byte.b	>LEVEL__103_Ajalae
      5  195b		       09		      .byte.b	BANK_LEVEL__103_Ajalae
      6  195c
      7  195c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  195c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  195c					      ADD_LEVEL	_103_Adin
      1  195c				   LEVEL_ACTIVE__103_Adin SET	1
      2  195c		       01 5c	   LEVEL_NAMED__103_Adin =	LEVELNUM
      3  195c		       5b		      .byte.b	<LEVEL__103_Adin
      4  195d		       f1		      .byte.b	>LEVEL__103_Adin
      5  195e		       09		      .byte.b	BANK_LEVEL__103_Adin
      6  195f
      7  195f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  195f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  195f					      ADD_LEVEL	_102_Raven
      1  195f				   LEVEL_ACTIVE__102_Raven SET	1
      2  195f		       01 5f	   LEVEL_NAMED__102_Raven =	LEVELNUM
      3  195f		       ec		      .byte.b	<LEVEL__102_Raven
      4  1960		       f0		      .byte.b	>LEVEL__102_Raven
      5  1961		       09		      .byte.b	BANK_LEVEL__102_Raven
      6  1962
      7  1962				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1962				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1962					      ADD_LEVEL	_102_Oralia
      1  1962				   LEVEL_ACTIVE__102_Oralia SET	1
      2  1962		       01 62	   LEVEL_NAMED__102_Oralia =	LEVELNUM
      3  1962		       a7		      .byte.b	<LEVEL__102_Oralia
      4  1963		       f0		      .byte.b	>LEVEL__102_Oralia
      5  1964		       09		      .byte.b	BANK_LEVEL__102_Oralia
      6  1965
      7  1965				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1965				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1965					      ADD_LEVEL	_102_Natalie
      1  1965				   LEVEL_ACTIVE__102_Natalie SET	1
      2  1965		       01 65	   LEVEL_NAMED__102_Natalie =	LEVELNUM
      3  1965		       00		      .byte.b	<LEVEL__102_Natalie
      4  1966		       f0		      .byte.b	>LEVEL__102_Natalie
      5  1967		       09		      .byte.b	BANK_LEVEL__102_Natalie
      6  1968
      7  1968				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1968				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1968					      ADD_LEVEL	_102_Mirabel
      1  1968				   LEVEL_ACTIVE__102_Mirabel SET	1
      2  1968		       01 68	   LEVEL_NAMED__102_Mirabel =	LEVELNUM
      3  1968		       47		      .byte.b	<LEVEL__102_Mirabel
      4  1969		       f0		      .byte.b	>LEVEL__102_Mirabel
      5  196a		       09		      .byte.b	BANK_LEVEL__102_Mirabel
      6  196b
      7  196b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  196b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  196b					      ADD_LEVEL	_1XJH_Tara_Gelson
      1  196b				   LEVEL_ACTIVE__1XJH_Tara_Gelson SET	1
      2  196b		       01 6b	   LEVEL_NAMED__1XJH_Tara_Gelson =	LEVELNUM
      3  196b		       40		      .byte.b	<LEVEL__1XJH_Tara_Gelson
      4  196c		       f2		      .byte.b	>LEVEL__1XJH_Tara_Gelson
      5  196d		       09		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
      6  196e
      7  196e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  196e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  196e					      ADD_LEVEL	_1R7X_Alison
      1  196e				   LEVEL_ACTIVE__1R7X_Alison SET	1
      2  196e		       01 6e	   LEVEL_NAMED__1R7X_Alison =	LEVELNUM
      3  196e		       7b		      .byte.b	<LEVEL__1R7X_Alison
      4  196f		       f2		      .byte.b	>LEVEL__1R7X_Alison
      5  1970		       09		      .byte.b	BANK_LEVEL__1R7X_Alison
      6  1971
      7  1971				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1971				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1971					      ADD_LEVEL	_1KWD_Cecile_Clayworth
      1  1971				   LEVEL_ACTIVE__1KWD_Cecile_Clayworth SET	1
      2  1971		       01 71	   LEVEL_NAMED__1KWD_Cecile_Clayworth =	LEVELNUM
      3  1971		       a9		      .byte.b	<LEVEL__1KWD_Cecile_Clayworth
      4  1972		       f2		      .byte.b	>LEVEL__1KWD_Cecile_Clayworth
      5  1973		       09		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
      6  1974
      7  1974				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1974				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1974					      ADD_LEVEL	_1EKT_Samantha_Gelson
      1  1974				   LEVEL_ACTIVE__1EKT_Samantha_Gelson SET	1
      2  1974		       01 74	   LEVEL_NAMED__1EKT_Samantha_Gelson =	LEVELNUM
      3  1974		       de		      .byte.b	<LEVEL__1EKT_Samantha_Gelson
      4  1975		       f2		      .byte.b	>LEVEL__1EKT_Samantha_Gelson
      5  1976		       09		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
      6  1977
      7  1977				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1977				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1977					      ADD_LEVEL	_0VM5_Andrea_Wadd
      1  1977				   LEVEL_ACTIVE__0VM5_Andrea_Wadd SET	1
      2  1977		       01 77	   LEVEL_NAMED__0VM5_Andrea_Wadd =	LEVELNUM
      3  1977		       18		      .byte.b	<LEVEL__0VM5_Andrea_Wadd
      4  1978		       f3		      .byte.b	>LEVEL__0VM5_Andrea_Wadd
      5  1979		       09		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
      6  197a
      7  197a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  197a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  197a					      ADD_LEVEL	_0PAL_Jill_Leatherby
      1  197a				   LEVEL_ACTIVE__0PAL_Jill_Leatherby SET	1
      2  197a		       01 7a	   LEVEL_NAMED__0PAL_Jill_Leatherby =	LEVELNUM
      3  197a		       46		      .byte.b	<LEVEL__0PAL_Jill_Leatherby
      4  197b		       f3		      .byte.b	>LEVEL__0PAL_Jill_Leatherby
      5  197c		       09		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
      6  197d
      7  197d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  197d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  197d					      ADD_LEVEL	_0IZ1_Sophia
      1  197d				   LEVEL_ACTIVE__0IZ1_Sophia SET	1
      2  197d		       01 7d	   LEVEL_NAMED__0IZ1_Sophia =	LEVELNUM
      3  197d		       71		      .byte.b	<LEVEL__0IZ1_Sophia
      4  197e		       f3		      .byte.b	>LEVEL__0IZ1_Sophia
      5  197f		       09		      .byte.b	BANK_LEVEL__0IZ1_Sophia
      6  1980
      7  1980				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1980				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1980					      ADD_LEVEL	_0CNH_Alice
      1  1980				   LEVEL_ACTIVE__0CNH_Alice SET	1
      2  1980		       01 80	   LEVEL_NAMED__0CNH_Alice =	LEVELNUM
      3  1980		       9d		      .byte.b	<LEVEL__0CNH_Alice
      4  1981		       f3		      .byte.b	>LEVEL__0CNH_Alice
      5  1982		       09		      .byte.b	BANK_LEVEL__0CNH_Alice
      6  1983
      7  1983				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1983				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1983					      ADD_LEVEL	Thomas_Reinke16
      1  1983				   LEVEL_ACTIVE_Thomas_Reinke16 SET	1
      2  1983		       01 83	   LEVEL_NAMED_Thomas_Reinke16 =	LEVELNUM
      3  1983		       6d		      .byte.b	<LEVEL_Thomas_Reinke16
      4  1984		       f5		      .byte.b	>LEVEL_Thomas_Reinke16
      5  1985		       09		      .byte.b	BANK_LEVEL_Thomas_Reinke16
      6  1986
      7  1986				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1986				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1986					      ADD_LEVEL	bDarcy_Burnsell101
      1  1986				   LEVEL_ACTIVE_bDarcy_Burnsell101 SET	1
      2  1986		       01 86	   LEVEL_NAMED_bDarcy_Burnsell101 =	LEVELNUM
      3  1986		       f3		      .byte.b	<LEVEL_bDarcy_Burnsell101
      4  1987		       f4		      .byte.b	>LEVEL_bDarcy_Burnsell101
      5  1988		       09		      .byte.b	BANK_LEVEL_bDarcy_Burnsell101
      6  1989
      7  1989				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1989				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1989					      ADD_LEVEL	bAlfa_DrFogh
      1  1989				   LEVEL_ACTIVE_bAlfa_DrFogh SET	1
      2  1989		       01 89	   LEVEL_NAMED_bAlfa_DrFogh =	LEVELNUM
      3  1989		       ca		      .byte.b	<LEVEL_bAlfa_DrFogh
      4  198a		       f3		      .byte.b	>LEVEL_bAlfa_DrFogh
      5  198b		       09		      .byte.b	BANK_LEVEL_bAlfa_DrFogh
      6  198c
      7  198c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  198c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  198c					      ADD_LEVEL	bAislin101
      1  198c				   LEVEL_ACTIVE_bAislin101 SET	1
      2  198c		       01 8c	   LEVEL_NAMED_bAislin101 =	LEVELNUM
      3  198c		       30		      .byte.b	<LEVEL_bAislin101
      4  198d		       f5		      .byte.b	>LEVEL_bAislin101
      5  198e		       09		      .byte.b	BANK_LEVEL_bAislin101
      6  198f
      7  198f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  198f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  198f					      ADD_LEVEL	b51X_Sharpen
      1  198f				   LEVEL_ACTIVE_b51X_Sharpen SET	1
      2  198f		       01 8f	   LEVEL_NAMED_b51X_Sharpen =	LEVELNUM
      3  198f		       72		      .byte.b	<LEVEL_b51X_Sharpen
      4  1990		       f4		      .byte.b	>LEVEL_b51X_Sharpen
      5  1991		       09		      .byte.b	BANK_LEVEL_b51X_Sharpen
      6  1992
      7  1992				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1992				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    191  1992							;    ADD_LEVEL b82X_Sharpen
    192  1992
    193  1992
    194  1992				   finX
    195  1992							; now put the soil in - fill from the outsides
    196  1992
    197  1992		       a9 01		      lda	#CHARACTER_SOIL
    198  1994		       85 8e		      sta	POS_Type
    199  1996
    200  1996		       a9 15		      lda	#SIZE_BOARD_Y-1
    201  1998		       85 8b		      sta	POS_Y
    202  199a
    203  199a		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    204  199c		       85 8a		      sta	POS_X
    205  199e		       20 26 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    206  19a1		       c9 01		      cmp	#CHARACTER_SOIL
    207  19a3		       f0 07		      beq	kg2a
    208  19a5		       c9 00		      cmp	#0
    209  19a7		       d0 07		      bne	endzap1
    210  19a9		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    211  19ac		       c6 8a	   kg2a       dec	POS_X
    212  19ae		       10 ee		      bpl	zap1
    213  19b0
    214  19b0		       a9 00	   endzap1    lda	#0
    215  19b2		       85 8a		      sta	POS_X
    216  19b4		       20 26 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    217  19b7		       c9 01		      cmp	#CHARACTER_SOIL
    218  19b9		       f0 07		      beq	kg2
    219  19bb		       c9 00		      cmp	#0
    220  19bd		       d0 0b		      bne	endzap2
    221  19bf		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    222  19c2		       e6 8a	   kg2	      inc	POS_X
    223  19c4		       a5 8a		      lda	POS_X
    224  19c6		       c9 28		      cmp	#SIZE_BOARD_X
    225  19c8		       d0 ea		      bne	zap2
    226  19ca
    227  19ca		       c6 8b	   endzap2    dec	POS_Y
    228  19cc		       10 cc		      bpl	xlin
    229  19ce
    230  19ce
    231  19ce		       a9 27		      lda	#SIZE_BOARD_X-1
    232  19d0		       85 8a		      sta	POS_X
    233  19d2
    234  19d2		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    235  19d4		       85 8b		      sta	POS_Y
    236  19d6		       20 26 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    237  19d9		       c9 01		      cmp	#CHARACTER_SOIL
    238  19db		       f0 07		      beq	kg3
    239  19dd		       c9 00		      cmp	#0
    240  19df		       d0 07		      bne	endzapy1
    241  19e1		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    242  19e4		       c6 8b	   kg3	      dec	POS_Y
    243  19e6		       10 ee		      bpl	zapy1
    244  19e8
    245  19e8		       a9 00	   endzapy1   lda	#0
    246  19ea		       85 8b		      sta	POS_Y
    247  19ec		       20 26 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    248  19ef		       c9 01		      cmp	#CHARACTER_SOIL
    249  19f1		       f0 07		      beq	kg3b
    250  19f3		       c9 00		      cmp	#0
    251  19f5		       d0 0b		      bne	endzapy2
    252  19f7		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    253  19fa		       e6 8b	   kg3b       inc	POS_Y
    254  19fc		       a5 8b		      lda	POS_Y
    255  19fe		       c9 16		      cmp	#SIZE_BOARD_Y
    256  1a00		       d0 ea		      bne	zapy2
    257  1a02
    258  1a02		       c6 8a	   endzapy2   dec	POS_X
    259  1a04		       10 cc		      bpl	ylin
    260  1a06		       60		      rts
    261  1a07
      0  1a07					      DEFINE_SUBROUTINE	RegisterOneMoreTarget
      1  1a07		       00 03	   BANK_RegisterOneMoreTarget =	_CURRENT_BANK
      2  1a07					      SUBROUTINE
      3  1a07				   RegisterOneMoreTarget
    263  1a07
    264  1a07		       f8		      sed
    265  1a08		       18		      clc
    266  1a09		       a5 b9		      lda	targetsRequired
    267  1a0b		       69 01		      adc	#1
    268  1a0d		       85 b9		      sta	targetsRequired
    269  1a0f		       d8		      cld
    270  1a10		       60		      rts
    271  1a11
    272  1a11							;A	 steel wall
    273  1a11							;B	 soil (surround)
    274  1a11							;C	 box
    275  1a11
    276  1a11
    277  1a11				   C1
    278  1a11		       b6 2a a8 48	      .byte.b	$b6,$2A,$a8,$48
    279  1a15		       c8 78 28 98	      .byte.b	$C8,$78,$28,$98
    280  1a19				   C2
    281  1a19		       62 a4 22 84	      .byte.b	$62,$A4,$22,$84
    282  1a1d		       44 82 f4 64	      .byte.b	$44,$82,$F4,$64
    283  1a21				   C3
    284  1a21		       2a 7a f8 b8	      .byte.b	$2a,$7A,$f8,$B8
    285  1a25		       fc c6 98 ea	      .byte.b	$FC,$C6,$98,$Ea
    286  1a29
    287  1a29							; C6 44 2A	 browns
    288  1a29							; BA 96 E8	 ice blues
    289  1a29
    290  1a29
      0  1a29					      DEFINE_SUBROUTINE	UnpackLevel
      1  1a29		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  1a29					      SUBROUTINE
      3  1a29				   UnpackLevel
    292  1a29
    293  1a29		       85 c5		      sta	RAM_Bank
    294  1a2b
    295  1a2b							; has to be done before decoding the level to have the platform right:
    296  1a2b							;	    SET_PLATFORM
    297  1a2b
    298  1a2b		       a9 01		      lda	#CHARACTER_SOIL
    299  1a2d		       85 8e		      sta	POS_Type
    300  1a2f
    301  1a2f		       a9 15		      lda	#SIZE_BOARD_Y-1
    302  1a31		       85 8b		      sta	POS_Y
    303  1a33		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    304  1a35		       85 8a		      sta	POS_X
    305  1a37		       20 3a f8    xyClear    jsr	PutBoardCharacterFromRAM
    306  1a3a		       c6 8a		      dec	POS_X
    307  1a3c		       10 f9		      bpl	xyClear
    308  1a3e		       c6 8b		      dec	POS_Y
    309  1a40		       10 f1		      bpl	xyLine
    310  1a42
    311  1a42		       a9 06		      lda	#6
    312  1a44		       85 da		      sta	base_x
    313  1a46		       85 db		      sta	base_y
    314  1a48
    315  1a48		       a5 ca		      lda	NextLevelTrigger
    316  1a4a		       09 80		      ora	#BIT_NEXTLEVEL
    317  1a4c		       85 ca		      sta	NextLevelTrigger
    318  1a4e
    319  1a4e		       a5 b4		      lda	levelX
    320  1a50		       0a		      asl
    321  1a51		       65 b4		      adc	levelX
    322  1a53		       a8		      tay
    323  1a54		       38		      sec
    324  1a55		       b9 00 f0 	      lda	LevelInformation,y
    325  1a58		       e9 01		      sbc	#1
    326  1a5a		       85 c0		      sta	Board_AddressR
    327  1a5c		       b9 01 f0 	      lda	LevelInformation+1,y
    328  1a5f		       e9 00		      sbc	#0
    329  1a61		       85 c1		      sta	Board_AddressR+1
    330  1a63		       b9 02 f0 	      lda	LevelInformation+2,y
    331  1a66		       85 b0		      sta	LEVEL_bank
    332  1a68
    333  1a68		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    334  1a6a		       85 c4		      sta	ROM_Bank	; GetROMByte returns to this bank
    335  1a6c
    336  1a6c		       a5 b4		      lda	levelX
    337  1a6e		       29 07		      and	#7
    338  1a70		       aa		      tax
    339  1a71		       bd 11 f2 	      lda	C1,x
    340  1a74		       85 bd		      sta	color
    341  1a76		       bd 19 f2 	      lda	C2,x
    342  1a79		       85 be		      sta	color+1
    343  1a7b		       bd 21 f2 	      lda	C3,x
    344  1a7e		       85 bf		      sta	color+2
    345  1a80
    346  1a80							;NEXT_RANDOM
    347  1a80							;and #$F0
    348  1a80							;ora #$A
    349  1a80							;lda #$ba
    350  1a80							;sta color
    351  1a80							;lda #$96
    352  1a80							;lda #$A0
    353  1a80							;sta color+1
    354  1a80							;lda #$e8 ;lda #$9C
    355  1a80							;sta color+2
    356  1a80
    357  1a80							; good colours
    358  1a80
    359  1a80
    360  1a80		       a9 00		      lda	#$00
    361  1a82		       85 ba		      sta	moveCounter
    362  1a84		       85 bb		      sta	moveCounterHi
    363  1a86		       85 bc		      sta	moveCounterBinary
    364  1a88
    365  1a88		       a9 00		      lda	#$00	; BCD reminder!
    366  1a8a		       85 b9		      sta	targetsRequired	; # of targets that do NOT have boxes on them
    367  1a8c
    368  1a8c							;lda #SIZE_BOARD_X
    369  1a8c							;sta BoardLimit_Width
    370  1a8c							;lda #SIZE_BOARD_Y
    371  1a8c							;sta BoardLimit_Height
    372  1a8c							;lda #$5
    373  1a8c							;sta targetsRequired		   ;	   should never be 0
    374  1a8c
    375  1a8c		       a9 18		      lda	#24	; arbitrary
    376  1a8e		       85 b8		      sta	ThrottleSpeed
    377  1a90
    378  1a90							; first fill bg with character_soil
    379  1a90							; then rle unpack level
    380  1a90							; change level colours
    381  1a90
    382  1a90		       a9 00		      lda	#0
    383  1a92		       85 8a		      sta	POS_X
    384  1a94		       85 8b		      sta	POS_Y
    385  1a96		       85 94		      sta	BoardLimit_Width
    386  1a98		       85 95		      sta	BoardLimit_Height
    387  1a9a
    388  1a9a				   GetNextItem
    389  1a9a
    390  1a9a		       a9 01		      lda	#1
    391  1a9c		       85 dc		      sta	upk_length
    392  1a9e		       a9 00		      lda	#0
    393  1aa0		       85 dd		      sta	upk_column	; reuse var - this flags a digit already
    394  1aa2
    395  1aa2		       e6 c0	   Get2       inc	Board_AddressR
    396  1aa4		       d0 02		      bne	addrOK
    397  1aa6		       e6 c1		      inc	Board_AddressR+1
    398  1aa8				   addrOK
    399  1aa8
    400  1aa8		       a5 b0		      lda	LEVEL_bank
    401  1aaa		       a0 00		      ldy	#0
    402  1aac		       20 0f f8 	      jsr	GetROMByte
    403  1aaf		       85 de		      sta	upk_temp	;scratch
    404  1ab1
    405  1ab1
    406  1ab1		       c9 00		      cmp	#0
    407  1ab3		       d0 03		      bne	parse
    408  1ab5		       4c 92 f1 	      jmp	finX
    409  1ab8				   parse
    410  1ab8		       c9 3a		      cmp	#"9"+1
    411  1aba		       b0 1e		      bcs	notDigit
    412  1abc		       c9 30		      cmp	#"0"
    413  1abe		       90 1a		      bcc	notDigit
    414  1ac0
    415  1ac0		       a5 dd		      lda	upk_column
    416  1ac2		       f0 09		      beq	firstDig
    417  1ac4
    418  1ac4		       a5 dc		      lda	upk_length
    419  1ac6		       0a		      asl
    420  1ac7		       0a		      asl
    421  1ac8		       0a		      asl
    422  1ac9		       65 dc		      adc	upk_length
    423  1acb		       65 dc		      adc	upk_length
    424  1acd
    425  1acd		       18	   firstDig   clc
    426  1ace		       65 de		      adc	upk_temp
    427  1ad0		       38		      sec
    428  1ad1		       e9 30		      sbc	#"0"
    429  1ad3		       85 dc		      sta	upk_length
    430  1ad5		       e6 dd		      inc	upk_column	; flag we have seen a digit
    431  1ad7		       4c a2 f2 	      jmp	Get2
    432  1ada
    433  1ada		       c9 7c	   notDigit   cmp	#"|"	; newline
    434  1adc		       d0 11		      bne	checkWall
    435  1ade
    436  1ade							; Handle new-line
    437  1ade		       a9 00		      lda	#0
    438  1ae0		       85 8a		      sta	POS_X
    439  1ae2		       e6 8b		      inc	POS_Y
    440  1ae4
    441  1ae4
    442  1ae4		       a5 8b		      lda	POS_Y
    443  1ae6		       c5 95		      cmp	BoardLimit_Height
    444  1ae8		       90 02		      bcc	wOK2
    445  1aea		       85 95		      sta	BoardLimit_Height	;???^^^
    446  1aec				   wOK2
    447  1aec
    448  1aec		       4c 9a f2 	      jmp	GetNextItem
    449  1aef
    450  1aef		       c9 23	   checkWall  cmp	#"#"	; wall
    451  1af1		       d0 09		      bne	checkForGap
    452  1af3		       a5 b4		      lda	levelX
    453  1af5		       29 01		      and	#1
    454  1af7		       18		      clc
    455  1af8		       69 06		      adc	#CHARACTER_STEEL
    456  1afa		       d0 66		      bne	WriteChars
    457  1afc
    458  1afc		       c9 20	   checkForGap cmp	#32
    459  1afe		       f0 08		      beq	writeGap
    460  1b00		       c9 2d		      cmp	#"-"
    461  1b02		       f0 04		      beq	writeGap
    462  1b04		       c9 5f		      cmp	#"_"
    463  1b06		       d0 05		      bne	checkForMan
    464  1b08
    465  1b08		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    466  1b0a		       4c 62 f3 	      jmp	WriteChars
    467  1b0d
    468  1b0d				   checkForMan
    469  1b0d		       c9 2b		      cmp	#"+"	; player on goal square
    470  1b0f		       d0 07		      bne	notPlayerGoal
    471  1b11
    472  1b11		       20 07 f2 	      jsr	RegisterOneMoreTarget
    473  1b14
    474  1b14							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    475  1b14
    476  1b14		       a9 03		      lda	#CHARACTER_TARGET
    477  1b16		       d0 06		      bne	genPlayer
    478  1b18
    479  1b18				   notPlayerGoal
    480  1b18		       c9 40		      cmp	#"@"	; player on normal square
    481  1b1a		       d0 2d		      bne	checkBox
    482  1b1c
    483  1b1c		       a9 00		      lda	#CHARACTER_BLANK
    484  1b1e
    485  1b1e				   genPlayer
    486  1b1e
    487  1b1e		       85 8f		      sta	POS_VAR	; character man is on
    488  1b20
    489  1b20		       18		      clc
    490  1b21		       a5 8a		      lda	POS_X
    491  1b23		       48		      pha
    492  1b24		       65 da		      adc	base_x
    493  1b26		       85 8a		      sta	POS_X
    494  1b28		       85 9b		      sta	ManX
    495  1b2a
    496  1b2a		       a5 8b		      lda	POS_Y
    497  1b2c		       48		      pha
    498  1b2d		       65 db		      adc	base_y
    499  1b2f		       85 8b		      sta	POS_Y
    500  1b31		       85 9c		      sta	ManY
    501  1b33
    502  1b33							; POS_X     x position
    503  1b33							; POS_Y     y position
    504  1b33							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    505  1b33							; POS_Type  type of object
    506  1b33
    507  1b33		       a9 00		      lda	#TYPE_MAN
    508  1b35		       85 8e		      sta	POS_Type	;	 creature TYPE
    509  1b37		       20 21 f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    510  1b3a
    511  1b3a		       a9 00		      lda	#0
    512  1b3c		       85 9a		      sta	manAnimationIndex
    513  1b3e
    514  1b3e		       68		      pla
    515  1b3f		       85 8b		      sta	POS_Y
    516  1b41		       68		      pla
    517  1b42		       85 8a		      sta	POS_X
    518  1b44
    519  1b44		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    520  1b46		       4c 62 f3 	      jmp	WriteChars
    521  1b49
    522  1b49		       c9 24	   checkBox   cmp	#"$"
    523  1b4b		       d0 04		      bne	checkBoxTarget
    524  1b4d
    525  1b4d		       a9 02		      lda	#CHARACTER_BOX
    526  1b4f		       d0 11		      bne	WriteChars
    527  1b51
    528  1b51		       c9 2a	   checkBoxTarget cmp	#"*"
    529  1b53		       d0 04		      bne	checkTarget
    530  1b55
    531  1b55		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    532  1b57		       d0 09		      bne	WriteChars
    533  1b59
    534  1b59		       c9 2e	   checkTarget cmp	#"."
    535  1b5b		       f0 03		      beq	targ
    536  1b5d		       4c 9a f2 	      jmp	GetNextItem
    537  1b60				   targ
    538  1b60
    539  1b60		       a9 03		      lda	#CHARACTER_TARGET
    540  1b62
    541  1b62		       85 8e	   WriteChars sta	POS_Type
    542  1b64
    543  1b64		       18	   Wc2x       clc
    544  1b65		       a5 8a		      lda	POS_X
    545  1b67		       48		      pha
    546  1b68		       65 da		      adc	base_x
    547  1b6a		       85 8a		      sta	POS_X
    548  1b6c
    549  1b6c		       a5 8b		      lda	POS_Y
    550  1b6e		       48		      pha
    551  1b6f		       65 db		      adc	base_y
    552  1b71		       85 8b		      sta	POS_Y
    553  1b73
    554  1b73		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    555  1b76
    556  1b76		       a5 8e		      lda	POS_Type
    557  1b78		       c9 03		      cmp	#CHARACTER_TARGET
    558  1b7a		       d0 03		      bne	notargdet
    559  1b7c		       20 07 f2 	      jsr	RegisterOneMoreTarget
    560  1b7f				   notargdet
    561  1b7f
    562  1b7f		       68		      pla
    563  1b80		       85 8b		      sta	POS_Y
    564  1b82		       68		      pla
    565  1b83		       85 8a		      sta	POS_X
    566  1b85
    567  1b85		       18		      clc
    568  1b86		       69 01		      adc	#1
    569  1b88		       85 8a		      sta	POS_X
    570  1b8a
    571  1b8a		       c5 94		      cmp	BoardLimit_Width
    572  1b8c		       90 02		      bcc	wOK
    573  1b8e		       85 94		      sta	BoardLimit_Width
    574  1b90				   wOK
    575  1b90
    576  1b90		       c6 dc		      dec	upk_length
    577  1b92		       d0 d0		      bne	Wc2x
    578  1b94		       4c 9a f2 	      jmp	GetNextItem
    579  1b97
    580  1b97				   finishedUnpack
    581  1b97
    582  1b97		       60		      rts
    583  1b97					      endif
------- FILE BANK_GENERIC.asm
     44  1b98
      0  1b98					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1b98
      2  1b98
      3  1b98		       03 98	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $398 , FREE= $68
      4  1b98					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1b98				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1b98				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1b98				  -	      ERR
      8  1b98					      endif
     46  1b98
     47  1b98							;------------------------------------------------------------------------------
     48  1b98							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1b98							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1b98							; bank finishes.  Just continue on from where it left off...
     51  1b98							;------------------------------------------------------------------------------
     52  1b98
      0  1b98					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1b98		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1b98					      SUBROUTINE
      3  1b98				   Cart_Init
     54  1b98
     55  1b98							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1b98							; at any time.  So they need to be used immediately.
     57  1b98
     58  1b98
     59  1b98							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1b98
     61  1b98		       a9 01		      lda	#1
     62  1b9a		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1b9c		       a0 00		      ldy	#0	;sJoysticks
     64  1b9e		       84 a9		      sty	jtoggle
     65  1ba0		       86 b5		      stx	level
     66  1ba2		       85 a7		      sta	ManCount	; = #players
     67  1ba4		       a9 00		      lda	#0
     68  1ba6		       85 b4		      sta	levelX	; make an immediate copy to safe variables!
     69  1ba8		       85 e0		      sta	startingLevel
     70  1baa
     71  1baa							; multiply with LEVEL_DEFINITION_SIZE (5):
     72  1baa		       0a		      asl
     73  1bab		       0a		      asl
     74  1bac		       85 b4		      sta	levelX
     75  1bae
     76  1bae		       a9 01		      lda	#1
     77  1bb0		       85 99		      sta	whichPlayer	; will switch to 0 on 1st go
     78  1bb2
     79  1bb2		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     80  1bb4		       a6 a7		      ldx	ManCount	; = sPlayers
     81  1bb6		       f0 02		      beq	opg
     82  1bb8		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     83  1bba		       85 a7	   opg	      sta	ManCount	; P2P1 nybble each
     84  1bbc
     85  1bbc							;---------------------------------------------------------------------------
     86  1bbc
     87  1bbc		       a9 00		      lda	#0
     88  1bbe		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     89  1bc1		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     90  1bc4		       85 6b		      sta	HMCLR
     91  1bc6
     92  1bc6							; cleanup remains of title screen
     93  1bc6		       85 5b		      sta	GRP0
     94  1bc8		       85 5c		      sta	GRP1
     95  1bca		       85 5b		      sta	GRP0
     96  1bcc
     97  1bcc		       85 89		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     98  1bce		       85 aa		      sta	circle_d
     99  1bd0		       85 ab		      sta	circle_d+1
    100  1bd2
    101  1bd2							;    IFCONST DEBUG_CREATURE
    102  1bd2							;		  sta worstTime
    103  1bd2							;    ENDIF
    104  1bd2
    105  1bd2		       a9 04		      lda	#%100	; players/missiles BEHIND BG
    106  1bd4		       85 4a		      sta	CTRLPF
    107  1bd6		       85 82		      sta	rnd	; anything non-0
    108  1bd8
    109  1bd8		       a9 ff		      lda	#$FF
    110  1bda		       85 84		      sta	DrawStackPointer
    111  1bdc		       85 92		      sta	BufferedButton
    112  1bde		       85 93		      sta	BufferedButton+1
    113  1be0
    114  1be0		       a9 07		      lda	#DIRECTION_BITS
    115  1be2		       85 a4		      sta	ManLastDirection
    116  1be4
    117  1be4		       a9 00		      lda	#0
    118  1be6							;		  sta ObjStackPtr		  ; object stack index of last entry
    119  1be6							;		  sta ObjStackPtr+1
    120  1be6							;		  sta ObjStackNum
    121  1be6							;		  sta ObjIterator
    122  1be6
    123  1be6		       85 cc		      sta	sortPtr
    124  1be8		       a9 ff		      lda	#<(-1)
    125  1bea		       85 cb		      sta	sortRequired
    126  1bec
    127  1bec							; read high score from SaveKey and store in highScoreSK,
    128  1bec							; which is transferred to high score variable in RAM by GeneralScoringSetups
    129  1bec		       4c 5c f6 	      jmp	ReadSaveKey
    130  1bef
    131  1bef							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    132  1bef							;		  .byte -1
    133  1bef
    134  1bef							;------------------------------------------------------------------------------
    135  1bef
      0  1bef					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1bef		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1bef					      SUBROUTINE
      3  1bef				   SwapPlayersGeneric
    137  1bef
    138  1bef							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    139  1bef							; into the gameMode variable.
    140  1bef
    141  1bef		       a5 80		      lda	gameMode
    142  1bf1		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    143  1bf3		       85 80		      sta	gameMode
    144  1bf5		       ad 82 02 	      lda	SWCHB
    145  1bf8		       29 08		      and	#BW_SWITCH
    146  1bfa		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    147  1bfc		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    148  1bfe
    149  1bfe
    150  1bfe							; restart level
    151  1bfe		       a5 ca		      lda	NextLevelTrigger
    152  1c00		       29 bf		      and	#<(~BIT_NEXTLIFE)
    153  1c02		       85 ca		      sta	NextLevelTrigger
    154  1c04
    155  1c04							; if new high score was set by SwapPlayers, update it:
    156  1c04
    157  1c04		       4c 82 f6 	      jmp	WriteSaveKey
    158  1c07
    159  1c07
    160  1c07							;------------------------------------------------------------------------------
    161  1c07
      0  1c07					      DEFINE_SUBROUTINE	CreateCreatures
      1  1c07		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1c07					      SUBROUTINE
      3  1c07				   CreateCreatures
    163  1c07
    164  1c07							; Calculate rightmost value for scrolling edge.  .
    165  1c07
    166  1c07		       85 c4		      sta	ROM_Bank
    167  1c09
    168  1c09		       38		      sec
    169  1c0a		       a5 94		      lda	BoardLimit_Width
    170  1c0c		       e9 09		      sbc	#SCREEN_WIDTH-1
    171  1c0e		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    172  1c10
    173  1c10							;		  sec			     already set
    174  1c10		       a5 95		      lda	BoardLimit_Height
    175  1c12		       e9 07		      sbc	#SCREEN_LINES-1
    176  1c14		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    177  1c16
    178  1c16							; kludge position scroll roughly at player
    179  1c16
    180  1c16							;		  sec			 already set
    181  1c16		       a5 9b		      lda	ManX
    182  1c18		       e9 05		      sbc	#5
    183  1c1a		       b0 02		      bcs	notL0
    184  1c1c		       a9 00		      lda	#0
    185  1c1e		       85 97	   notL0      sta	BoardScrollX
    186  1c20
    187  1c20
    188  1c20		       38		      sec
    189  1c21		       a5 9c		      lda	ManY
    190  1c23		       e9 03		      sbc	#3	; TJ: why 5???
    191  1c25		       b0 02		      bcs	notU0
    192  1c27		       a9 00		      lda	#0
    193  1c29		       85 96	   notU0      sta	BoardScrollY
    194  1c2b
    195  1c2b		       a9 00		      lda	#0
    196  1c2d		       85 9f		      sta	ManMode
    197  1c2f		       85 a0		      sta	ManDelayCount
    198  1c31
    199  1c31		       a9 1a		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    200  1c33		       85 a1		      sta	ManAnimation
    201  1c35							;lda #>AnimateBLANK ;
    202  1c35							;sta ManAnimation+1
    203  1c35
    204  1c35		       a9 ff		      lda	#$FF
    205  1c37		       85 b1		      sta	LastSpriteY
    206  1c39
    207  1c39		       a9 07		      lda	#DIRECTION_BITS
    208  1c3b		       85 a4		      sta	ManLastDirection
    209  1c3d		       60		      rts
    210  1c3e
    211  1c3e							;-------------------------------------------------------------------------------------
    212  1c3e
      0  1c3e					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1c3e		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1c3e					      SUBROUTINE
      3  1c3e				   LevelInit
    214  1c3e
    215  1c3e		       a9 00		      lda	#0
    216  1c40		       85 86		      sta	ObjStackPtr
    217  1c42		       85 87		      sta	ObjStackPtr+1	; kill all creatures
    218  1c44		       85 85		      sta	ObjStackNum
    219  1c46		       85 cd		      sta	ObjIterator
    220  1c48
    221  1c48		       85 98		      sta	scrollBits
    222  1c4a		       85 89		      sta	ScreenDrawPhase
    223  1c4c
    224  1c4c		       85 b3		      sta	BGColour
    225  1c4e		       85 c6		      sta	ColourTimer
    226  1c50
    227  1c50		       85 59		      sta	AUDV0
    228  1c52		       85 5a		      sta	AUDV1	; turn off music while levels init
    229  1c54							;		  sta AUDC0
    230  1c54
    231  1c54		       85 a4		      sta	ManLastDirection
    232  1c56		       85 a5		      sta	ManPushCounter
    233  1c58
    234  1c58		       85 cc		      sta	sortPtr	; sort stopped
    235  1c5a		       a9 ff		      lda	#<(-1)
    236  1c5c		       85 cb		      sta	sortRequired	; nothing needed
    237  1c5e		       85 84		      sta	DrawStackPointer
    238  1c60
    239  1c60		       a9 00		      lda	#DISPLAY_TIME	;DISPLAY_SCORE
    240  1c62		       85 c9		      sta	scoringFlags
    241  1c64		       a9 00		      lda	#0	;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    242  1c66		       85 c8		      sta	scoringTimer
    243  1c68		       60		      rts
    244  1c69
    245  1c69							;-------------------------------------------------------------------------------------
    246  1c69
      0  1c69					      DEFINE_SUBROUTINE	Resync
      1  1c69		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1c69					      SUBROUTINE
      3  1c69				   Resync
      0  1c69					      RESYNC
      1  1c69
      2  1c69		       a9 02		      lda	#%10
      3  1c6b		       85 41		      sta	VBLANK
      4  1c6d
      5  1c6d		       a2 08		      ldx	#8
      6  1c6f				   .loopResync
      0  1c6f					      VERTICAL_SYNC
      1  1c6f		       a9 0e		      lda	#%1110
      2  1c71		       85 42	   .VSLP1     sta	WSYNC
      3  1c73		       85 40		      sta	VSYNC
      4  1c75		       4a		      lsr
      5  1c76		       d0 f9		      bne	.VSLP1
      8  1c78
      9  1c78		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1c7a		       a5 81		      lda	Platform
     11  1c7c		       49 02		      eor	#PAL_50
     12  1c7e		       d0 02		      bne	.ntsc
     13  1c80		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1c82				   .ntsc
     15  1c82				   .loopWait
     16  1c82		       85 42		      sta	WSYNC
     17  1c84		       85 42		      sta	WSYNC
     18  1c86		       88		      dey
     19  1c87		       d0 f9		      bne	.loopWait
     20  1c89		       ca		      dex
     21  1c8a		       d0 e3		      bne	.loopResync
    249  1c8c		       60	   Ret	      rts
    250  1c8d
    251  1c8d							;---------------------------------------------------------------------------
    252  1c8d
      0  1c8d					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1c8d		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1c8d					      SUBROUTINE
      3  1c8d				   TrackPlayer
    254  1c8d
    255  1c8d		       a5 a6		      lda	LookingAround	; 3
    256  1c8f		       d0 fb		      bne	Ret	; 2/3=5/6   don't track when looking around
    257  1c91
    258  1c91							; Contribution by Thomas Jentzsch
    259  1c91
    260  1c91							; scrolling constants:
    261  1c91		       00 03	   .SCRL_START_LEFT =	3	; 3
    262  1c91		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    263  1c91		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    264  1c91		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    265  1c91		       00 11	   .SCRL_LEFT_BIT =	%00010001
    266  1c91		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    267  1c91		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    268  1c91
    269  1c91		       00 02	   .SCRL_START_UP =	2	; 2
    270  1c91		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    271  1c91		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    272  1c91		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    273  1c91		       00 44	   .SCRL_UP_BIT =	%01000100
    274  1c91		       00 88	   .SCRL_DOWN_BIT =	%10001000
    275  1c91		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    276  1c91
    277  1c91							; *** horizontal scrolling (unoptimized version): ***
    278  1c91
    279  1c91							; check for enabling horizontal scrolling:
    280  1c91		       a5 9b		      lda	ManX	; 3
    281  1c93		       38		      sec		; 2
    282  1c94		       e5 97		      sbc	BoardScrollX	; 3
    283  1c96		       a8		      tay		; 2	     for later use
    284  1c97		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    285  1c99		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    286  1c9b		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    287  1c9d		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    288  1c9f		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    289  1ca1		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    290  1ca3				   .startXScroll
    291  1ca3		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    292  1ca5		       05 98		      ora	scrollBits	; 3
    293  1ca7		       85 98		      sta	scrollBits	; 3 =	8
    294  1ca9				   .skipStartXScroll
    295  1ca9
    296  1ca9							; do horizontal scrolling:
    297  1ca9		       a5 98		      lda	scrollBits	; 3
    298  1cab		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    299  1cad		       f0 23		      beq	.skipXScroll	; 2/3
    300  1caf		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    301  1cb1		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    302  1cb3
    303  1cb3							; scroll left:
    304  1cb3		       a5 97		      lda	BoardScrollX	; 3	     already at left edge?
    305  1cb5		       f0 15		      beq	.stopXScroll	; 2
    306  1cb7		       c6 97		      dec	BoardScrollX	; 5
    307  1cb9		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    308  1cbb		       10 0f		      bpl	.stopXScroll	; 2/3=15
    309  1cbd		       30 13		      bmi	.skipXScroll	; 3
    310  1cbf							;---------------------------------------
    311  1cbf				   .xScrollRight
    312  1cbf		       a6 97		      ldx	BoardScrollX	; 3
    313  1cc1		       e8		      inx		; 2
    314  1cc2		       e4 94		      cpx	BoardEdge_Right	; 3	     already at right edge?
    315  1cc4		       10 06		      bpl	.stopXScroll	; 2/3
    316  1cc6		       86 97		      stx	BoardScrollX	; 3
    317  1cc8		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    318  1cca		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    319  1ccc				   .stopXScroll
    320  1ccc		       a5 98		      lda	scrollBits	; 3
    321  1cce		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    322  1cd0		       85 98		      sta	scrollBits	; 3 =	8
    323  1cd2				   .skipXScroll
    324  1cd2							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    325  1cd2
    326  1cd2							; *** vertical scrolling (unoptimized version): ***
    327  1cd2
    328  1cd2							; check for enabling vertical scrolling:
    329  1cd2		       a5 9c		      lda	ManY	; 3
    330  1cd4		       38		      sec		; 2
    331  1cd5		       e5 96		      sbc	BoardScrollY	; 3
    332  1cd7		       a8		      tay		; 2	     for later use
    333  1cd8		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    334  1cda		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    335  1cdc		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    336  1cde		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    337  1ce0		       30 08		      bmi	.skipStartYScroll	; 2/3
    338  1ce2		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    339  1ce4				   .startYScroll
    340  1ce4		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    341  1ce6		       05 98		      ora	scrollBits	; 3
    342  1ce8		       85 98		      sta	scrollBits	; 3 =	8
    343  1cea				   .skipStartYScroll
    344  1cea
    345  1cea							; do vertical scrolling:
    346  1cea		       a5 98		      lda	scrollBits	; 3
    347  1cec		       29 cc		      and	#.SCRL_Y_BITS	; 2
    348  1cee		       f0 23		      beq	.skipYScroll	; 2/3
    349  1cf0		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    350  1cf2		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    351  1cf4
    352  1cf4							; scroll up
    353  1cf4		       a5 96		      lda	BoardScrollY	; 3
    354  1cf6		       f0 15		      beq	.stopYScroll	; 2
    355  1cf8		       c6 96		      dec	BoardScrollY	; 5
    356  1cfa		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    357  1cfc		       10 0f		      bpl	.stopYScroll	; 2/3=15
    358  1cfe		       30 13		      bmi	.skipYScroll	; 3
    359  1d00							;---------------------------------------
    360  1d00				   .yScrollDown
    361  1d00		       a6 96		      ldx	BoardScrollY	; 3
    362  1d02		       e8		      inx		; 2
    363  1d03		       e4 95		      cpx	BoardEdge_Bottom	;     ; 3
    364  1d05		       10 06		      bpl	.stopYScroll	; 2/3
    365  1d07		       86 96		      stx	BoardScrollY	; 3
    366  1d09		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    367  1d0b		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    368  1d0d				   .stopYScroll
    369  1d0d		       a5 98		      lda	scrollBits	; 3
    370  1d0f		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    371  1d11		       85 98		      sta	scrollBits	; 3 =	8
    372  1d13				   .skipYScroll
    373  1d13							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    374  1d13
    375  1d13		       60	   EarlyAbortx rts		; 6 =	6
    376  1d14							; total: 5+67*2+6 = 145
    377  1d14
    378  1d14							;------------------------------------------------------------------------------
    379  1d14
    380  1d14
    381  1d14
    382  1d14							; worst case time from positive last check to rts: 123
    383  1d14							; cycles until 0-check: 15
    384  1d14							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    385  1d14							; MINIMUM_SORT_TIME = 3 = 129
    386  1d14							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    387  1d14
    388  1d14							;------------------------------------------------------------------------------
    389  1d14
    390  1d14							; This is a GOOD home for these tables.
    391  1d14
      0  1d14					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1d14		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1d14					      SUBROUTINE
      3  1d14				   TS_PhaseVectorLO
    393  1d14
    394  1d14							; Gives LO byte of addresses of subroutines for timeslice processing
    395  1d14
    396  1d14		       50		      .byte.b	<ProcessObjStack
    397  1d15		       a4		      .byte.b	<DrawFullScreen
    398  1d16		       86		      .byte.b	<BuildDrawStack
    399  1d17		       8d		      .byte.b	<DrawAIntoStack
    400  1d18		       93		      .byte.b	<SwitchObjects
    401  1d19
    402  1d19				   TS_PhaseVectorHI
    403  1d19
    404  1d19							; Gives HI byte of addresses of subroutines for timeslice processing
    405  1d19
    406  1d19		       f8		      .byte.b	>ProcessObjStack
    407  1d1a		       f2		      .byte.b	>DrawFullScreen
    408  1d1b		       fa		      .byte.b	>BuildDrawStack
    409  1d1c		       fa		      .byte.b	>DrawAIntoStack
    410  1d1d		       f8		      .byte.b	>SwitchObjects
    411  1d1e
    412  1d1e				   TS_PhaseBank
    413  1d1e
    414  1d1e							; Gives bank of subroutines for timeslice processing
    415  1d1e
    416  1d1e		       0f		      .byte.b	BANK_ProcessObjStack
    417  1d1f		       0b		      .byte.b	BANK_DrawFullScreen
    418  1d20		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    419  1d21		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    420  1d22		       0f		      .byte.b	BANK_SwitchObjects
    421  1d23
    422  1d23							;------------------------------------------------------------------------------
    423  1d23		       02 02	   lookColour2 .byte.b	$02, $02
    424  1d25		       04 04		      .byte.b	$04, $04
    425  1d27
    426  1d27				   OverscanTime
    427  1d27		       3c 3c		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    428  1d29		       43 3c		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    429  1d2b
    430  1d2b		       c0 c0 50 50 FlashColour .byte.b	$C0, $C0, $50, $50
    431  1d2f
    432  1d2f
      0  1d2f					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1d2f		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1d2f					      SUBROUTINE
      3  1d2f				   PostScreenCleanup
    434  1d2f
    435  1d2f		       c8		      iny		; --> 0
    436  1d30
    437  1d30		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    438  1d32							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    439  1d32
    440  1d32		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    441  1d34							; TJ: no idea why, but you had removed it in revision 758 ;)
    442  1d34							; completely accidental -- one of our cats may have deleted it.
    443  1d34		       84 4e		      sty	PF1
    444  1d36		       84 4f		      sty	PF2
    445  1d38		       84 5d		      sty	ENAM0
    446  1d3a		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    447  1d3c		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    448  1d3e
    449  1d3e							; D1 VBLANK turns off beam
    450  1d3e
    451  1d3e		       a9 42		      lda	#%01000010	; bit6 is not required
    452  1d40		       85 41		      sta	VBLANK	; end of screen - enter blanking
    453  1d42
    454  1d42							;------------------------------------------------------------------------------
    455  1d42							; This is where the PAL system has a bit of extra time on a per-frame basis.
    456  1d42
    457  1d42		       a6 81		      ldx	Platform
    458  1d44		       bd 27 f5 	      lda	OverscanTime,x
    459  1d47		       8d 96 02 	      sta	TIM64T
    460  1d4a
    461  1d4a							; Background colour priorities. Increasing order of priority...
    462  1d4a							;	black -- nothing happening
    463  1d4a							;	looking around			     lookingAround<0		     BLUE
    464  1d4a							;	when paused			     gameMode... BIT7		     RED
    465  1d4a							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    466  1d4a
    467  1d4a
    468  1d4a							;		  lda LookingAround
    469  1d4a							;		  bpl nolooker			  ; if not looking around, that will do nicely
    470  1d4a							;		  ldy #0 ;sok
    471  1d4a							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    472  1d4a							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    473  1d4a
    474  1d4a		       a5 b8		      lda	ThrottleSpeed
    475  1d4c		       18		      clc
    476  1d4d		       65 b7		      adc	Throttle
    477  1d4f		       b0 02		      bcs	noVerflo
    478  1d51		       85 b7		      sta	Throttle
    479  1d53				   noVerflo
    480  1d53
    481  1d53
    482  1d53							;----------------------------------------------------------------------------------------------
    483  1d53							; handle pause button for 2600 and 7800
    484  1d53
    485  1d53							; Timings:  NOT including palette setting or platform detect
    486  1d53							; 2600:     no button press:	 11 cycles
    487  1d53							;	     with button press:  21 cycles
    488  1d53							; 7800      no button press:	 16 cycles
    489  1d53							;	     with button press:  21 cycles
    490  1d53
    491  1d53
    492  1d53
    493  1d53		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    494  1d53
    495  1d53		       24 80		      bit	gameMode
    496  1d55		       50 0b		      bvc	.pause7800	; 7800 platform
    497  1d57
    498  1d57							; 2600 pause logic...
    499  1d57
    500  1d57		       ad 82 02 	      lda	SWCHB
    501  1d5a		       45 80		      eor	gameMode
    502  1d5c		       29 08		      and	#BW_SWITCH
    503  1d5e		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    504  1d60		       d0 0f		      bne	.buttonDown	; unconditional
    505  1d62
    506  1d62							; 7800 pause logic...
    507  1d62
    508  1d62							; When the button is pressed, we check if it's the FIRST time it's pressed.
    509  1d62							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    510  1d62							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    511  1d62							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    512  1d62							; is next pressed.
    513  1d62
    514  1d62		       a9 08	   .pause7800 lda	#BW_SWITCH
    515  1d64		       2c 82 02 	      bit	SWCHB
    516  1d67		       f0 04		      beq	.pausePress
    517  1d69		       05 80		      ora	gameMode	; not pressed, so enable first time press
    518  1d6b		       d0 08		      bne	.fixPause	; unconditional
    519  1d6d
    520  1d6d		       24 80	   .pausePress bit	gameMode
    521  1d6f		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    522  1d71
    523  1d71							; Button is down, and we have detected it as a FIRST-TIME button press.
    524  1d71
    525  1d71		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    526  1d73		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    527  1d75		       85 80	   .fixPause  sta	gameMode
    528  1d77
    529  1d77		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    530  1d79		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    531  1d7b
    532  1d7b		       a6 81		      ldx	Platform
    533  1d7d		       bd ed f5 	      lda	pscol,x
    534  1d80		       85 b3		      sta	BGColour	; set main screen background colour.  RED is paused.
    535  1d82
    536  1d82				   .exitPause
    537  1d82
    538  1d82							;----------------------------------------------------------------------------------------------
    539  1d82
    540  1d82							; has to be done AFTER screen display, because it disables the effect!
    541  1d82		       a5 82		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    542  1d84		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    543  1d86
    544  1d86							; "Flash" has highest BG colour priority
    545  1d86
    546  1d86		       a5 c6		      lda	ColourTimer
    547  1d88		       f0 07		      beq	noFlashBG
    548  1d8a		       c6 c6		      dec	ColourTimer
    549  1d8c		       a6 81		      ldx	Platform
    550  1d8e		       bd 2b f5 	      lda	FlashColour,x
    551  1d91		       85 b3	   noFlashBG  sta	BGColour
    552  1d93
    553  1d93							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    554  1d93							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    555  1d93
    556  1d93		       a5 90		      lda	BufferedJoystick	; previous frame
    557  1d95		       85 91		      sta	BufferedJoystick+1	; -> buffered
    558  1d97
    559  1d97
    560  1d97							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    561  1d97							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    562  1d97
    563  1d97		       a5 99		      lda	whichPlayer	; 3
    564  1d99		       25 a9		      and	jtoggle	; 3
    565  1d9b		       aa		      tax		; 2
    566  1d9c
    567  1d9c		       b5 4c		      lda	INPT4,x	; 4
    568  1d9e		       25 92		      and	BufferedButton
    569  1da0		       85 92		      sta	BufferedButton	; 3 = 15
    570  1da2
    571  1da2		       ad 80 02 	      lda	SWCHA	; 4
    572  1da5
    573  1da5		       ca		      dex		; 2
    574  1da6		       30 04		      bmi	notP2	; 2/3= 8/9
    575  1da8
    576  1da8		       0a		      asl		; 2
    577  1da9		       0a		      asl		; 2
    578  1daa		       0a		      asl		; 2
    579  1dab		       0a		      asl		; 2 =	8
    580  1dac		       85 90	   notP2      sta	BufferedJoystick	; 3
    581  1dae
    582  1dae
    583  1dae							; "Scoring timer" reset stomp comment
    584  1dae
    585  1dae		       a5 c8		      lda	scoringTimer
    586  1db0		       f0 0a		      beq	timer0now
    587  1db2		       c6 c8		      dec	scoringTimer
    588  1db4		       d0 06		      bne	timer0now
    589  1db6		       a5 c9		      lda	scoringFlags
    590  1db8		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    591  1dba		       85 c9		      sta	scoringFlags
    592  1dbc				   timer0now
    593  1dbc
    594  1dbc							; fall through
    595  1dbc
    596  1dbc							;-------------------------------------------------------------------------------------
    597  1dbc							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    598  1dbc							; the player animation consists of running a small animation 'program', and then actually drawing
    599  1dbc							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    600  1dbc							; inside the actual draw kernel in the appropriate bank.
    601  1dbc
    602  1dbc
      0  1dbc					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  1dbc		       00 03	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  1dbc					      SUBROUTINE
      3  1dbc				   AnimatePlayers
    604  1dbc
    605  1dbc							; Optimised 7/1/2012 -- single page tables
    606  1dbc
    607  1dbc							; This interesting code performs the animations for the player(s) and sets the
    608  1dbc							; pointers INSIDE the row bank for the draw code to point to the correct player
    609  1dbc							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    610  1dbc
    611  1dbc
    612  1dbc							; Cycle the player through his animation list.  The animation of a player is a direct
    613  1dbc							; pointer to the actual shape used to display the player.  This shape is in turn
    614  1dbc							; written to the current bank's self-modifying locations for the draw.  Since
    615  1dbc							; we are effectively drawing from this current bank, the same code can be used
    616  1dbc							; to 'undraw' the player as required.
    617  1dbc
    618  1dbc
    619  1dbc							; x = player index
    620  1dbc							; sets ManAnimation = FRAME to display for player
    621  1dbc							; ManAnimation = index of player program into Manimate list
    622  1dbc
    623  1dbc		       24 80		      bit	gameMode
    624  1dbe		       30 2c		      bmi	AnimationOK	; don't animate during pause
    625  1dc0
    626  1dc0		       c6 a0		      dec	ManDelayCount
    627  1dc2		       10 28		      bpl	AnimationOK
    628  1dc4
    629  1dc4		       a4 a1	   ReloadAnimation ldy	ManAnimation
    630  1dc6		       b9 00 f7    ContinueAnim lda	Manimate,y	; delay count
    631  1dc9		       d0 07		      bne	NewFrameOK
    632  1dcb		       b9 01 f7 	      lda	Manimate+1,y
    633  1dce		       a8		      tay
    634  1dcf		       4c c6 f5 	      jmp	ContinueAnim
    635  1dd2
    636  1dd2		       10 0d	   NewFrameOK bpl	doDelay
    637  1dd4
    638  1dd4		       c8		      iny		; handle a REFLECT
    639  1dd5		       a5 a4		      lda	ManLastDirection
    640  1dd7		       29 f7		      and	#%11110111
    641  1dd9		       19 00 f7 	      ora	Manimate,y
    642  1ddc		       85 a4		      sta	ManLastDirection
    643  1dde
    644  1dde		       c8		      iny
    645  1ddf		       d0 e5		      bne	ContinueAnim
    646  1de1
    647  1de1		       85 a0	   doDelay    sta	ManDelayCount
    648  1de3
    649  1de3		       c8		      iny
    650  1de4		       b9 00 f7 	      lda	Manimate,y
    651  1de7		       85 a3		      sta	ManAnimationFrameLO
    652  1de9
    653  1de9		       c8		      iny
    654  1dea		       84 a1		      sty	ManAnimation
    655  1dec
    656  1dec		       60	   AnimationOK rts
    657  1ded
    658  1ded
    659  1ded
    660  1ded		       40 40	   pscol      .byte.b	$40, $40
    661  1def		       60 60		      .byte.b	$60, $60
    662  1df1
    663  1df1							;------------------------------------------------------------------------------
    664  1df1
------- FILE i2c_v2.2.inc LEVEL 3 PASS 4
      0  1df1					      include	"i2c_v2.2.inc"
      1  1df1							;
      2  1df1							; i2c_v2.2.inc
      3  1df1							;
      4  1df1							;
      5  1df1							; AtariVox EEPROM Driver
      6  1df1							;
      7  1df1							; By Alex Herbert, 2004
      8  1df1							;
      9  1df1							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1df1							;
     11  1df1
     12  1df1
     13  1df1							; I/O Constants
     14  1df1
     15  1df1		       00 04	   I2C_SDA_MASK equ	$04
     16  1df1		       00 08	   I2C_SCL_MASK equ	$08
     17  1df1
     18  1df1
     19  1df1							; Signalling Macros
     20  1df1
     21  1df1							;  MAC     I2C_SCL_0
     22  1df1							;    lda     #$00
     23  1df1							;    sta     SWCHA
     24  1df1							;  ENDM
     25  1df1
     26  1df1							;  MAC     I2C_SCL_1
     27  1df1							;    lda     #I2C_SCL_MASK
     28  1df1							;    sta     SWCHA
     29  1df1							;  ENDM
     30  1df1
     31  1df1							;  MAC     I2C_SDA_IN
     32  1df1							;    lda     #I2C_SCL_MASK
     33  1df1							;    sta     SWACNT
     34  1df1							;  ENDM
     35  1df1
     36  1df1							;  MAC     I2C_SDA_OUT
     37  1df1							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1df1							;    sta     SWACNT
     39  1df1							;  ENDM
     40  1df1
     41  1df1
     42  1df1					      MAC	i2c_start
     43  1df1							; I2C_SCL_1
     44  1df1					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1df1					      sta	SWCHA	; 4
     46  1df1							; I2C_SDA_OUT
     47  1df1					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1df1					      sta	SWACNT	; 4
     49  1df1							; total: 12 cycles
     50  1df1					      ENDM
     51  1df1
     52  1df1
     53  1df1					      MAC	i2c_txbit
     54  1df1							; I2C_SCL_0
     55  1df1					      lda	#%0011	; 2
     56  1df1					      sta	SWCHA	; 4
     57  1df1							; set bit
     58  1df1					      adc	#%1000	; 2
     59  1df1					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1df1							; I2C_SCL_1
     61  1df1					      lda	#I2C_SCL_MASK	; 2
     62  1df1					      sta	SWCHA	; 4
     63  1df1							; total: 18 cycles
     64  1df1					      ENDM
     65  1df1
     66  1df1
     67  1df1					      MAC	i2c_txnack
     68  1df1							; I2C_SCL_0
     69  1df1					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1df1					      sta	SWCHA	; 4
     71  1df1							; I2C_SDA_IN
     72  1df1					      lsr		; 2	     I2C_SCL_MASK
     73  1df1					      sta	SWACNT	; 4
     74  1df1							; I2C_SCL_1
     75  1df1					      nop		; 2	     required for timing!
     76  1df1					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1df1							; total: 18 cycles
     78  1df1					      ENDM
     79  1df1
     80  1df1
     81  1df1							; Subroutine Macros
     82  1df1
     83  1df1					      MAC	i2c_subs
     84  1df1
     85  1df1				   i2c_startread
     86  1df1							; use V to flag if previous byte needs ACK
     87  1df1					      ldy	#%10100001	; 2	     eeprom read command
     88  1df1					      .byte	$2c	; 2
     89  1df1				   i2c_startwrite
     90  1df1					      ldy	#%10100000	; 2	     eeprom write command
     91  1df1					      I2C_START		;12	     start signal (clears V flag)
     92  1df1					      tya		; 2 = 16
     93  1df1				   i2c_txbyte
     94  1df1					      eor	#$ff	; 2	     invert data byte
     95  1df1					      sec		; 2
     96  1df1					      rol		; 2 =	6    shift loop bit into a
     97  1df1				   i2c_txbyteloop
     98  1df1					      tay		; 2
     99  1df1					      I2C_TXBIT		;18	     transmit
    100  1df1					      tya		; 2
    101  1df1					      asl		; 2	     shift next bit into C
    102  1df1					      bne	i2c_txbyteloop	; 2= 26/27
    103  1df1
    104  1df1							; receive acknowledge bit
    105  1df1
    106  1df1					      beq	i2c_rxbit	;43 = 43
    107  1df1							; i2c_txbyte: 264 cycles
    108  1df1							;-------------------------------------------------------------------------------
    109  1df1
    110  1df1				   i2c_rxbyte
    111  1df1					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1df1					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1df1
    114  1df1				   i2c_rxskipack
    115  1df1					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1df1
    117  1df1					      lda	#1	; 2
    118  1df1				   i2c_rxbyteloop
    119  1df1					      tay		; 2 =	2
    120  1df1				   i2c_rxbit		;	     receive bit in C
    121  1df1					      I2C_TXNACK		;18 = 18
    122  1df1
    123  1df1					      lda	SWCHA	; 4
    124  1df1					      lsr		; 2
    125  1df1					      lsr		; 2
    126  1df1					      lsr		; 2 = 10    C = SDA
    127  1df1
    128  1df1					      tya		; 2
    129  1df1					      rol		; 2	     rotate into Y
    130  1df1					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1df1
    132  1df1							; received byte in A
    133  1df1					      rts		; 6 =	6
    134  1df1							; i2c_rxbit:  40 cycles
    135  1df1							; i2c_rxbyte: 310/333 cycles
    136  1df1							;-------------------------------------------------------------------------------
    137  1df1
    138  1df1				   i2c_stopread
    139  1df1					      bvc	i2c_stopwrite	; 2
    140  1df1					      ldy	#$80	; 2
    141  1df1					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1df1
    143  1df1				   i2c_stopwrite
    144  1df1					      jsr	i2c_txack	;30
    145  1df1
    146  1df1							; return port to input mode
    147  1df1					      lda	#0	; 2	     0
    148  1df1					      sta	SWACNT	; 4
    149  1df1					      rts		; 6 = 12
    150  1df1							; i2c_stopread:  45/92
    151  1df1							; i2c_stopwrite: 42
    152  1df1							;-------------------------------------------------------------------------------
    153  1df1
    154  1df1				   i2c_txack
    155  1df1							; I2C_SCL_0
    156  1df1					      lda	#0	; 2	     $00
    157  1df1					      sta	SWCHA	; 4
    158  1df1							; I2C_SDA_OUT
    159  1df1					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1df1					      sta	SWACNT	; 4
    161  1df1							; I2C_SCL_1
    162  1df1					      asl		; 2	     I2C_SCL_MASK
    163  1df1					      sta	SWCHA	; 4
    164  1df1
    165  1df1					      rts		; 6
    166  1df1							; total: 24 cycles
    167  1df1							;-------------------------------------------------------------------------------
    168  1df1
    169  1df1					      ENDM
    170  1df1
    171  1df1
    172  1df1
------- FILE BANK_GENERIC.asm
    666  1df1
      0  1df1					      i2c_subs
      1  1df1
      2  1df1				   i2c_startread
      3  1df1
      4  1df1		       a0 a1		      ldy	#%10100001
      5  1df3		       2c		      .byte.b	$2c
      6  1df4				   i2c_startwrite
      7  1df4		       a0 a0		      ldy	#%10100000
      0  1df6					      I2C_START
      1  1df6
      2  1df6		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1df8		       8d 80 02 	      sta	SWCHA
      4  1dfb
      5  1dfb		       4a		      lsr
      6  1dfc		       8d 81 02 	      sta	SWACNT
      7  1dff
      9  1dff		       98		      tya
     10  1e00				   i2c_txbyte
     11  1e00		       49 ff		      eor	#$ff
     12  1e02		       38		      sec
     13  1e03		       2a		      rol
     14  1e04				   i2c_txbyteloop
     15  1e04		       a8		      tay
      0  1e05					      I2C_TXBIT
      1  1e05
      2  1e05		       a9 03		      lda	#%0011
      3  1e07		       8d 80 02 	      sta	SWCHA
      4  1e0a
      5  1e0a		       69 08		      adc	#%1000
      6  1e0c		       8d 81 02 	      sta	SWACNT
      7  1e0f
      8  1e0f		       a9 08		      lda	#I2C_SCL_MASK
      9  1e11		       8d 80 02 	      sta	SWCHA
     10  1e14
     17  1e14		       98		      tya
     18  1e15		       0a		      asl
     19  1e16		       d0 ec		      bne	i2c_txbyteloop
     20  1e18
     21  1e18
     22  1e18
     23  1e18		       f0 0b		      beq	i2c_rxbit
     24  1e1a
     25  1e1a
     26  1e1a
     27  1e1a				   i2c_rxbyte
     28  1e1a		       50 03		      bvc	i2c_rxskipack
     29  1e1c		       20 4d f6 	      jsr	i2c_txack
     30  1e1f
     31  1e1f				   i2c_rxskipack
     32  1e1f		       2c 1a f6 	      bit	i2c_rxbyte
     33  1e22
     34  1e22		       a9 01		      lda	#1
     35  1e24				   i2c_rxbyteloop
     36  1e24		       a8		      tay
     37  1e25				   i2c_rxbit
      0  1e25					      I2C_TXNACK
      1  1e25
      2  1e25		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1e27		       8d 80 02 	      sta	SWCHA
      4  1e2a
      5  1e2a		       4a		      lsr
      6  1e2b		       8d 81 02 	      sta	SWACNT
      7  1e2e
      8  1e2e		       ea		      nop
      9  1e2f		       8d 80 02 	      sta	SWCHA
     10  1e32
     39  1e32
     40  1e32		       ad 80 02 	      lda	SWCHA
     41  1e35		       4a		      lsr
     42  1e36		       4a		      lsr
     43  1e37		       4a		      lsr
     44  1e38
     45  1e38		       98		      tya
     46  1e39		       2a		      rol
     47  1e3a		       90 e8		      bcc	i2c_rxbyteloop
     48  1e3c
     49  1e3c
     50  1e3c		       60		      rts
     51  1e3d
     52  1e3d
     53  1e3d
     54  1e3d
     55  1e3d				   i2c_stopread
     56  1e3d		       50 05		      bvc	i2c_stopwrite
     57  1e3f		       a0 80		      ldy	#$80
     58  1e41		       20 25 f6 	      jsr	i2c_rxbit
     59  1e44
     60  1e44				   i2c_stopwrite
     61  1e44		       20 4d f6 	      jsr	i2c_txack
     62  1e47
     63  1e47
     64  1e47		       a9 00		      lda	#0
     65  1e49		       8d 81 02 	      sta	SWACNT
     66  1e4c		       60		      rts
     67  1e4d
     68  1e4d
     69  1e4d
     70  1e4d
     71  1e4d				   i2c_txack
     72  1e4d
     73  1e4d		       a9 00		      lda	#0
     74  1e4f		       8d 80 02 	      sta	SWCHA
     75  1e52
     76  1e52		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1e54		       8d 81 02 	      sta	SWACNT
     78  1e57
     79  1e57		       0a		      asl
     80  1e58		       8d 80 02 	      sta	SWCHA
     81  1e5b
     82  1e5b		       60		      rts
     83  1e5c
     84  1e5c
     85  1e5c
    668  1e5c
    669  1e5c				   HandleSaveKey SUBROUTINE
    670  1e5c
    671  1e5c		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    672  1e5c
    673  1e5c							;------------------------------------------------------------------------------
      0  1e5c					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1e5c		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1e5c					      SUBROUTINE
      3  1e5c				   ReadSaveKey
    675  1e5c
    676  1e5c							; assume no SaveKey found:
    677  1e5c		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    678  1e5e		       85 df		      sta	highScoreSK+2	; 3
    679  1e60
    680  1e60							; setup SaveKey:
    681  1e60		       a5 e0		      lda	startingLevel	; 3	     load start levelX*5 and level
    682  1e62		       a6 b5		      ldx	level	; 3
    683  1e64		       20 9d f6 	      jsr	SetupSaveKey	;6+853
    684  1e67		       90 52		      bcc	NoSKfound	; 2/3
    685  1e69
    686  1e69							;    lda     #$34
    687  1e69							;    sta     COLUBK
    688  1e69
    689  1e69							; start read
    690  1e69		       20 44 f6 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    691  1e6c		       20 f1 f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    692  1e6f
    693  1e6f							; read high score:
    694  1e6f		       a2 02		      ldx	#3-1	; 2 = 1187
    695  1e71				   .loopRead
    696  1e71		       20 1a f6 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    697  1e74		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    698  1e76		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    699  1e78		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    700  1e7a				   .skipEmpty
    701  1e7a		       95 dd		      sta	highScoreSK,x	; 4
    702  1e7c		       ca		      dex		; 2
    703  1e7d		       10 f2		      bpl	.loopRead	; 2/3= 354
    704  1e7f
    705  1e7f							; stop read:
    706  1e7f		       4c 3d f6 	      jmp	i2c_stopread	;3+92=95    terminate read
    707  1e82
    708  1e82							;------------------------------------------------------------------------------
      0  1e82					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1e82		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1e82					      SUBROUTINE
      3  1e82				   WriteSaveKey
    710  1e82
    711  1e82							; check if new high score:
    712  1e82		       a6 dd		      ldx	highScoreSK	; 3
    713  1e84		       e8		      inx		; 2
    714  1e85		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    715  1e87
    716  1e87							; setup SaveKey:
    717  1e87		       a5 e0		      lda	startingLevel	; 3	     load start levelX*5 and level
    718  1e89		       a6 e1		      ldx	startLevel	; 3
    719  1e8b		       20 9d f6 	      jsr	SetupSaveKey	; 6+853
    720  1e8e		       90 2b		      bcc	NoSKfound	; 2/3
    721  1e90
    722  1e90							;    lda     #$64
    723  1e90							;    sta     COLUBK
    724  1e90
    725  1e90							; write high score:
    726  1e90		       a2 02		      ldx	#3-1	; 2 = 841
    727  1e92				   .loopWrite
    728  1e92		       b5 dd		      lda	highScoreSK,x	; 4
    729  1e94		       20 00 f6 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    730  1e97		       ca		      dex		; 2
    731  1e98		       10 f8		      bpl	.loopWrite	; 2/3= 837
    732  1e9a
    733  1e9a							; stop write:
    734  1e9a		       4c 44 f6 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    735  1e9d
    736  1e9d
    737  1e9d							;------------------------------------------------------------------------------
      0  1e9d					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1e9d		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1e9d					      SUBROUTINE
      3  1e9d				   SetupSaveKey
    739  1e9d
    740  1e9d							; calculate slot;
    741  1e9d							; a = levelX
    742  1e9d							; x = level (0..4)
    743  1e9d		       85 e2		      sta	offsetSK	; 3
    744  1e9f		       8a		      txa		; 2
    745  1ea0		       18		      clc		; 2
    746  1ea1		       65 e2		      adc	offsetSK	; 3
    747  1ea3		       85 e2		      sta	offsetSK	; 3
    748  1ea5		       0a		      asl		; 2	     multiply by 3
    749  1ea6		       65 e2		      adc	offsetSK	; 3
    750  1ea8		       69 00		      adc	#<SAVEKEY_ADR	; 2
    751  1eaa		       aa		      tax		; 2 = 22
    752  1eab							; detect SaveKey:
    753  1eab		       20 f4 f5 	      jsr	i2c_startwrite	;6+280
    754  1eae		       d0 0a		      bne	.exitSK	; 2/3
    755  1eb0
    756  1eb0							; setup address:
    757  1eb0		       b8		      clv		; 2
    758  1eb1		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    759  1eb3		       20 00 f6 	      jsr	i2c_txbyte	;6+264
    760  1eb6		       8a		      txa		; 2	     x = lower byte offset
    761  1eb7		       4c 00 f6 	      jmp	i2c_txbyte	;3+264      returns C==1
    762  1eba
    763  1eba				   .exitSK
    764  1eba		       18		      clc
    765  1ebb				   NoSKfound
    766  1ebb		       60		      rts
    767  1ebb					      ENDIF
    768  1ebc
    769  1f00		       00 00 00 00*	      align	256
    770  1f00
    771  1f00				   Manimate
    772  1f00				   AnimateSTAND
    773  1f00				   AnimateRIGHT
    774  1f00				   AnimateLEFT
    775  1f00				   AnimateUP
    776  1f00				   AnimateSTOPPED
    777  1f00		       7f		      .byte.b	127
    778  1f01		       d1		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    779  1f02							;.byte 10
    780  1f02							;.byte < PLAYER_BLINK
    781  1f02							;.byte 127
    782  1f02							;.byte < PLAYER_STAND
    783  1f02							;.byte 0
    784  1f02							;.word AnimateTAP
    785  1f02
    786  1f02				   AnimateTAP
    787  1f02							;.byte 128, %0 		  ; reflect off, always tap with left foot
    788  1f02							;.byte 8
    789  1f02							;.byte < PLAYER_TAP0
    790  1f02							;.byte 8
    791  1f02							;.byte < PLAYER_TAP1
    792  1f02							;.byte 8
    793  1f02							;.byte < PLAYER_TAP0
    794  1f02							;.byte 8
    795  1f02							;.byte < PLAYER_TAP1
    796  1f02							;.byte 8
    797  1f02							;.byte < PLAYER_TAP0
    798  1f02							;.byte 8
    799  1f02							;.byte < PLAYER_TAP1
    800  1f02		       00		      .byte.b	0
    801  1f03		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    802  1f04
    803  1f04							;AnimateRIGHT
    804  1f04		       80 00		      .byte.b	128, %0	; reflect off
    805  1f06		       05		      .byte.b	5
    806  1f07		       d1		      .byte.b	< PLAYER_RIGHT0
    807  1f08		       05		      .byte.b	5
    808  1f09		       e6		      .byte.b	< PLAYER_RIGHT1
    809  1f0a		       00		      .byte.b	0
    810  1f0b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    811  1f0c
    812  1f0c							;AnimateLEFT
    813  1f0c		       80 08		      .byte.b	128, %1000	; reflect ON
    814  1f0e		       05		      .byte.b	5
    815  1f0f		       d1		      .byte.b	< PLAYER_RIGHT0
    816  1f10		       05		      .byte.b	5
    817  1f11		       e6		      .byte.b	< PLAYER_RIGHT1
    818  1f12		       00		      .byte.b	0
    819  1f13		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    820  1f14
    821  1f14							;AnimateUP
    822  1f14							;    .byte 128, %0		   ; reflect off
    823  1f14							;    .byte 5
    824  1f14							;    .byte < PLAYER_TAP
    825  1f14							;    .byte 128, %1000
    826  1f14							;    .byte 5
    827  1f14							;    .byte < PLAYER_TAP
    828  1f14							;    .byte 0
    829  1f14							;    .word AnimateUP
    830  1f14
    831  1f14							;AnimateUP
    832  1f14		       05		      .byte.b	5
    833  1f15		       d1		      .byte.b	< PLAYER_RIGHT0
    834  1f16		       05		      .byte.b	5
    835  1f17		       e6		      .byte.b	< PLAYER_RIGHT1
    836  1f18		       00		      .byte.b	0
    837  1f19		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    838  1f1a
    839  1f1a				   AnimateBLANK
    840  1f1a		       7f		      .byte.b	127
    841  1f1b		       bc		      .byte.b	< PLAYER_BLANK
    842  1f1c		       00		      .byte.b	0
    843  1f1d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    844  1f1e
    845  1f1e				   AnimateEND
      0  1f1e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  1f1e					      LIST	ON
    847  1f1e
    848  1f1e
      0  1f1e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1f1e		       07 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $71e , FREE= $e2
      2  1f1e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1f1e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1f1e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1f1e				  -	      ERR
      6  1f1e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 4
      0  1f1e					      include	"BANK_LEVELS1.asm"
      1  1f1e							;    Sokoboo - a Sokoban implementation
      2  1f1e							;    using a generic tile-based display engine for the Atari 2600
      3  1f1e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1f1e							;
      5  1f1e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1f1e							;
      7  1f1e							;    Code related to the generic tile-based display engine was developed by
      8  1f1e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1f1e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1f1e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1f1e							;
     12  1f1e							;    Code related to music and sound effects uses the TIATracker music player
     13  1f1e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1f1e							;    directory for Apache licensing details.
     15  1f1e							;
     16  1f1e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1f1e							;    See the copyright notices in the License directory for a list of level
     18  1f1e							;    contributors.
     19  1f1e							;
     20  1f1e							;    Except where otherwise indicated, this software is released under the
     21  1f1e							;    following licensing arrangement...
     22  1f1e							;
     23  1f1e							;    This program is free software: you can redistribute it and/or modify
     24  1f1e							;    it under the terms of the GNU General Public License as published by
     25  1f1e							;    the Free Software Foundation, either version 3 of the License, or
     26  1f1e							;    (at your option) any later version.
     27  1f1e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1f1e
     29  1f1e							;    This program is distributed in the hope that it will be useful,
     30  1f1e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1f1e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1f1e							;    GNU General Public License for more details.
     33  1f1e
      0  1f1e					      NEWBANK	LEVELS1
      1  27db ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000							; "SOKWHOLE" collection...
     37  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00		      .byte.b	0
      2  2012		       00 13	   LEVEL_SIZE__001_L =	* - LEVEL_START
      3  2013					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      4  2013				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      5  2013					      ENDIF
      0  2013					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2013					      START_LEVEL	_001_R
      1  2013				   LEVEL_START SET	*
      2  2013		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2013				   LEVEL__001_R SUBROUTINE
      4  2013				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2013
      2  2013		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201f					      END_LEVEL	_001_R
      1  201f		       00		      .byte.b	0
      2  201f		       00 0d	   LEVEL_SIZE__001_R =	* - LEVEL_START
      3  2020				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      4  2020				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      5  2020					      ENDIF
      0  2020					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  2020					      START_LEVEL	_002_L
      1  2020				   LEVEL_START SET	*
      2  2020		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  2020				   LEVEL__002_L SUBROUTINE
      4  2020				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2020
      2  2020		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2039					      END_LEVEL	_002_L
      1  2039		       00		      .byte.b	0
      2  2039		       00 1a	   LEVEL_SIZE__002_L =	* - LEVEL_START
      3  203a					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      4  203a				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      5  203a					      ENDIF
      0  203a					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  203a					      START_LEVEL	_002_R
      1  203a				   LEVEL_START SET	*
      2  203a		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  203a				   LEVEL__002_R SUBROUTINE
      4  203a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  203a
      2  203a		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  2062					      END_LEVEL	_002_R
      1  2062		       00		      .byte.b	0
      2  2062		       00 29	   LEVEL_SIZE__002_R =	* - LEVEL_START
      3  2063					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      4  2063				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      5  2063					      ENDIF
      0  2063					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  2063					      START_LEVEL	_003_L
      1  2063				   LEVEL_START SET	*
      2  2063		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  2063				   LEVEL__003_L SUBROUTINE
      4  2063				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2063
      2  2063		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208f					      END_LEVEL	_003_L
      1  208f		       00		      .byte.b	0
      2  208f		       00 2d	   LEVEL_SIZE__003_L =	* - LEVEL_START
      3  2090					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      4  2090				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      5  2090					      ENDIF
      0  2090					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  2090					      START_LEVEL	_003_R
      1  2090				   LEVEL_START SET	*
      2  2090		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  2090				   LEVEL__003_R SUBROUTINE
      4  2090				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2090
      2  2090		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20ba					      END_LEVEL	_003_R
      1  20ba		       00		      .byte.b	0
      2  20ba		       00 2b	   LEVEL_SIZE__003_R =	* - LEVEL_START
      3  20bb				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      4  20bb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      5  20bb					      ENDIF
      0  20bb					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20bb					      START_LEVEL	_004_L
      1  20bb				   LEVEL_START SET	*
      2  20bb		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20bb				   LEVEL__004_L SUBROUTINE
      4  20bb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20bb
      2  20bb		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20de					      END_LEVEL	_004_L
      1  20de		       00		      .byte.b	0
      2  20de		       00 24	   LEVEL_SIZE__004_L =	* - LEVEL_START
      3  20df				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      4  20df				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      5  20df					      ENDIF
      0  20df					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20df					      START_LEVEL	_004_R
      1  20df				   LEVEL_START SET	*
      2  20df		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20df				   LEVEL__004_R SUBROUTINE
      4  20df				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20df
      2  20df		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20fb					      END_LEVEL	_004_R
      1  20fb		       00		      .byte.b	0
      2  20fb		       00 1d	   LEVEL_SIZE__004_R =	* - LEVEL_START
      3  20fc				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      4  20fc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      5  20fc					      ENDIF
      0  20fc					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20fc					      START_LEVEL	_005_L
      1  20fc				   LEVEL_START SET	*
      2  20fc		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20fc				   LEVEL__005_L SUBROUTINE
      4  20fc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20fc
      2  20fc		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  212e					      END_LEVEL	_005_L
      1  212e		       00		      .byte.b	0
      2  212e		       00 33	   LEVEL_SIZE__005_L =	* - LEVEL_START
      3  212f					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      4  212f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      5  212f					      ENDIF
      0  212f					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  212f					      START_LEVEL	_005_R
      1  212f				   LEVEL_START SET	*
      2  212f		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  212f				   LEVEL__005_R SUBROUTINE
      4  212f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  212f
      2  212f		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  216e					      END_LEVEL	_005_R
      1  216e		       00		      .byte.b	0
      2  216e		       00 40	   LEVEL_SIZE__005_R =	* - LEVEL_START
      3  216f					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      4  216f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      5  216f					      ENDIF
      0  216f					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  216f					      START_LEVEL	_006_L
      1  216f				   LEVEL_START SET	*
      2  216f		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  216f				   LEVEL__006_L SUBROUTINE
      4  216f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  216f
      2  216f		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21aa					      END_LEVEL	_006_L
      1  21aa		       00		      .byte.b	0
      2  21aa		       00 3c	   LEVEL_SIZE__006_L =	* - LEVEL_START
      3  21ab				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      4  21ab				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      5  21ab					      ENDIF
      0  21ab					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21ab					      START_LEVEL	_006_R
      1  21ab				   LEVEL_START SET	*
      2  21ab		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21ab				   LEVEL__006_R SUBROUTINE
      4  21ab				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ab
      2  21ab		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21e9					      END_LEVEL	_006_R
      1  21e9		       00		      .byte.b	0
      2  21e9		       00 3f	   LEVEL_SIZE__006_R =	* - LEVEL_START
      3  21ea				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      4  21ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      5  21ea					      ENDIF
      0  21ea					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21ea					      START_LEVEL	_007_L
      1  21ea				   LEVEL_START SET	*
      2  21ea		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21ea				   LEVEL__007_L SUBROUTINE
      4  21ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ea
      2  21ea		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  2217					      END_LEVEL	_007_L
      1  2217		       00		      .byte.b	0
      2  2217		       00 2e	   LEVEL_SIZE__007_L =	* - LEVEL_START
      3  2218				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      4  2218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      5  2218					      ENDIF
      0  2218					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  2218					      START_LEVEL	_007_R
      1  2218				   LEVEL_START SET	*
      2  2218		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  2218				   LEVEL__007_R SUBROUTINE
      4  2218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2218
      2  2218		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  224b					      END_LEVEL	_007_R
      1  224b		       00		      .byte.b	0
      2  224b		       00 34	   LEVEL_SIZE__007_R =	* - LEVEL_START
      3  224c				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      4  224c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      5  224c					      ENDIF
      0  224c					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  224c					      START_LEVEL	_008_L
      1  224c				   LEVEL_START SET	*
      2  224c		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  224c				   LEVEL__008_L SUBROUTINE
      4  224c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  224c
      2  224c		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2282					      END_LEVEL	_008_L
      1  2282		       00		      .byte.b	0
      2  2282		       00 37	   LEVEL_SIZE__008_L =	* - LEVEL_START
      3  2283				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      4  2283				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      5  2283					      ENDIF
      0  2283					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2283					      START_LEVEL	_008_R
      1  2283				   LEVEL_START SET	*
      2  2283		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2283				   LEVEL__008_R SUBROUTINE
      4  2283				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2283
      2  2283		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22b4					      END_LEVEL	_008_R
      1  22b4		       00		      .byte.b	0
      2  22b4		       00 32	   LEVEL_SIZE__008_R =	* - LEVEL_START
      3  22b5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      4  22b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      5  22b5					      ENDIF
      0  22b5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22b5					      START_LEVEL	_009_L
      1  22b5				   LEVEL_START SET	*
      2  22b5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22b5				   LEVEL__009_L SUBROUTINE
      4  22b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22b5
      2  22b5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22e7					      END_LEVEL	_009_L
      1  22e7		       00		      .byte.b	0
      2  22e7		       00 33	   LEVEL_SIZE__009_L =	* - LEVEL_START
      3  22e8				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      4  22e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      5  22e8					      ENDIF
      0  22e8					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22e8					      START_LEVEL	_009_R
      1  22e8				   LEVEL_START SET	*
      2  22e8		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22e8				   LEVEL__009_R SUBROUTINE
      4  22e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22e8
      2  22e8		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2318					      END_LEVEL	_009_R
      1  2318		       00		      .byte.b	0
      2  2318		       00 31	   LEVEL_SIZE__009_R =	* - LEVEL_START
      3  2319				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      4  2319				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      5  2319					      ENDIF
      0  2319					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2319					      START_LEVEL	_010_L
      1  2319				   LEVEL_START SET	*
      2  2319		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2319				   LEVEL__010_L SUBROUTINE
      4  2319				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2319
      2  2319		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2353					      END_LEVEL	_010_L
      1  2353		       00		      .byte.b	0
      2  2353		       00 3b	   LEVEL_SIZE__010_L =	* - LEVEL_START
      3  2354				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      4  2354				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      5  2354					      ENDIF
      0  2354					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2354					      START_LEVEL	_010_R
      1  2354				   LEVEL_START SET	*
      2  2354		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2354				   LEVEL__010_R SUBROUTINE
      4  2354				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2354
      2  2354		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2387					      END_LEVEL	_010_R
      1  2387		       00		      .byte.b	0
      2  2387		       00 34	   LEVEL_SIZE__010_R =	* - LEVEL_START
      3  2388				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      4  2388				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      5  2388					      ENDIF
      0  2388					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2388					      START_LEVEL	_011_L
      1  2388				   LEVEL_START SET	*
      2  2388		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2388				   LEVEL__011_L SUBROUTINE
      4  2388				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2388
      2  2388		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23bb					      END_LEVEL	_011_L
      1  23bb		       00		      .byte.b	0
      2  23bb		       00 34	   LEVEL_SIZE__011_L =	* - LEVEL_START
      3  23bc				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      4  23bc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      5  23bc					      ENDIF
      0  23bc					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23bc					      START_LEVEL	_011_R
      1  23bc				   LEVEL_START SET	*
      2  23bc		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23bc				   LEVEL__011_R SUBROUTINE
      4  23bc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23bc
      2  23bc		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23f6					      END_LEVEL	_011_R
      1  23f6		       00		      .byte.b	0
      2  23f6		       00 3b	   LEVEL_SIZE__011_R =	* - LEVEL_START
      3  23f7				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      4  23f7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      5  23f7					      ENDIF
      0  23f7					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23f7					      START_LEVEL	_012_L
      1  23f7				   LEVEL_START SET	*
      2  23f7		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23f7				   LEVEL__012_L SUBROUTINE
      4  23f7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23f7
      2  23f7		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2427					      END_LEVEL	_012_L
      1  2427		       00		      .byte.b	0
      2  2427		       00 31	   LEVEL_SIZE__012_L =	* - LEVEL_START
      3  2428				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      4  2428				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      5  2428					      ENDIF
      0  2428					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2428					      START_LEVEL	_012_R
      1  2428				   LEVEL_START SET	*
      2  2428		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2428				   LEVEL__012_R SUBROUTINE
      4  2428				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2428
      2  2428		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  2464					      END_LEVEL	_012_R
      1  2464		       00		      .byte.b	0
      2  2464		       00 3d	   LEVEL_SIZE__012_R =	* - LEVEL_START
      3  2465				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      4  2465				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      5  2465					      ENDIF
      0  2465					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  2465					      START_LEVEL	_013_L
      1  2465				   LEVEL_START SET	*
      2  2465		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  2465				   LEVEL__013_L SUBROUTINE
      4  2465				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2465
      2  2465		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  24a4					      END_LEVEL	_013_L
      1  24a4		       00		      .byte.b	0
      2  24a4		       00 40	   LEVEL_SIZE__013_L =	* - LEVEL_START
      3  24a5				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      4  24a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      5  24a5					      ENDIF
      0  24a5					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  24a5					      START_LEVEL	_013_R
      1  24a5				   LEVEL_START SET	*
      2  24a5		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  24a5				   LEVEL__013_R SUBROUTINE
      4  24a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24a5
      2  24a5		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24d8					      END_LEVEL	_013_R
      1  24d8		       00		      .byte.b	0
      2  24d8		       00 34	   LEVEL_SIZE__013_R =	* - LEVEL_START
      3  24d9				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      4  24d9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      5  24d9					      ENDIF
      0  24d9					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24d9					      START_LEVEL	_014_L
      1  24d9				   LEVEL_START SET	*
      2  24d9		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24d9				   LEVEL__014_L SUBROUTINE
      4  24d9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24d9
      2  24d9		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  251c					      END_LEVEL	_014_L
      1  251c		       00		      .byte.b	0
      2  251c		       00 44	   LEVEL_SIZE__014_L =	* - LEVEL_START
      3  251d					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      4  251d				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      5  251d					      ENDIF
      0  251d					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  251d					      START_LEVEL	_014_R
      1  251d				   LEVEL_START SET	*
      2  251d		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  251d				   LEVEL__014_R SUBROUTINE
      4  251d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  251d
      2  251d		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2560					      END_LEVEL	_014_R
      1  2560		       00		      .byte.b	0
      2  2560		       00 44	   LEVEL_SIZE__014_R =	* - LEVEL_START
      3  2561				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      4  2561				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      5  2561					      ENDIF
      0  2561					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2561					      START_LEVEL	_015_L
      1  2561				   LEVEL_START SET	*
      2  2561		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2561				   LEVEL__015_L SUBROUTINE
      4  2561				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2561
      2  2561		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  2596					      END_LEVEL	_015_L
      1  2596		       00		      .byte.b	0
      2  2596		       00 36	   LEVEL_SIZE__015_L =	* - LEVEL_START
      3  2597				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      4  2597				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      5  2597					      ENDIF
      0  2597					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  2597					      START_LEVEL	_015_R
      1  2597				   LEVEL_START SET	*
      2  2597		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  2597				   LEVEL__015_R SUBROUTINE
      4  2597				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2597
      2  2597		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25dc					      END_LEVEL	_015_R
      1  25dc		       00		      .byte.b	0
      2  25dc		       00 46	   LEVEL_SIZE__015_R =	* - LEVEL_START
      3  25dd					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      4  25dd				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      5  25dd					      ENDIF
      0  25dd					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25dd					      START_LEVEL	_016_L
      1  25dd				   LEVEL_START SET	*
      2  25dd		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25dd				   LEVEL__016_L SUBROUTINE
      4  25dd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25dd
      2  25dd		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  2614					      END_LEVEL	_016_L
      1  2614		       00		      .byte.b	0
      2  2614		       00 38	   LEVEL_SIZE__016_L =	* - LEVEL_START
      3  2615				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      4  2615				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      5  2615					      ENDIF
      0  2615					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  2615					      START_LEVEL	_016_R
      1  2615				   LEVEL_START SET	*
      2  2615		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  2615				   LEVEL__016_R SUBROUTINE
      4  2615				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2615
      2  2615		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2648					      END_LEVEL	_016_R
      1  2648		       00		      .byte.b	0
      2  2648		       00 34	   LEVEL_SIZE__016_R =	* - LEVEL_START
      3  2649				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      4  2649				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      5  2649					      ENDIF
      0  2649					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2649					      START_LEVEL	_017_L
      1  2649				   LEVEL_START SET	*
      2  2649		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2649				   LEVEL__017_L SUBROUTINE
      4  2649				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2649
      2  2649		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2693					      END_LEVEL	_017_L
      1  2693		       00		      .byte.b	0
      2  2693		       00 4b	   LEVEL_SIZE__017_L =	* - LEVEL_START
      3  2694					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      4  2694				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      5  2694					      ENDIF
      0  2694					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2694					      START_LEVEL	_017_R
      1  2694				   LEVEL_START SET	*
      2  2694		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2694				   LEVEL__017_R SUBROUTINE
      4  2694				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2694
      2  2694		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26d7					      END_LEVEL	_017_R
      1  26d7		       00		      .byte.b	0
      2  26d7		       00 44	   LEVEL_SIZE__017_R =	* - LEVEL_START
      3  26d8				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      4  26d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      5  26d8					      ENDIF
      0  26d8					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26d8					      START_LEVEL	_018_L
      1  26d8				   LEVEL_START SET	*
      2  26d8		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26d8				   LEVEL__018_L SUBROUTINE
      4  26d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26d8
      2  26d8		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  270c					      END_LEVEL	_018_L
      1  270c		       00		      .byte.b	0
      2  270c		       00 35	   LEVEL_SIZE__018_L =	* - LEVEL_START
      3  270d				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      4  270d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      5  270d					      ENDIF
      0  270d					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  270d					      START_LEVEL	_018_R
      1  270d				   LEVEL_START SET	*
      2  270d		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  270d				   LEVEL__018_R SUBROUTINE
      4  270d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  270d
      2  270d		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2749					      END_LEVEL	_018_R
      1  2749		       00		      .byte.b	0
      2  2749		       00 3d	   LEVEL_SIZE__018_R =	* - LEVEL_START
      3  274a				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      4  274a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      5  274a					      ENDIF
      0  274a					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  274a					      START_LEVEL	_019_L
      1  274a				   LEVEL_START SET	*
      2  274a		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  274a				   LEVEL__019_L SUBROUTINE
      4  274a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  274a
      2  274a		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2785					      END_LEVEL	_019_L
      1  2785		       00		      .byte.b	0
      2  2785		       00 3c	   LEVEL_SIZE__019_L =	* - LEVEL_START
      3  2786				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      4  2786				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      5  2786					      ENDIF
      0  2786					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2786					      START_LEVEL	_019_R
      1  2786				   LEVEL_START SET	*
      2  2786		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2786				   LEVEL__019_R SUBROUTINE
      4  2786				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2786
      2  2786		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27d6					      END_LEVEL	_019_R
      1  27d6		       00		      .byte.b	0
      2  27d6		       00 51	   LEVEL_SIZE__019_R =	* - LEVEL_START
      3  27d7					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      4  27d7				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      5  27d7					      ENDIF
     76  27d7
     77  27d7							;-----------------------------------------------------------
     78  27d7							; Stella 3E autodetect signature, can live anywhere
     79  27d7		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
     80  27db							;-----------------------------------------------------------
     81  27db
      0  27db					      CHECK_BANK_SIZE	"LEVELS1"
      1  27db		       07 db	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7db , FREE= $25
      2  27db					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27db				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27db				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27db				  -	      ERR
      6  27db					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 4
      0  27db					      include	"BANK_LEVELS2.asm"
      1  27db							;    Sokoboo - a Sokoban implementation
      2  27db							;    using a generic tile-based display engine for the Atari 2600
      3  27db							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27db							;
      5  27db							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27db							;
      7  27db							;    Code related to the generic tile-based display engine was developed by
      8  27db							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27db							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27db							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27db							;
     12  27db							;    Code related to music and sound effects uses the TIATracker music player
     13  27db							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27db							;    directory for Apache licensing details.
     15  27db							;
     16  27db							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27db							;    See the copyright notices in the License directory for a list of level
     18  27db							;    contributors.
     19  27db							;
     20  27db							;    Except where otherwise indicated, this software is released under the
     21  27db							;    following licensing arrangement...
     22  27db							;
     23  27db							;    This program is free software: you can redistribute it and/or modify
     24  27db							;    it under the terms of the GNU General Public License as published by
     25  27db							;    the Free Software Foundation, either version 3 of the License, or
     26  27db							;    (at your option) any later version.
     27  27db							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27db
     29  27db							;    This program is distributed in the hope that it will be useful,
     30  27db							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27db							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27db							;    GNU General Public License for more details.
     33  27db
      0  27db					      NEWBANK	LEVELS2
      1  2c2e ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00		      .byte.b	0
      2  283f		       00 40	   LEVEL_SIZE__020_L =	* - LEVEL_START
      3  2840				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      4  2840				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      5  2840					      ENDIF
      0  2840					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  2840					      START_LEVEL	_020_R
      1  2840				   LEVEL_START SET	*
      2  2840		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  2840				   LEVEL__020_R SUBROUTINE
      4  2840				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2840
      2  2840		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  2880					      END_LEVEL	_020_R
      1  2880		       00		      .byte.b	0
      2  2880		       00 41	   LEVEL_SIZE__020_R =	* - LEVEL_START
      3  2881				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      4  2881				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      5  2881					      ENDIF
      0  2881					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  2881					      START_LEVEL	_021_L
      1  2881				   LEVEL_START SET	*
      2  2881		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  2881				   LEVEL__021_L SUBROUTINE
      4  2881				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2881
      2  2881		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d7					      END_LEVEL	_021_L
      1  28d7		       00		      .byte.b	0
      2  28d7		       00 57	   LEVEL_SIZE__021_L =	* - LEVEL_START
      3  28d8					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      4  28d8				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      5  28d8					      ENDIF
      0  28d8					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d8					      START_LEVEL	_021_R
      1  28d8				   LEVEL_START SET	*
      2  28d8		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d8				   LEVEL__021_R SUBROUTINE
      4  28d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d8
      2  28d8		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  290c					      END_LEVEL	_021_R
      1  290c		       00		      .byte.b	0
      2  290c		       00 35	   LEVEL_SIZE__021_R =	* - LEVEL_START
      3  290d				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      4  290d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      5  290d					      ENDIF
      0  290d					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  290d					      START_LEVEL	_022_L
      1  290d				   LEVEL_START SET	*
      2  290d		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  290d				   LEVEL__022_L SUBROUTINE
      4  290d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  290d
      2  290d		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  2953					      END_LEVEL	_022_L
      1  2953		       00		      .byte.b	0
      2  2953		       00 47	   LEVEL_SIZE__022_L =	* - LEVEL_START
      3  2954				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      4  2954				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      5  2954					      ENDIF
      0  2954					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  2954					      START_LEVEL	_022_R
      1  2954				   LEVEL_START SET	*
      2  2954		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  2954				   LEVEL__022_R SUBROUTINE
      4  2954				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2954
      2  2954		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  2990					      END_LEVEL	_022_R
      1  2990		       00		      .byte.b	0
      2  2990		       00 3d	   LEVEL_SIZE__022_R =	* - LEVEL_START
      3  2991				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      4  2991				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      5  2991					      ENDIF
      0  2991					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  2991					      START_LEVEL	_023_L
      1  2991				   LEVEL_START SET	*
      2  2991		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  2991				   LEVEL__023_L SUBROUTINE
      4  2991				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2991
      2  2991		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29d2					      END_LEVEL	_023_L
      1  29d2		       00		      .byte.b	0
      2  29d2		       00 42	   LEVEL_SIZE__023_L =	* - LEVEL_START
      3  29d3				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      4  29d3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      5  29d3					      ENDIF
      0  29d3					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29d3					      START_LEVEL	_023_R
      1  29d3				   LEVEL_START SET	*
      2  29d3		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29d3				   LEVEL__023_R SUBROUTINE
      4  29d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29d3
      2  29d3		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a15					      END_LEVEL	_023_R
      1  2a15		       00		      .byte.b	0
      2  2a15		       00 43	   LEVEL_SIZE__023_R =	* - LEVEL_START
      3  2a16				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      4  2a16				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      5  2a16					      ENDIF
      0  2a16					      DEFL	_024_L, "-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-"
      0  2a16					      START_LEVEL	_024_L
      1  2a16				   LEVEL_START SET	*
      2  2a16		       00 05	   BANK_LEVEL__024_L =	_CURRENT_BANK
      3  2a16				   LEVEL__024_L SUBROUTINE
      4  2a16				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a16
      2  2a16		       2d 39 23 7c*	      .byte.b	"-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-",0
      0  2a66					      END_LEVEL	_024_L
      1  2a66		       00		      .byte.b	0
      2  2a66		       00 51	   LEVEL_SIZE__024_L =	* - LEVEL_START
      3  2a67				  -	      IF	LEVEL_SIZE__024_L > MAX_LEVEL_SIZE
      4  2a67				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_L
      5  2a67					      ENDIF
      0  2a67					      DEFL	_024_R, "-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-"
      0  2a67					      START_LEVEL	_024_R
      1  2a67				   LEVEL_START SET	*
      2  2a67		       00 05	   BANK_LEVEL__024_R =	_CURRENT_BANK
      3  2a67				   LEVEL__024_R SUBROUTINE
      4  2a67				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a67
      2  2a67		       2d 38 23 7c*	      .byte.b	"-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-",0
      0  2aaf					      END_LEVEL	_024_R
      1  2aaf		       00		      .byte.b	0
      2  2aaf		       00 49	   LEVEL_SIZE__024_R =	* - LEVEL_START
      3  2ab0				  -	      IF	LEVEL_SIZE__024_R > MAX_LEVEL_SIZE
      4  2ab0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_R
      5  2ab0					      ENDIF
      0  2ab0					      DEFL	_025_L, "4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-"
      0  2ab0					      START_LEVEL	_025_L
      1  2ab0				   LEVEL_START SET	*
      2  2ab0		       00 05	   BANK_LEVEL__025_L =	_CURRENT_BANK
      3  2ab0				   LEVEL__025_L SUBROUTINE
      4  2ab0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ab0
      2  2ab0		       34 2d 34 23*	      .byte.b	"4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-",0
      0  2af3					      END_LEVEL	_025_L
      1  2af3		       00		      .byte.b	0
      2  2af3		       00 44	   LEVEL_SIZE__025_L =	* - LEVEL_START
      3  2af4				  -	      IF	LEVEL_SIZE__025_L > MAX_LEVEL_SIZE
      4  2af4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_L
      5  2af4					      ENDIF
      0  2af4					      DEFL	_025_R, "-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-"
      0  2af4					      START_LEVEL	_025_R
      1  2af4				   LEVEL_START SET	*
      2  2af4		       00 05	   BANK_LEVEL__025_R =	_CURRENT_BANK
      3  2af4				   LEVEL__025_R SUBROUTINE
      4  2af4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2af4
      2  2af4		       2d 36 23 2d*	      .byte.b	"-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-",0
      0  2b33					      END_LEVEL	_025_R
      1  2b33		       00		      .byte.b	0
      2  2b33		       00 40	   LEVEL_SIZE__025_R =	* - LEVEL_START
      3  2b34				  -	      IF	LEVEL_SIZE__025_R > MAX_LEVEL_SIZE
      4  2b34				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_R
      5  2b34					      ENDIF
      0  2b34					      DEFL	_026_L, "-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#"
      0  2b34					      START_LEVEL	_026_L
      1  2b34				   LEVEL_START SET	*
      2  2b34		       00 05	   BANK_LEVEL__026_L =	_CURRENT_BANK
      3  2b34				   LEVEL__026_L SUBROUTINE
      4  2b34				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b34
      2  2b34		       2d 36 23 32*	      .byte.b	"-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#",0
      0  2b6d					      END_LEVEL	_026_L
      1  2b6d		       00		      .byte.b	0
      2  2b6d		       00 3a	   LEVEL_SIZE__026_L =	* - LEVEL_START
      3  2b6e				  -	      IF	LEVEL_SIZE__026_L > MAX_LEVEL_SIZE
      4  2b6e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_L
      5  2b6e					      ENDIF
      0  2b6e					      DEFL	_026_R, "5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-"
      0  2b6e					      START_LEVEL	_026_R
      1  2b6e				   LEVEL_START SET	*
      2  2b6e		       00 05	   BANK_LEVEL__026_R =	_CURRENT_BANK
      3  2b6e				   LEVEL__026_R SUBROUTINE
      4  2b6e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b6e
      2  2b6e		       35 2d 34 23*	      .byte.b	"5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-",0
      0  2baf					      END_LEVEL	_026_R
      1  2baf		       00		      .byte.b	0
      2  2baf		       00 42	   LEVEL_SIZE__026_R =	* - LEVEL_START
      3  2bb0				  -	      IF	LEVEL_SIZE__026_R > MAX_LEVEL_SIZE
      4  2bb0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_R
      5  2bb0					      ENDIF
      0  2bb0					      DEFL	_027_L, "8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-"
      0  2bb0					      START_LEVEL	_027_L
      1  2bb0				   LEVEL_START SET	*
      2  2bb0		       00 05	   BANK_LEVEL__027_L =	_CURRENT_BANK
      3  2bb0				   LEVEL__027_L SUBROUTINE
      4  2bb0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2bb0
      2  2bb0		       38 23 2d 7c*	      .byte.b	"8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-",0
      0  2bee					      END_LEVEL	_027_L
      1  2bee		       00		      .byte.b	0
      2  2bee		       00 3f	   LEVEL_SIZE__027_L =	* - LEVEL_START
      3  2bef				  -	      IF	LEVEL_SIZE__027_L > MAX_LEVEL_SIZE
      4  2bef				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_L
      5  2bef					      ENDIF
      0  2bef					      DEFL	_027_R, "7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#"
      0  2bef					      START_LEVEL	_027_R
      1  2bef				   LEVEL_START SET	*
      2  2bef		       00 05	   BANK_LEVEL__027_R =	_CURRENT_BANK
      3  2bef				   LEVEL__027_R SUBROUTINE
      4  2bef				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2bef
      2  2bef		       37 23 32 2d*	      .byte.b	"7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#",0
      0  2c2d					      END_LEVEL	_027_R
      1  2c2d		       00		      .byte.b	0
      2  2c2d		       00 3f	   LEVEL_SIZE__027_R =	* - LEVEL_START
      3  2c2e				  -	      IF	LEVEL_SIZE__027_R > MAX_LEVEL_SIZE
      4  2c2e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_R
      5  2c2e					      ENDIF
     52  2c2e
     53  2c2e
      0  2c2e					      CHECK_BANK_SIZE	"LEVELS2"
      1  2c2e		       04 2e	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $42e , FREE= $3d2
      2  2c2e					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2c2e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2c2e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2c2e				  -	      ERR
      6  2c2e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 4
      0  2c2e					      include	"BANK_LEVELS3.asm"
      1  2c2e							;    Sokoboo - a Sokoban implementation
      2  2c2e							;    using a generic tile-based display engine for the Atari 2600
      3  2c2e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2c2e							;
      5  2c2e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2c2e							;
      7  2c2e							;    Code related to the generic tile-based display engine was developed by
      8  2c2e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2c2e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2c2e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2c2e							;
     12  2c2e							;    Code related to music and sound effects uses the TIATracker music player
     13  2c2e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2c2e							;    directory for Apache licensing details.
     15  2c2e							;
     16  2c2e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2c2e							;    See the copyright notices in the License directory for a list of level
     18  2c2e							;    contributors.
     19  2c2e							;
     20  2c2e							;    Except where otherwise indicated, this software is released under the
     21  2c2e							;    following licensing arrangement...
     22  2c2e							;
     23  2c2e							;    This program is free software: you can redistribute it and/or modify
     24  2c2e							;    it under the terms of the GNU General Public License as published by
     25  2c2e							;    the Free Software Foundation, either version 3 of the License, or
     26  2c2e							;    (at your option) any later version.
     27  2c2e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2c2e
     29  2c2e							;    This program is distributed in the hope that it will be useful,
     30  2c2e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2c2e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2c2e							;    GNU General Public License for more details.
     33  2c2e
      0  2c2e					      NEWBANK	LEVELS3
      1  3758 ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_028_L, "3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-"
      0  3000					      START_LEVEL	_028_L
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__028_L =	_CURRENT_BANK
      3  3000				   LEVEL__028_L SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       33 2d 33 23*	      .byte.b	"3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-",0
      0  304c					      END_LEVEL	_028_L
      1  304c		       00		      .byte.b	0
      2  304c		       00 4d	   LEVEL_SIZE__028_L =	* - LEVEL_START
      3  304d				  -	      IF	LEVEL_SIZE__028_L > MAX_LEVEL_SIZE
      4  304d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_L
      5  304d					      ENDIF
      0  304d					      DEFL	_028_R, "9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-"
      0  304d					      START_LEVEL	_028_R
      1  304d				   LEVEL_START SET	*
      2  304d		       00 06	   BANK_LEVEL__028_R =	_CURRENT_BANK
      3  304d				   LEVEL__028_R SUBROUTINE
      4  304d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  304d
      2  304d		       39 23 2d 7c*	      .byte.b	"9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-",0
      0  309b					      END_LEVEL	_028_R
      1  309b		       00		      .byte.b	0
      2  309b		       00 4f	   LEVEL_SIZE__028_R =	* - LEVEL_START
      3  309c				  -	      IF	LEVEL_SIZE__028_R > MAX_LEVEL_SIZE
      4  309c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_R
      5  309c					      ENDIF
      0  309c					      DEFL	_029_L, "-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-"
      0  309c					      START_LEVEL	_029_L
      1  309c				   LEVEL_START SET	*
      2  309c		       00 06	   BANK_LEVEL__029_L =	_CURRENT_BANK
      3  309c				   LEVEL__029_L SUBROUTINE
      4  309c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  309c
      2  309c		       2d 35 23 33*	      .byte.b	"-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-",0
      0  30e1					      END_LEVEL	_029_L
      1  30e1		       00		      .byte.b	0
      2  30e1		       00 46	   LEVEL_SIZE__029_L =	* - LEVEL_START
      3  30e2				  -	      IF	LEVEL_SIZE__029_L > MAX_LEVEL_SIZE
      4  30e2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_L
      5  30e2					      ENDIF
      0  30e2					      DEFL	_029_R, "-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-"
      0  30e2					      START_LEVEL	_029_R
      1  30e2				   LEVEL_START SET	*
      2  30e2		       00 06	   BANK_LEVEL__029_R =	_CURRENT_BANK
      3  30e2				   LEVEL__029_R SUBROUTINE
      4  30e2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30e2
      2  30e2		       2d 34 23 34*	      .byte.b	"-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-",0
      0  3126					      END_LEVEL	_029_R
      1  3126		       00		      .byte.b	0
      2  3126		       00 45	   LEVEL_SIZE__029_R =	* - LEVEL_START
      3  3127				  -	      IF	LEVEL_SIZE__029_R > MAX_LEVEL_SIZE
      4  3127				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_R
      5  3127					      ENDIF
      0  3127					      DEFL	_030_L, "6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#"
      0  3127					      START_LEVEL	_030_L
      1  3127				   LEVEL_START SET	*
      2  3127		       00 06	   BANK_LEVEL__030_L =	_CURRENT_BANK
      3  3127				   LEVEL__030_L SUBROUTINE
      4  3127				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3127
      2  3127		       36 2d 35 23*	      .byte.b	"6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#",0
      0  3177					      END_LEVEL	_030_L
      1  3177		       00		      .byte.b	0
      2  3177		       00 51	   LEVEL_SIZE__030_L =	* - LEVEL_START
      3  3178				  -	      IF	LEVEL_SIZE__030_L > MAX_LEVEL_SIZE
      4  3178				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_L
      5  3178					      ENDIF
      0  3178					      DEFL	_030_R, "-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#"
      0  3178					      START_LEVEL	_030_R
      1  3178				   LEVEL_START SET	*
      2  3178		       00 06	   BANK_LEVEL__030_R =	_CURRENT_BANK
      3  3178				   LEVEL__030_R SUBROUTINE
      4  3178				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3178
      2  3178		       2d 37 23 32*	      .byte.b	"-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#",0
      0  31cb					      END_LEVEL	_030_R
      1  31cb		       00		      .byte.b	0
      2  31cb		       00 54	   LEVEL_SIZE__030_R =	* - LEVEL_START
      3  31cc				  -	      IF	LEVEL_SIZE__030_R > MAX_LEVEL_SIZE
      4  31cc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_R
      5  31cc					      ENDIF
      0  31cc					      DEFL	_031_L, "-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-"
      0  31cc					      START_LEVEL	_031_L
      1  31cc				   LEVEL_START SET	*
      2  31cc		       00 06	   BANK_LEVEL__031_L =	_CURRENT_BANK
      3  31cc				   LEVEL__031_L SUBROUTINE
      4  31cc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31cc
      2  31cc		       2d 37 23 32*	      .byte.b	"-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-",0
      0  3212					      END_LEVEL	_031_L
      1  3212		       00		      .byte.b	0
      2  3212		       00 47	   LEVEL_SIZE__031_L =	* - LEVEL_START
      3  3213				  -	      IF	LEVEL_SIZE__031_L > MAX_LEVEL_SIZE
      4  3213				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_L
      5  3213					      ENDIF
      0  3213					      DEFL	_031_R, "6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#"
      0  3213					      START_LEVEL	_031_R
      1  3213				   LEVEL_START SET	*
      2  3213		       00 06	   BANK_LEVEL__031_R =	_CURRENT_BANK
      3  3213				   LEVEL__031_R SUBROUTINE
      4  3213				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3213
      2  3213		       36 23 2d 7c*	      .byte.b	"6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#",0
      0  3252					      END_LEVEL	_031_R
      1  3252		       00		      .byte.b	0
      2  3252		       00 40	   LEVEL_SIZE__031_R =	* - LEVEL_START
      3  3253				  -	      IF	LEVEL_SIZE__031_R > MAX_LEVEL_SIZE
      4  3253				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_R
      5  3253					      ENDIF
      0  3253					      DEFL	_032_L, "-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#"
      0  3253					      START_LEVEL	_032_L
      1  3253				   LEVEL_START SET	*
      2  3253		       00 06	   BANK_LEVEL__032_L =	_CURRENT_BANK
      3  3253				   LEVEL__032_L SUBROUTINE
      4  3253				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3253
      2  3253		       2d 34 23 32*	      .byte.b	"-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#",0
      0  328b					      END_LEVEL	_032_L
      1  328b		       00		      .byte.b	0
      2  328b		       00 39	   LEVEL_SIZE__032_L =	* - LEVEL_START
      3  328c				  -	      IF	LEVEL_SIZE__032_L > MAX_LEVEL_SIZE
      4  328c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_L
      5  328c					      ENDIF
      0  328c					      DEFL	_032_R, "9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-"
      0  328c					      START_LEVEL	_032_R
      1  328c				   LEVEL_START SET	*
      2  328c		       00 06	   BANK_LEVEL__032_R =	_CURRENT_BANK
      3  328c				   LEVEL__032_R SUBROUTINE
      4  328c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  328c
      2  328c		       39 23 2d 7c*	      .byte.b	"9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-",0
      0  32d0					      END_LEVEL	_032_R
      1  32d0		       00		      .byte.b	0
      2  32d0		       00 45	   LEVEL_SIZE__032_R =	* - LEVEL_START
      3  32d1				  -	      IF	LEVEL_SIZE__032_R > MAX_LEVEL_SIZE
      4  32d1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_R
      5  32d1					      ENDIF
      0  32d1					      DEFL	_033_L, "2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-"
      0  32d1					      START_LEVEL	_033_L
      1  32d1				   LEVEL_START SET	*
      2  32d1		       00 06	   BANK_LEVEL__033_L =	_CURRENT_BANK
      3  32d1				   LEVEL__033_L SUBROUTINE
      4  32d1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32d1
      2  32d1		       32 2d 37 23*	      .byte.b	"2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-",0
      0  331b					      END_LEVEL	_033_L
      1  331b		       00		      .byte.b	0
      2  331b		       00 4b	   LEVEL_SIZE__033_L =	* - LEVEL_START
      3  331c				  -	      IF	LEVEL_SIZE__033_L > MAX_LEVEL_SIZE
      4  331c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_L
      5  331c					      ENDIF
      0  331c					      DEFL	_033_R, "-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#"
      0  331c					      START_LEVEL	_033_R
      1  331c				   LEVEL_START SET	*
      2  331c		       00 06	   BANK_LEVEL__033_R =	_CURRENT_BANK
      3  331c				   LEVEL__033_R SUBROUTINE
      4  331c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  331c
      2  331c		       2d 37 23 32*	      .byte.b	"-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#",0
      0  335c					      END_LEVEL	_033_R
      1  335c		       00		      .byte.b	0
      2  335c		       00 41	   LEVEL_SIZE__033_R =	* - LEVEL_START
      3  335d				  -	      IF	LEVEL_SIZE__033_R > MAX_LEVEL_SIZE
      4  335d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_R
      5  335d					      ENDIF
      0  335d					      DEFL	_034_L, "5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-"
      0  335d					      START_LEVEL	_034_L
      1  335d				   LEVEL_START SET	*
      2  335d		       00 06	   BANK_LEVEL__034_L =	_CURRENT_BANK
      3  335d				   LEVEL__034_L SUBROUTINE
      4  335d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  335d
      2  335d		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-",0
      0  33ac					      END_LEVEL	_034_L
      1  33ac		       00		      .byte.b	0
      2  33ac		       00 50	   LEVEL_SIZE__034_L =	* - LEVEL_START
      3  33ad				  -	      IF	LEVEL_SIZE__034_L > MAX_LEVEL_SIZE
      4  33ad				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_L
      5  33ad					      ENDIF
      0  33ad					      DEFL	_034_R, "-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#"
      0  33ad					      START_LEVEL	_034_R
      1  33ad				   LEVEL_START SET	*
      2  33ad		       00 06	   BANK_LEVEL__034_R =	_CURRENT_BANK
      3  33ad				   LEVEL__034_R SUBROUTINE
      4  33ad				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33ad
      2  33ad		       2d 36 23 33*	      .byte.b	"-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#",0
      0  33f6					      END_LEVEL	_034_R
      1  33f6		       00		      .byte.b	0
      2  33f6		       00 4a	   LEVEL_SIZE__034_R =	* - LEVEL_START
      3  33f7				  -	      IF	LEVEL_SIZE__034_R > MAX_LEVEL_SIZE
      4  33f7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_R
      5  33f7					      ENDIF
      0  33f7					      DEFL	_035_L, "5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#"
      0  33f7					      START_LEVEL	_035_L
      1  33f7				   LEVEL_START SET	*
      2  33f7		       00 06	   BANK_LEVEL__035_L =	_CURRENT_BANK
      3  33f7				   LEVEL__035_L SUBROUTINE
      4  33f7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33f7
      2  33f7		       35 2d 33 23*	      .byte.b	"5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#",0
      0  343c					      END_LEVEL	_035_L
      1  343c		       00		      .byte.b	0
      2  343c		       00 46	   LEVEL_SIZE__035_L =	* - LEVEL_START
      3  343d				  -	      IF	LEVEL_SIZE__035_L > MAX_LEVEL_SIZE
      4  343d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_L
      5  343d					      ENDIF
      0  343d					      DEFL	_035_R, "-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-"
      0  343d					      START_LEVEL	_035_R
      1  343d				   LEVEL_START SET	*
      2  343d		       00 06	   BANK_LEVEL__035_R =	_CURRENT_BANK
      3  343d				   LEVEL__035_R SUBROUTINE
      4  343d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  343d
      2  343d		       2d 31 31 23*	      .byte.b	"-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-",0
      0  347d					      END_LEVEL	_035_R
      1  347d		       00		      .byte.b	0
      2  347d		       00 41	   LEVEL_SIZE__035_R =	* - LEVEL_START
      3  347e				  -	      IF	LEVEL_SIZE__035_R > MAX_LEVEL_SIZE
      4  347e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_R
      5  347e					      ENDIF
      0  347e					      DEFL	_036_L, "5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#"
      0  347e					      START_LEVEL	_036_L
      1  347e				   LEVEL_START SET	*
      2  347e		       00 06	   BANK_LEVEL__036_L =	_CURRENT_BANK
      3  347e				   LEVEL__036_L SUBROUTINE
      4  347e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347e
      2  347e		       35 23 32 2d*	      .byte.b	"5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#",0
      0  34b4					      END_LEVEL	_036_L
      1  34b4		       00		      .byte.b	0
      2  34b4		       00 37	   LEVEL_SIZE__036_L =	* - LEVEL_START
      3  34b5				  -	      IF	LEVEL_SIZE__036_L > MAX_LEVEL_SIZE
      4  34b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_L
      5  34b5					      ENDIF
      0  34b5					      DEFL	_036_R, "2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-"
      0  34b5					      START_LEVEL	_036_R
      1  34b5				   LEVEL_START SET	*
      2  34b5		       00 06	   BANK_LEVEL__036_R =	_CURRENT_BANK
      3  34b5				   LEVEL__036_R SUBROUTINE
      4  34b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34b5
      2  34b5		       32 2d 35 23*	      .byte.b	"2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-",0
      0  34fb					      END_LEVEL	_036_R
      1  34fb		       00		      .byte.b	0
      2  34fb		       00 47	   LEVEL_SIZE__036_R =	* - LEVEL_START
      3  34fc				  -	      IF	LEVEL_SIZE__036_R > MAX_LEVEL_SIZE
      4  34fc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_R
      5  34fc					      ENDIF
      0  34fc					      DEFL	_037_L, "5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-"
      0  34fc					      START_LEVEL	_037_L
      1  34fc				   LEVEL_START SET	*
      2  34fc		       00 06	   BANK_LEVEL__037_L =	_CURRENT_BANK
      3  34fc				   LEVEL__037_L SUBROUTINE
      4  34fc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34fc
      2  34fc		       35 2d 36 23*	      .byte.b	"5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-",0
      0  3539					      END_LEVEL	_037_L
      1  3539		       00		      .byte.b	0
      2  3539		       00 3e	   LEVEL_SIZE__037_L =	* - LEVEL_START
      3  353a				  -	      IF	LEVEL_SIZE__037_L > MAX_LEVEL_SIZE
      4  353a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_L
      5  353a					      ENDIF
      0  353a					      DEFL	_037_R, "9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-"
      0  353a					      START_LEVEL	_037_R
      1  353a				   LEVEL_START SET	*
      2  353a		       00 06	   BANK_LEVEL__037_R =	_CURRENT_BANK
      3  353a				   LEVEL__037_R SUBROUTINE
      4  353a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  353a
      2  353a		       39 23 32 2d*	      .byte.b	"9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-",0
      0  3583					      END_LEVEL	_037_R
      1  3583		       00		      .byte.b	0
      2  3583		       00 4a	   LEVEL_SIZE__037_R =	* - LEVEL_START
      3  3584				  -	      IF	LEVEL_SIZE__037_R > MAX_LEVEL_SIZE
      4  3584				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_R
      5  3584					      ENDIF
      0  3584					      DEFL	_038_L, "6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-"
      0  3584					      START_LEVEL	_038_L
      1  3584				   LEVEL_START SET	*
      2  3584		       00 06	   BANK_LEVEL__038_L =	_CURRENT_BANK
      3  3584				   LEVEL__038_L SUBROUTINE
      4  3584				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3584
      2  3584		       36 2d 34 23*	      .byte.b	"6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-",0
      0  35cc					      END_LEVEL	_038_L
      1  35cc		       00		      .byte.b	0
      2  35cc		       00 49	   LEVEL_SIZE__038_L =	* - LEVEL_START
      3  35cd				  -	      IF	LEVEL_SIZE__038_L > MAX_LEVEL_SIZE
      4  35cd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_L
      5  35cd					      ENDIF
      0  35cd					      DEFL	_038_R, "6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-"
      0  35cd					      START_LEVEL	_038_R
      1  35cd				   LEVEL_START SET	*
      2  35cd		       00 06	   BANK_LEVEL__038_R =	_CURRENT_BANK
      3  35cd				   LEVEL__038_R SUBROUTINE
      4  35cd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35cd
      2  35cd		       36 2d 36 23*	      .byte.b	"6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-",0
      0  361c					      END_LEVEL	_038_R
      1  361c		       00		      .byte.b	0
      2  361c		       00 50	   LEVEL_SIZE__038_R =	* - LEVEL_START
      3  361d				  -	      IF	LEVEL_SIZE__038_R > MAX_LEVEL_SIZE
      4  361d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_R
      5  361d					      ENDIF
      0  361d					      DEFL	_039_L, "-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#"
      0  361d					      START_LEVEL	_039_L
      1  361d				   LEVEL_START SET	*
      2  361d		       00 06	   BANK_LEVEL__039_L =	_CURRENT_BANK
      3  361d				   LEVEL__039_L SUBROUTINE
      4  361d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  361d
      2  361d		       2d 37 23 32*	      .byte.b	"-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#",0
      0  366c					      END_LEVEL	_039_L
      1  366c		       00		      .byte.b	0
      2  366c		       00 50	   LEVEL_SIZE__039_L =	* - LEVEL_START
      3  366d				  -	      IF	LEVEL_SIZE__039_L > MAX_LEVEL_SIZE
      4  366d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_L
      5  366d					      ENDIF
      0  366d					      DEFL	_039_R, "4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-"
      0  366d					      START_LEVEL	_039_R
      1  366d				   LEVEL_START SET	*
      2  366d		       00 06	   BANK_LEVEL__039_R =	_CURRENT_BANK
      3  366d				   LEVEL__039_R SUBROUTINE
      4  366d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  366d
      2  366d		       34 2d 34 23*	      .byte.b	"4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-",0
      0  36c7					      END_LEVEL	_039_R
      1  36c7		       00		      .byte.b	0
      2  36c7		       00 5b	   LEVEL_SIZE__039_R =	* - LEVEL_START
      3  36c8					      IF	LEVEL_SIZE__039_R > MAX_LEVEL_SIZE
      4  36c8				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_R
      5  36c8					      ENDIF
      0  36c8					      DEFL	_040_L, "6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-"
      0  36c8					      START_LEVEL	_040_L
      1  36c8				   LEVEL_START SET	*
      2  36c8		       00 06	   BANK_LEVEL__040_L =	_CURRENT_BANK
      3  36c8				   LEVEL__040_L SUBROUTINE
      4  36c8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  36c8
      2  36c8		       36 23 33 2d*	      .byte.b	"6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-",0
      0  370f					      END_LEVEL	_040_L
      1  370f		       00		      .byte.b	0
      2  370f		       00 48	   LEVEL_SIZE__040_L =	* - LEVEL_START
      3  3710				  -	      IF	LEVEL_SIZE__040_L > MAX_LEVEL_SIZE
      4  3710				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_L
      5  3710					      ENDIF
      0  3710					      DEFL	_040_R, "5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-"
      0  3710					      START_LEVEL	_040_R
      1  3710				   LEVEL_START SET	*
      2  3710		       00 06	   BANK_LEVEL__040_R =	_CURRENT_BANK
      3  3710				   LEVEL__040_R SUBROUTINE
      4  3710				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3710
      2  3710		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-",0
      0  3757					      END_LEVEL	_040_R
      1  3757		       00		      .byte.b	0
      2  3757		       00 48	   LEVEL_SIZE__040_R =	* - LEVEL_START
      3  3758				  -	      IF	LEVEL_SIZE__040_R > MAX_LEVEL_SIZE
      4  3758				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_R
      5  3758					      ENDIF
     62  3758
     63  3758
     64  3758
     65  3758
     66  3758
     67  3758
      0  3758					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  3758		       07 58	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $758 , FREE= $a8
      2  3758					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3758				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3758				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3758				  -	      ERR
      6  3758					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 4
      0  3758					      include	"BANK_LEVELS4.asm"
      1  3758							;    Sokoboo - a Sokoban implementation
      2  3758							;    using a generic tile-based display engine for the Atari 2600
      3  3758							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3758							;
      5  3758							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3758							;
      7  3758							;    Code related to the generic tile-based display engine was developed by
      8  3758							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3758							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3758							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3758							;
     12  3758							;    Code related to music and sound effects uses the TIATracker music player
     13  3758							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3758							;    directory for Apache licensing details.
     15  3758							;
     16  3758							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3758							;    See the copyright notices in the License directory for a list of level
     18  3758							;    contributors.
     19  3758							;
     20  3758							;    Except where otherwise indicated, this software is released under the
     21  3758							;    following licensing arrangement...
     22  3758							;
     23  3758							;    This program is free software: you can redistribute it and/or modify
     24  3758							;    it under the terms of the GNU General Public License as published by
     25  3758							;    the Free Software Foundation, either version 3 of the License, or
     26  3758							;    (at your option) any later version.
     27  3758							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3758
     29  3758							;    This program is distributed in the hope that it will be useful,
     30  3758							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3758							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3758							;    GNU General Public License for more details.
     33  3758
     34  3758							; level definitions
     35  3758							; Sample level definitions.
     36  3758							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  3758							; have as many banks as you like.
     38  3758
      0  3758					      NEWBANK	LEVELS4
      1  3f86 ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
      0  3800					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  3800					      START_LEVEL	_050_L
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  3800				   LEVEL__050_L SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
      2  3800		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  384d					      END_LEVEL	_050_L
      1  384d		       00		      .byte.b	0
      2  384d		       00 4e	   LEVEL_SIZE__050_L =	* - LEVEL_START
      3  384e				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      4  384e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      5  384e					      ENDIF
      0  384e					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  384e					      START_LEVEL	_050_R
      1  384e				   LEVEL_START SET	*
      2  384e		       00 07	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  384e				   LEVEL__050_R SUBROUTINE
      4  384e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  384e
      2  384e		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  3887					      END_LEVEL	_050_R
      1  3887		       00		      .byte.b	0
      2  3887		       00 3a	   LEVEL_SIZE__050_R =	* - LEVEL_START
      3  3888				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      4  3888				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      5  3888					      ENDIF
      0  3888					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  3888					      START_LEVEL	_051_L
      1  3888				   LEVEL_START SET	*
      2  3888		       00 07	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  3888				   LEVEL__051_L SUBROUTINE
      4  3888				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3888
      2  3888		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  38db					      END_LEVEL	_051_L
      1  38db		       00		      .byte.b	0
      2  38db		       00 54	   LEVEL_SIZE__051_L =	* - LEVEL_START
      3  38dc				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      4  38dc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      5  38dc					      ENDIF
      0  38dc					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  38dc					      START_LEVEL	_051_R
      1  38dc				   LEVEL_START SET	*
      2  38dc		       00 07	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  38dc				   LEVEL__051_R SUBROUTINE
      4  38dc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38dc
      2  38dc		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  392d					      END_LEVEL	_051_R
      1  392d		       00		      .byte.b	0
      2  392d		       00 52	   LEVEL_SIZE__051_R =	* - LEVEL_START
      3  392e				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      4  392e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      5  392e					      ENDIF
      0  392e					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  392e					      START_LEVEL	_052_L
      1  392e				   LEVEL_START SET	*
      2  392e		       00 07	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  392e				   LEVEL__052_L SUBROUTINE
      4  392e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  392e
      2  392e		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  3968					      END_LEVEL	_052_L
      1  3968		       00		      .byte.b	0
      2  3968		       00 3b	   LEVEL_SIZE__052_L =	* - LEVEL_START
      3  3969				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      4  3969				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      5  3969					      ENDIF
      0  3969					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  3969					      START_LEVEL	_052_R
      1  3969				   LEVEL_START SET	*
      2  3969		       00 07	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  3969				   LEVEL__052_R SUBROUTINE
      4  3969				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3969
      2  3969		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  39b1					      END_LEVEL	_052_R
      1  39b1		       00		      .byte.b	0
      2  39b1		       00 49	   LEVEL_SIZE__052_R =	* - LEVEL_START
      3  39b2				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      4  39b2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      5  39b2					      ENDIF
      0  39b2					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  39b2					      START_LEVEL	_053_L
      1  39b2				   LEVEL_START SET	*
      2  39b2		       00 07	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  39b2				   LEVEL__053_L SUBROUTINE
      4  39b2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39b2
      2  39b2		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  3a07					      END_LEVEL	_053_L
      1  3a07		       00		      .byte.b	0
      2  3a07		       00 56	   LEVEL_SIZE__053_L =	* - LEVEL_START
      3  3a08				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      4  3a08				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      5  3a08					      ENDIF
      0  3a08					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  3a08					      START_LEVEL	_053_R
      1  3a08				   LEVEL_START SET	*
      2  3a08		       00 07	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  3a08				   LEVEL__053_R SUBROUTINE
      4  3a08				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a08
      2  3a08		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  3a55					      END_LEVEL	_053_R
      1  3a55		       00		      .byte.b	0
      2  3a55		       00 4e	   LEVEL_SIZE__053_R =	* - LEVEL_START
      3  3a56				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      4  3a56				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      5  3a56					      ENDIF
      0  3a56					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  3a56					      START_LEVEL	_054_L
      1  3a56				   LEVEL_START SET	*
      2  3a56		       00 07	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  3a56				   LEVEL__054_L SUBROUTINE
      4  3a56				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a56
      2  3a56		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  3aa2					      END_LEVEL	_054_L
      1  3aa2		       00		      .byte.b	0
      2  3aa2		       00 4d	   LEVEL_SIZE__054_L =	* - LEVEL_START
      3  3aa3				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      4  3aa3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      5  3aa3					      ENDIF
      0  3aa3					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  3aa3					      START_LEVEL	_054_R
      1  3aa3				   LEVEL_START SET	*
      2  3aa3		       00 07	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  3aa3				   LEVEL__054_R SUBROUTINE
      4  3aa3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3aa3
      2  3aa3		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  3aec					      END_LEVEL	_054_R
      1  3aec		       00		      .byte.b	0
      2  3aec		       00 4a	   LEVEL_SIZE__054_R =	* - LEVEL_START
      3  3aed				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      4  3aed				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      5  3aed					      ENDIF
      0  3aed					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  3aed					      START_LEVEL	_055_L
      1  3aed				   LEVEL_START SET	*
      2  3aed		       00 07	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  3aed				   LEVEL__055_L SUBROUTINE
      4  3aed				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3aed
      2  3aed		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  3b47					      END_LEVEL	_055_L
      1  3b47		       00		      .byte.b	0
      2  3b47		       00 5b	   LEVEL_SIZE__055_L =	* - LEVEL_START
      3  3b48				  -	      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      4  3b48				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      5  3b48					      ENDIF
      0  3b48					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  3b48					      START_LEVEL	_055_R
      1  3b48				   LEVEL_START SET	*
      2  3b48		       00 07	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  3b48				   LEVEL__055_R SUBROUTINE
      4  3b48				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b48
      2  3b48		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  3b9d					      END_LEVEL	_055_R
      1  3b9d		       00		      .byte.b	0
      2  3b9d		       00 56	   LEVEL_SIZE__055_R =	* - LEVEL_START
      3  3b9e				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      4  3b9e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      5  3b9e					      ENDIF
      0  3b9e					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  3b9e					      START_LEVEL	_056_L
      1  3b9e				   LEVEL_START SET	*
      2  3b9e		       00 07	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  3b9e				   LEVEL__056_L SUBROUTINE
      4  3b9e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b9e
      2  3b9e		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  3bf8					      END_LEVEL	_056_L
      1  3bf8		       00		      .byte.b	0
      2  3bf8		       00 5b	   LEVEL_SIZE__056_L =	* - LEVEL_START
      3  3bf9				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      4  3bf9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      5  3bf9					      ENDIF
      0  3bf9					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  3bf9					      START_LEVEL	_056_R
      1  3bf9				   LEVEL_START SET	*
      2  3bf9		       00 07	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  3bf9				   LEVEL__056_R SUBROUTINE
      4  3bf9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bf9
      2  3bf9		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  3c54					      END_LEVEL	_056_R
      1  3c54		       00		      .byte.b	0
      2  3c54		       00 5c	   LEVEL_SIZE__056_R =	* - LEVEL_START
      3  3c55					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      4  3c55				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      5  3c55					      ENDIF
      0  3c55					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  3c55					      START_LEVEL	_057_L
      1  3c55				   LEVEL_START SET	*
      2  3c55		       00 07	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  3c55				   LEVEL__057_L SUBROUTINE
      4  3c55				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c55
      2  3c55		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  3cab					      END_LEVEL	_057_L
      1  3cab		       00		      .byte.b	0
      2  3cab		       00 57	   LEVEL_SIZE__057_L =	* - LEVEL_START
      3  3cac				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      4  3cac				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      5  3cac					      ENDIF
     56  3cac
      0  3cac					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  3cac					      START_LEVEL	_060_R
      1  3cac				   LEVEL_START SET	*
      2  3cac		       00 07	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  3cac				   LEVEL__060_R SUBROUTINE
      4  3cac				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cac
      2  3cac		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  3cf4					      END_LEVEL	_060_R
      1  3cf4		       00		      .byte.b	0
      2  3cf4		       00 49	   LEVEL_SIZE__060_R =	* - LEVEL_START
      3  3cf5				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      4  3cf5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      5  3cf5					      ENDIF
      0  3cf5					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  3cf5					      START_LEVEL	_061_L
      1  3cf5				   LEVEL_START SET	*
      2  3cf5		       00 07	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  3cf5				   LEVEL__061_L SUBROUTINE
      4  3cf5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cf5
      2  3cf5		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  3d49					      END_LEVEL	_061_L
      1  3d49		       00		      .byte.b	0
      2  3d49		       00 55	   LEVEL_SIZE__061_L =	* - LEVEL_START
      3  3d4a				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      4  3d4a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      5  3d4a					      ENDIF
      0  3d4a					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  3d4a					      START_LEVEL	_061_R
      1  3d4a				   LEVEL_START SET	*
      2  3d4a		       00 07	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  3d4a				   LEVEL__061_R SUBROUTINE
      4  3d4a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d4a
      2  3d4a		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  3d93					      END_LEVEL	_061_R
      1  3d93		       00		      .byte.b	0
      2  3d93		       00 4a	   LEVEL_SIZE__061_R =	* - LEVEL_START
      3  3d94				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      4  3d94				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      5  3d94					      ENDIF
      0  3d94					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  3d94					      START_LEVEL	_062_L
      1  3d94				   LEVEL_START SET	*
      2  3d94		       00 07	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  3d94				   LEVEL__062_L SUBROUTINE
      4  3d94				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d94
      2  3d94		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  3deb					      END_LEVEL	_062_L
      1  3deb		       00		      .byte.b	0
      2  3deb		       00 58	   LEVEL_SIZE__062_L =	* - LEVEL_START
      3  3dec				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      4  3dec				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      5  3dec					      ENDIF
      0  3dec					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  3dec					      START_LEVEL	_062_R
      1  3dec				   LEVEL_START SET	*
      2  3dec		       00 07	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  3dec				   LEVEL__062_R SUBROUTINE
      4  3dec				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3dec
      2  3dec		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  3e38					      END_LEVEL	_062_R
      1  3e38		       00		      .byte.b	0
      2  3e38		       00 4d	   LEVEL_SIZE__062_R =	* - LEVEL_START
      3  3e39				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      4  3e39				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      5  3e39					      ENDIF
      0  3e39					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  3e39					      START_LEVEL	_063_L
      1  3e39				   LEVEL_START SET	*
      2  3e39		       00 07	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  3e39				   LEVEL__063_L SUBROUTINE
      4  3e39				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e39
      2  3e39		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  3e89					      END_LEVEL	_063_L
      1  3e89		       00		      .byte.b	0
      2  3e89		       00 51	   LEVEL_SIZE__063_L =	* - LEVEL_START
      3  3e8a				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      4  3e8a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      5  3e8a					      ENDIF
      0  3e8a					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  3e8a					      START_LEVEL	_063_R
      1  3e8a				   LEVEL_START SET	*
      2  3e8a		       00 07	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  3e8a				   LEVEL__063_R SUBROUTINE
      4  3e8a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e8a
      2  3e8a		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  3edc					      END_LEVEL	_063_R
      1  3edc		       00		      .byte.b	0
      2  3edc		       00 53	   LEVEL_SIZE__063_R =	* - LEVEL_START
      3  3edd				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      4  3edd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      5  3edd					      ENDIF
      0  3edd					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  3edd					      START_LEVEL	_064_L
      1  3edd				   LEVEL_START SET	*
      2  3edd		       00 07	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  3edd				   LEVEL__064_L SUBROUTINE
      4  3edd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3edd
      2  3edd		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  3f38					      END_LEVEL	_064_L
      1  3f38		       00		      .byte.b	0
      2  3f38		       00 5c	   LEVEL_SIZE__064_L =	* - LEVEL_START
      3  3f39				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      4  3f39				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      5  3f39					      ENDIF
      0  3f39					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  3f39					      START_LEVEL	_064_R
      1  3f39				   LEVEL_START SET	*
      2  3f39		       00 07	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  3f39				   LEVEL__064_R SUBROUTINE
      4  3f39				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3f39
      2  3f39		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  3f85					      END_LEVEL	_064_R
      1  3f85		       00		      .byte.b	0
      2  3f85		       00 4d	   LEVEL_SIZE__064_R =	* - LEVEL_START
      3  3f86				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      4  3f86				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      5  3f86					      ENDIF
     66  3f86
      0  3f86					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3f86		       07 86	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $786 , FREE= $7a
      2  3f86					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3f86				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3f86				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3f86				  -	      ERR
      6  3f86					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS5.asm LEVEL 2 PASS 4
      0  3f86					      include	"BANK_LEVELS5.asm"
      1  3f86							;    Sokoboo - a Sokoban implementation
      2  3f86							;    using a generic tile-based display engine for the Atari 2600
      3  3f86							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3f86							;
      5  3f86							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3f86							;
      7  3f86							;    Code related to the generic tile-based display engine was developed by
      8  3f86							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3f86							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3f86							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3f86							;
     12  3f86							;    Code related to music and sound effects uses the TIATracker music player
     13  3f86							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3f86							;    directory for Apache licensing details.
     15  3f86							;
     16  3f86							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3f86							;    See the copyright notices in the License directory for a list of level
     18  3f86							;    contributors.
     19  3f86							;
     20  3f86							;    Except where otherwise indicated, this software is released under the
     21  3f86							;    following licensing arrangement...
     22  3f86							;
     23  3f86							;    This program is free software: you can redistribute it and/or modify
     24  3f86							;    it under the terms of the GNU General Public License as published by
     25  3f86							;    the Free Software Foundation, either version 3 of the License, or
     26  3f86							;    (at your option) any later version.
     27  3f86							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3f86
     29  3f86							;    This program is distributed in the hope that it will be useful,
     30  3f86							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3f86							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3f86							;    GNU General Public License for more details.
     33  3f86
     34  3f86							; level definitions
     35  3f86							; Sample level definitions.
     36  3f86							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  3f86							; have as many banks as you like.
     38  3f86
      0  3f86					      NEWBANK	LEVELS5
      1  4352 ????				      SEG	LEVELS5
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   LEVELS5    SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	LEVELS5
     40  4000
      0  4000					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  4000					      START_LEVEL	_065_L
      1  4000				   LEVEL_START SET	*
      2  4000		       00 08	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  4000				   LEVEL__065_L SUBROUTINE
      4  4000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4000
      2  4000		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  4058					      END_LEVEL	_065_L
      1  4058		       00		      .byte.b	0
      2  4058		       00 59	   LEVEL_SIZE__065_L =	* - LEVEL_START
      3  4059				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      4  4059				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      5  4059					      ENDIF
      0  4059					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  4059					      START_LEVEL	_065_R
      1  4059				   LEVEL_START SET	*
      2  4059		       00 08	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  4059				   LEVEL__065_R SUBROUTINE
      4  4059				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4059
      2  4059		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  40a1					      END_LEVEL	_065_R
      1  40a1		       00		      .byte.b	0
      2  40a1		       00 49	   LEVEL_SIZE__065_R =	* - LEVEL_START
      3  40a2				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      4  40a2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      5  40a2					      ENDIF
      0  40a2					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  40a2					      START_LEVEL	_066_L
      1  40a2				   LEVEL_START SET	*
      2  40a2		       00 08	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  40a2				   LEVEL__066_L SUBROUTINE
      4  40a2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  40a2
      2  40a2		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  40fc					      END_LEVEL	_066_L
      1  40fc		       00		      .byte.b	0
      2  40fc		       00 5b	   LEVEL_SIZE__066_L =	* - LEVEL_START
      3  40fd				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      4  40fd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      5  40fd					      ENDIF
      0  40fd					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  40fd					      START_LEVEL	_066_R
      1  40fd				   LEVEL_START SET	*
      2  40fd		       00 08	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  40fd				   LEVEL__066_R SUBROUTINE
      4  40fd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  40fd
      2  40fd		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  4153					      END_LEVEL	_066_R
      1  4153		       00		      .byte.b	0
      2  4153		       00 57	   LEVEL_SIZE__066_R =	* - LEVEL_START
      3  4154				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      4  4154				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      5  4154					      ENDIF
      0  4154					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  4154					      START_LEVEL	_067_L
      1  4154				   LEVEL_START SET	*
      2  4154		       00 08	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  4154				   LEVEL__067_L SUBROUTINE
      4  4154				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4154
      2  4154		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  41a1					      END_LEVEL	_067_L
      1  41a1		       00		      .byte.b	0
      2  41a1		       00 4e	   LEVEL_SIZE__067_L =	* - LEVEL_START
      3  41a2				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      4  41a2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      5  41a2					      ENDIF
      0  41a2					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  41a2					      START_LEVEL	_067_R
      1  41a2				   LEVEL_START SET	*
      2  41a2		       00 08	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  41a2				   LEVEL__067_R SUBROUTINE
      4  41a2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  41a2
      2  41a2		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  4207					      END_LEVEL	_067_R
      1  4207		       00		      .byte.b	0
      2  4207		       00 66	   LEVEL_SIZE__067_R =	* - LEVEL_START
      3  4208					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      4  4208				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      5  4208					      ENDIF
      0  4208					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  4208					      START_LEVEL	_068_L
      1  4208				   LEVEL_START SET	*
      2  4208		       00 08	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  4208				   LEVEL__068_L SUBROUTINE
      4  4208				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4208
      2  4208		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  425c					      END_LEVEL	_068_L
      1  425c		       00		      .byte.b	0
      2  425c		       00 55	   LEVEL_SIZE__068_L =	* - LEVEL_START
      3  425d				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      4  425d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      5  425d					      ENDIF
      0  425d					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  425d					      START_LEVEL	_068_R
      1  425d				   LEVEL_START SET	*
      2  425d		       00 08	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  425d				   LEVEL__068_R SUBROUTINE
      4  425d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  425d
      2  425d		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  42b3					      END_LEVEL	_068_R
      1  42b3		       00		      .byte.b	0
      2  42b3		       00 57	   LEVEL_SIZE__068_R =	* - LEVEL_START
      3  42b4				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      4  42b4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      5  42b4					      ENDIF
      0  42b4					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  42b4					      START_LEVEL	_069_L
      1  42b4				   LEVEL_START SET	*
      2  42b4		       00 08	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  42b4				   LEVEL__069_L SUBROUTINE
      4  42b4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  42b4
      2  42b4		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  4302					      END_LEVEL	_069_L
      1  4302		       00		      .byte.b	0
      2  4302		       00 4f	   LEVEL_SIZE__069_L =	* - LEVEL_START
      3  4303				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      4  4303				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      5  4303					      ENDIF
      0  4303					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  4303					      START_LEVEL	_069_R
      1  4303				   LEVEL_START SET	*
      2  4303		       00 08	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  4303				   LEVEL__069_R SUBROUTINE
      4  4303				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4303
      2  4303		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  4351					      END_LEVEL	_069_R
      1  4351		       00		      .byte.b	0
      2  4351		       00 4f	   LEVEL_SIZE__069_R =	* - LEVEL_START
      3  4352				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      4  4352				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      5  4352					      ENDIF
     51  4352
     52  4352
      0  4352					      CHECK_BANK_SIZE	"LEVELS5 -- full 2K"
      1  4352		       03 52	   .TEMP      =	* - BANK_START
 LEVELS5 -- full 2K (2K) SIZE =  $352 , FREE= $4ae
      2  4352					      ECHO	"LEVELS5 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4352				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4352				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4352				  -	      ERR
      6  4352					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS6.asm LEVEL 2 PASS 4
      0  4352					      include	"BANK_LEVELS6.asm"
      1  4352							;    Sokoboo - a Sokoban implementation
      2  4352							;    using a generic tile-based display engine for the Atari 2600
      3  4352							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4352							;
      5  4352							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4352							;
      7  4352							;    Code related to the generic tile-based display engine was developed by
      8  4352							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4352							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4352							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4352							;
     12  4352							;    Code related to music and sound effects uses the TIATracker music player
     13  4352							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4352							;    directory for Apache licensing details.
     15  4352							;
     16  4352							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4352							;    See the copyright notices in the License directory for a list of level
     18  4352							;    contributors.
     19  4352							;
     20  4352							;    Except where otherwise indicated, this software is released under the
     21  4352							;    following licensing arrangement...
     22  4352							;
     23  4352							;    This program is free software: you can redistribute it and/or modify
     24  4352							;    it under the terms of the GNU General Public License as published by
     25  4352							;    the Free Software Foundation, either version 3 of the License, or
     26  4352							;    (at your option) any later version.
     27  4352							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4352
     29  4352							;    This program is distributed in the hope that it will be useful,
     30  4352							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4352							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4352							;    GNU General Public License for more details.
     33  4352
     34  4352							; level definitions
     35  4352							; Sample level definitions.
     36  4352							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  4352							; have as many banks as you like.
     38  4352
      0  4352					      NEWBANK	LEVELS6
      1  4db3 ????				      SEG	LEVELS6
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   LEVELS6    SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	LEVELS6
     40  4800
     41  4800
     42  4800							; Level definitions
     43  4800
     44  4800							; "sokhard" collection
     45  4800
      0  4800					      START_LEVEL	_102_Natalie
      1  4800				   LEVEL_START SET	*
      2  4800		       00 09	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  4800				   LEVEL__102_Natalie SUBROUTINE
      4  4800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4800
     47  4800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  4846					      END_LEVEL	_102_Natalie
      1  4846		       00		      .byte.b	0
      2  4846		       00 47	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      3  4847				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      4  4847				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      5  4847					      ENDIF
     49  4847
      0  4847					      START_LEVEL	_102_Mirabel
      1  4847				   LEVEL_START SET	*
      2  4847		       00 09	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  4847				   LEVEL__102_Mirabel SUBROUTINE
      4  4847				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4847
     51  4847		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  48a6					      END_LEVEL	_102_Mirabel
      1  48a6		       00		      .byte.b	0
      2  48a6		       00 60	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      3  48a7				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      4  48a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      5  48a7					      ENDIF
     53  48a7
      0  48a7					      START_LEVEL	_102_Oralia
      1  48a7				   LEVEL_START SET	*
      2  48a7		       00 09	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  48a7				   LEVEL__102_Oralia SUBROUTINE
      4  48a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48a7
     55  48a7		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  48eb					      END_LEVEL	_102_Oralia
      1  48eb		       00		      .byte.b	0
      2  48eb		       00 45	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      3  48ec				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      4  48ec				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      5  48ec					      ENDIF
     57  48ec
     58  48ec
     59  48ec							;---------------------------------------------------------------------------------------------------
     60  48ec							; IMAGE IS ABOVE DEFINITION
     61  48ec
     62  48ec							;  ###########
     63  48ec							;  #  #      #
     64  48ec							;  # $# $ $$ #
     65  48ec							;  #  ##$#$  #
     66  48ec							;  #  $    #@#
     67  48ec							;  # $## #  ##
     68  48ec							;  ##	# .## #
     69  48ec							;  ##$ #.*. ##
     70  48ec							;  # ..*. *. #
     71  48ec							;  # # .. #  #
     72  48ec							;  ###########
     73  48ec
      0  48ec					      START_LEVEL	_102_Raven
      1  48ec				   LEVEL_START SET	*
      2  48ec		       00 09	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  48ec				   LEVEL__102_Raven SUBROUTINE
      4  48ec				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48ec
     75  48ec		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  495a					      END_LEVEL	_102_Raven
      1  495a		       00		      .byte.b	0
      2  495a		       00 6f	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      3  495b					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      4  495b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      5  495b					      ENDIF
     77  495b
     78  495b							;  ############
     79  495b							;  #@##. #  # #
     80  495b							;  #**..$#    #
     81  495b							;  #. $..#  # #
     82  495b							;  # $#.$#$$$ #
     83  495b							;  #	      ##
     84  495b							;  #  ##  #   #
     85  495b							;  ############
     86  495b
      0  495b					      START_LEVEL	_103_Adin
      1  495b				   LEVEL_START SET	*
      2  495b		       00 09	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  495b				   LEVEL__103_Adin SUBROUTINE
      4  495b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  495b
     88  495b		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  49a6					      END_LEVEL	_103_Adin
      1  49a6		       00		      .byte.b	0
      2  49a6		       00 4c	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      3  49a7				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      4  49a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      5  49a7					      ENDIF
     90  49a7
     91  49a7							;  #######___
     92  49a7							;  #	  #___
     93  49a7							;  #	$$#___
     94  49a7							;  #.*  .#___
     95  49a7							;  #$*$#*###_
     96  49a7							;  #@*... .#_
     97  49a7							;  #####$ .##
     98  49a7							;  ___# $ $ #
     99  49a7							;  ___#     #
    100  49a7							;  ___#######	(_ = modified by boo from wall)
    101  49a7
      0  49a7					      START_LEVEL	_103_Ajalae
      1  49a7				   LEVEL_START SET	*
      2  49a7		       00 09	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  49a7				   LEVEL__103_Ajalae SUBROUTINE
      4  49a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49a7
    103  49a7		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  49ee					      END_LEVEL	_103_Ajalae
      1  49ee		       00		      .byte.b	0
      2  49ee		       00 48	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      3  49ef				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      4  49ef				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      5  49ef					      ENDIF
    105  49ef
    106  49ef							;  ############
    107  49ef							;  #@#  #     #
    108  49ef							;  #  # #$#$# #
    109  49ef							;  # *$       #
    110  49ef							;  #..##$#$   #
    111  49ef							;  #..#. #  $ #
    112  49ef							;  #....# $$$##
    113  49ef							;  #	       #
    114  49ef							;  ############
    115  49ef
      0  49ef					      START_LEVEL	_103_Arielle
      1  49ef				   LEVEL_START SET	*
      2  49ef		       00 09	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  49ef				   LEVEL__103_Arielle SUBROUTINE
      4  49ef				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49ef
    117  49ef		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  4a3f					      END_LEVEL	_103_Arielle
      1  4a3f		       00		      .byte.b	0
      2  4a3f		       00 51	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      3  4a40				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      4  4a40				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      5  4a40					      ENDIF
    119  4a40
    120  4a40
    121  4a40
      0  4a40					      START_LEVEL	_1XJH_Tara_Gelson
      1  4a40				   LEVEL_START SET	*
      2  4a40		       00 09	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  4a40				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  4a40				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a40
    123  4a40		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  4a7a					      END_LEVEL	_1XJH_Tara_Gelson
      1  4a7a		       00		      .byte.b	0
      2  4a7a		       00 3b	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      3  4a7b				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      4  4a7b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      5  4a7b					      ENDIF
    125  4a7b
      0  4a7b					      START_LEVEL	_1R7X_Alison
      1  4a7b				   LEVEL_START SET	*
      2  4a7b		       00 09	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  4a7b				   LEVEL__1R7X_Alison SUBROUTINE
      4  4a7b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a7b
    127  4a7b		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  4aa8					      END_LEVEL	_1R7X_Alison
      1  4aa8		       00		      .byte.b	0
      2  4aa8		       00 2e	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      3  4aa9				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      4  4aa9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      5  4aa9					      ENDIF
    129  4aa9
      0  4aa9					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  4aa9				   LEVEL_START SET	*
      2  4aa9		       00 09	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  4aa9				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  4aa9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4aa9
    131  4aa9		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  4add					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  4add		       00		      .byte.b	0
      2  4add		       00 35	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      3  4ade				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      4  4ade				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      5  4ade					      ENDIF
    133  4ade
      0  4ade					      START_LEVEL	_1EKT_Samantha_Gelson
      1  4ade				   LEVEL_START SET	*
      2  4ade		       00 09	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  4ade				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  4ade				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ade
    135  4ade		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  4b17					      END_LEVEL	_1EKT_Samantha_Gelson
      1  4b17		       00		      .byte.b	0
      2  4b17		       00 3a	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      3  4b18				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      4  4b18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      5  4b18					      ENDIF
    137  4b18
      0  4b18					      START_LEVEL	_0VM5_Andrea_Wadd
      1  4b18				   LEVEL_START SET	*
      2  4b18		       00 09	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  4b18				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  4b18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b18
    139  4b18		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  4b45					      END_LEVEL	_0VM5_Andrea_Wadd
      1  4b45		       00		      .byte.b	0
      2  4b45		       00 2e	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      3  4b46				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      4  4b46				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      5  4b46					      ENDIF
    141  4b46
      0  4b46					      START_LEVEL	_0PAL_Jill_Leatherby
      1  4b46				   LEVEL_START SET	*
      2  4b46		       00 09	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  4b46				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  4b46				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b46
    143  4b46		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  4b70					      END_LEVEL	_0PAL_Jill_Leatherby
      1  4b70		       00		      .byte.b	0
      2  4b70		       00 2b	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      3  4b71				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      4  4b71				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      5  4b71					      ENDIF
    145  4b71
      0  4b71					      START_LEVEL	_0IZ1_Sophia
      1  4b71				   LEVEL_START SET	*
      2  4b71		       00 09	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  4b71				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  4b71				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b71
    147  4b71		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  4b9c					      END_LEVEL	_0IZ1_Sophia
      1  4b9c		       00		      .byte.b	0
      2  4b9c		       00 2c	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      3  4b9d				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      4  4b9d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      5  4b9d					      ENDIF
    149  4b9d
      0  4b9d					      START_LEVEL	_0CNH_Alice
      1  4b9d				   LEVEL_START SET	*
      2  4b9d		       00 09	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  4b9d				   LEVEL__0CNH_Alice SUBROUTINE
      4  4b9d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b9d
    151  4b9d		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  4bc9					      END_LEVEL	_0CNH_Alice
      1  4bc9		       00		      .byte.b	0
      2  4bc9		       00 2d	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      3  4bca				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      4  4bca				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      5  4bca					      ENDIF
    153  4bca
    154  4bca							;  START_LEVEL TowC
    155  4bca							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    156  4bca							;  END_LEVEL TowC
    157  4bca
    158  4bca							;  START_LEVEL SimpleC
    159  4bca							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    160  4bca							;  END_LEVEL SimpleC
    161  4bca
      0  4bca					      START_LEVEL	bAlfa_DrFogh
      1  4bca				   LEVEL_START SET	*
      2  4bca		       00 09	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  4bca				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  4bca				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4bca
    163  4bca		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  4c71					      END_LEVEL	bAlfa_DrFogh
      1  4c71		       00		      .byte.b	0
      2  4c71		       00 a8	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      3  4c72					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      4  4c72				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      5  4c72					      ENDIF
    165  4c72
      0  4c72					      START_LEVEL	b51X_Sharpen
      1  4c72				   LEVEL_START SET	*
      2  4c72		       00 09	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  4c72				   LEVEL_b51X_Sharpen SUBROUTINE
      4  4c72				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4c72
    167  4c72		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  4cf2					      END_LEVEL	b51X_Sharpen
      1  4cf2		       00		      .byte.b	0
      2  4cf2		       00 81	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      3  4cf3				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      4  4cf3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      5  4cf3					      ENDIF
    169  4cf3
      0  4cf3					      START_LEVEL	bDarcy_Burnsell101
      1  4cf3				   LEVEL_START SET	*
      2  4cf3		       00 09	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  4cf3				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  4cf3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4cf3
    171  4cf3		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  4d2f					      END_LEVEL	bDarcy_Burnsell101
      1  4d2f		       00		      .byte.b	0
      2  4d2f		       00 3d	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      3  4d30				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      4  4d30				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      5  4d30					      ENDIF
    173  4d30
      0  4d30					      START_LEVEL	bAislin101
      1  4d30				   LEVEL_START SET	*
      2  4d30		       00 09	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  4d30				   LEVEL_bAislin101 SUBROUTINE
      4  4d30				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d30
    175  4d30		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  4d6c					      END_LEVEL	bAislin101
      1  4d6c		       00		      .byte.b	0
      2  4d6c		       00 3d	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      3  4d6d				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      4  4d6d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      5  4d6d					      ENDIF
    177  4d6d
    178  4d6d							;  START_LEVEL b82X_Sharpen
    179  4d6d							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    180  4d6d							;  END_LEVEL b82X_Sharpen
    181  4d6d
      0  4d6d					      START_LEVEL	Thomas_Reinke16
      1  4d6d				   LEVEL_START SET	*
      2  4d6d		       00 09	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  4d6d				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  4d6d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d6d
    183  4d6d		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  4db2					      END_LEVEL	Thomas_Reinke16
      1  4db2		       00		      .byte.b	0
      2  4db2		       00 46	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      3  4db3				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      4  4db3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      5  4db3					      ENDIF
    185  4db3
    186  4db3							;Level element	Character	ASCII Code
    187  4db3							;Wall	#	0x23
    188  4db3							;Player	@	0x40
    189  4db3							;Player on goal square	+	0x2b
    190  4db3							;Box	$	0x24
    191  4db3							;Box on goal square	*	0x2a
    192  4db3							;Goal square	.	0x2e
    193  4db3							;Floor	(Space)	0x20 or underscore
    194  4db3
    195  4db3							;This level ("Claire", by Lee J Haywood):
    196  4db3
    197  4db3							;#######
    198  4db3							;#.@ # #
    199  4db3							;#$* $ #
    200  4db3							;#   $ #
    201  4db3							;# ..	#
    202  4db3							;#  *	#
    203  4db3							;#######
    204  4db3							;runlength encoded looks like this:
    205  4db3
    206  4db3							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    207  4db3
    208  4db3							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    209  4db3
    210  4db3
      0  4db3					      CHECK_BANK_SIZE	"LEVELS6 -- full 2K"
      1  4db3		       05 b3	   .TEMP      =	* - BANK_START
 LEVELS6 -- full 2K (2K) SIZE =  $5b3 , FREE= $24d
      2  4db3					      ECHO	"LEVELS6 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4db3				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4db3				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4db3				  -	      ERR
      6  4db3					      endif
------- FILE ./sokoboo.asm
------- FILE titleScreen.asm LEVEL 2 PASS 4
      0  4db3					      include	"titleScreen.asm"
      0  4db3					      NEWBANK	TITLESCREEN
      1  5452 ????				      SEG	TITLESCREEN
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   TITLESCREEN SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	TITLESCREEN
      0  5000					      DEFINE_SUBROUTINE	TitleScreen
      1  5000		       00 0a	   BANK_TitleScreen =	_CURRENT_BANK
      2  5000					      SUBROUTINE
      3  5000				   TitleScreen
      3  5000
      4  5000							; Start of new frame
      5  5000
      6  5000							; Start of vertical blank processing
      7  5000
      8  5000				   TitleSequence
      9  5000
     10  5000		       a9 00		      lda	#%00000000
     11  5002		       85 4a		      sta	CTRLPF	; copy playfield
     12  5004		       a9 00		      lda	#$0
     13  5006		       85 49		      sta	COLUBK	; set the background color (sky)
     14  5008
     15  5008		       a5 81		      lda	Platform
     16  500a		       29 02		      and	#%10
     17  500c		       aa		      tax
     18  500d		       bd 8e f0 	      lda	colvec,x
     19  5010		       85 da		      sta	colour_table
     20  5012		       bd 8f f0 	      lda	colvec+1,x
     21  5015		       85 db		      sta	colour_table+1
     22  5017
     23  5017
     24  5017				   RestartFrame
     25  5017
     26  5017
     27  5017		       a9 0e		      lda	#%1110	; VSYNC ON
     28  5019		       85 42	   .loopVSync2 sta	WSYNC
     29  501b		       85 40		      sta	VSYNC
     30  501d		       4a		      lsr
     31  501e		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     32  5020
     33  5020							;------------------------------------------------------------------
     34  5020
     35  5020		       a6 81		      ldx	Platform
     36  5022		       bc 5a fc 	      ldy	VBlankTime,x
     37  5025		       8c 96 02 	      sty	TIM64T
     38  5028
     39  5028		       85 42	   VerticalBlank sta	WSYNC
     40  502a		       ad 84 02 	      lda	INTIM
     41  502d		       d0 f9		      bne	VerticalBlank
     42  502f		       85 41		      sta	VBLANK
     43  5031
     44  5031							;------------------------------------------------------------------
     45  5031
     46  5031							; Do X scanlines of color-changing (our picture)
     47  5031
     48  5031		       a0 77		      ldy	#119	; this counts our scanline number
     49  5033		       a2 03	   SokoLogo   ldx	#3
     50  5035		       b1 da	   triplet    lda	(colour_table),y
     51  5037		       85 42		      sta	WSYNC
     52  5039		       85 48		      sta	COLUPF	; 3
     53  503b
     54  503b		       b9 82 f1 	      lda	COL_0,y	; 5
     55  503e		       85 4d		      sta	PF0	; 3   @11
     56  5040		       b9 fa f1 	      lda	COL_1,y	; 5
     57  5043		       85 4e		      sta	PF1	; 3   @19
     58  5045		       b9 72 f2 	      lda	COL_2,y	; 5
     59  5048		       85 4f		      sta	PF2	; 3   @27
     60  504a
     61  504a		       b9 ea f2 	      lda	COL_3,y	; 5
     62  504d		       85 4d		      sta	PF0	; 3   @35
      0  504f					      SLEEP	2	; @37
      1  504f				   .CYCLES    SET	2
      2  504f
      3  504f				  -	      IF	.CYCLES < 2
      4  504f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  504f				  -	      ERR
      6  504f					      ENDIF
      7  504f
      8  504f				  -	      IF	.CYCLES & 1
      9  504f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  504f				  -	      nop	0
     11  504f				  -	      ELSE
     12  504f				  -	      bit	VSYNC
     13  504f				  -	      ENDIF
     14  504f				  -.CYCLES    SET	.CYCLES - 3
     15  504f					      ENDIF
     16  504f
     17  504f					      REPEAT	.CYCLES / 2
     18  504f		       ea		      nop
     19  5050					      REPEND
     64  5050		       b9 62 f3 	      lda	COL_4,y	; 5
     65  5053		       85 4e		      sta	PF1	; 3   @45
      0  5055					      SLEEP	3	; @45
      1  5055				   .CYCLES    SET	3
      2  5055
      3  5055				  -	      IF	.CYCLES < 2
      4  5055				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5055				  -	      ERR
      6  5055					      ENDIF
      7  5055
      8  5055					      IF	.CYCLES & 1
      9  5055					      IFNCONST	NO_ILLEGAL_OPCODES
     10  5055		       04 00		      nop	0
     11  5057				  -	      ELSE
     12  5057				  -	      bit	VSYNC
     13  5057					      ENDIF
     14  5057				   .CYCLES    SET	.CYCLES - 3
     15  5057					      ENDIF
     16  5057
     17  5057				  -	      REPEAT	.CYCLES / 2
     18  5057				  -	      nop
     19  5057					      REPEND
     67  5057		       b9 da f3 	      lda	COL_5,y	; 5
     68  505a		       85 4f		      sta	PF2	; 3
     69  505c
     70  505c		       88		      dey		; 2
     71  505d		       ca		      dex		; 2
     72  505e		       d0 d5		      bne	triplet	; 2(3)
     73  5060
     74  5060		       c0 02		      cpy	#2	; 2
     75  5062		       d0 cf		      bne	SokoLogo	; 2(3)
     76  5064
     77  5064		       a9 00		      lda	#0
     78  5066		       85 4d		      sta	PF0
     79  5068		       85 4e		      sta	PF1
     80  506a		       85 4f		      sta	PF2
     81  506c
     82  506c		       a6 81		      ldx	Platform
     83  506e		       bd 8a f0 	      lda	OverscanTime2,x
     84  5071		       8d 96 02 	      sta	TIM64T
     85  5074
     86  5074
     87  5074
     88  5074
     89  5074		       ad 84 02    frame      lda	INTIM
     90  5077		       d0 fb		      bne	frame
     91  5079
     92  5079
     93  5079
     94  5079							;		ldy #63
     95  5079							;bot2		 sta WSYNC
     96  5079							;		dey
     97  5079							;		bpl bot2
     98  5079
     99  5079							;--------------------------------------------------------------------------
    100  5079
    101  5079							;		lda #0
    102  5079							;		sta PF0
    103  5079							;		sta PF1
    104  5079							;		sta PF2
    105  5079
    106  5079
    107  5079
    108  5079							; D1 VBLANK turns off beam
    109  5079							; It needs to be turned on 37 scanlines later
    110  5079
    111  5079		       ad 84 02    oscan      lda	INTIM
    112  507c		       d0 fb		      bne	oscan
    113  507e
    114  507e		       a9 42		      lda	#%01000010	; bit6 is not required
    115  5080		       85 41		      sta	VBLANK	; end of screen - enter blanking
    116  5082
    117  5082		       a5 4c		      lda	INPT4
    118  5084		       10 03		      bpl	ret
    119  5086
    120  5086		       4c 17 f0 	      jmp	RestartFrame
    121  5089
    122  5089		       60	   ret	      rts
    123  508a
    124  508a				   OverscanTime2
    125  508a		       86 86		      .byte.b	134, 134
    126  508c		       8e 8e		      .byte.b	142, 142
    127  508e
    128  508e							;
    129  508e
    130  508e
    131  508e				   colvec
    132  508e		       0a f1 92 f0	      .word.w	colr, colr_pal
    133  5092
    134  5092				   colr_pal
    135  5092					      REPEAT	40
    136  5092		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  5092					      REPEND
    136  5095		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  5095					      REPEND
    136  5098		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  5098					      REPEND
    136  509b		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  509b					      REPEND
    136  509e		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  509e					      REPEND
    136  50a1		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50a1					      REPEND
    136  50a4		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50a4					      REPEND
    136  50a7		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50a7					      REPEND
    136  50aa		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50aa					      REPEND
    136  50ad		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50ad					      REPEND
    136  50b0		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50b0					      REPEND
    136  50b3		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50b3					      REPEND
    136  50b6		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50b6					      REPEND
    136  50b9		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50b9					      REPEND
    136  50bc		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50bc					      REPEND
    136  50bf		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50bf					      REPEND
    136  50c2		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50c2					      REPEND
    136  50c5		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50c5					      REPEND
    136  50c8		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50c8					      REPEND
    136  50cb		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50cb					      REPEND
    136  50ce		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50ce					      REPEND
    136  50d1		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50d1					      REPEND
    136  50d4		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50d4					      REPEND
    136  50d7		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50d7					      REPEND
    136  50da		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50da					      REPEND
    136  50dd		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50dd					      REPEND
    136  50e0		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50e0					      REPEND
    136  50e3		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50e3					      REPEND
    136  50e6		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50e6					      REPEND
    136  50e9		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50e9					      REPEND
    136  50ec		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50ec					      REPEND
    136  50ef		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50ef					      REPEND
    136  50f2		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50f2					      REPEND
    136  50f5		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50f5					      REPEND
    136  50f8		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50f8					      REPEND
    136  50fb		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50fb					      REPEND
    136  50fe		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  50fe					      REPEND
    136  5101		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  5101					      REPEND
    136  5104		       3c 66 da 	      .byte.b	$3C,$66,$DA
    135  5104					      REPEND
    136  5107		       3c 66 da 	      .byte.b	$3C,$66,$DA
    137  510a					      REPEND
    138  510a
    139  510a				   colr
    140  510a					      REPEAT	40
    141  510a		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  510a					      REPEND
    141  510d		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  510d					      REPEND
    141  5110		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5110					      REPEND
    141  5113		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5113					      REPEND
    141  5116		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5116					      REPEND
    141  5119		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5119					      REPEND
    141  511c		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  511c					      REPEND
    141  511f		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  511f					      REPEND
    141  5122		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5122					      REPEND
    141  5125		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5125					      REPEND
    141  5128		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5128					      REPEND
    141  512b		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  512b					      REPEND
    141  512e		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  512e					      REPEND
    141  5131		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5131					      REPEND
    141  5134		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5134					      REPEND
    141  5137		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5137					      REPEND
    141  513a		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  513a					      REPEND
    141  513d		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  513d					      REPEND
    141  5140		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5140					      REPEND
    141  5143		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5143					      REPEND
    141  5146		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5146					      REPEND
    141  5149		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5149					      REPEND
    141  514c		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  514c					      REPEND
    141  514f		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  514f					      REPEND
    141  5152		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5152					      REPEND
    141  5155		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5155					      REPEND
    141  5158		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5158					      REPEND
    141  515b		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  515b					      REPEND
    141  515e		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  515e					      REPEND
    141  5161		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5161					      REPEND
    141  5164		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5164					      REPEND
    141  5167		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5167					      REPEND
    141  516a		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  516a					      REPEND
    141  516d		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  516d					      REPEND
    141  5170		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5170					      REPEND
    141  5173		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5173					      REPEND
    141  5176		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5176					      REPEND
    141  5179		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  5179					      REPEND
    141  517c		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    140  517c					      REPEND
    141  517f		       1c 34 8a 	      .byte.b	$1C, $34, $8A
    142  5182					      REPEND
    143  5182
    144  5182				  -	      if	0
    145  5182				  -colr
    146  5182				  -	      .byte	$C6,$74,$26
    147  5182				  -	      .byte	$C6,$74,$26
    148  5182				  -	      .byte	$C6,$74,$26
    149  5182				  -	      .byte	$C6,$74,$26
    150  5182				  -	      .byte	$C6,$74,$26
    151  5182				  -	      .byte	$96,$74,$26
    152  5182				  -	      .byte	$96,$74,$26
    153  5182				  -	      .byte	$96,$74,$26
    154  5182				  -	      .byte	$96,$74,$26
    155  5182				  -	      .byte	$96,$74,$26
    156  5182				  -
    157  5182				  -	      .byte	$CA,$74,$2A
    158  5182				  -	      .byte	$CA,$74,$2A
    159  5182				  -	      .byte	$CA,$74,$2A
    160  5182				  -	      .byte	$CA,$74,$2A
    161  5182				  -	      .byte	$CA,$74,$2A
    162  5182				  -	      .byte	$CA,$74,$2A
    163  5182				  -	      .byte	$CA,$74,$2A
    164  5182				  -	      .byte	$CA,$74,$2A
    165  5182				  -	      .byte	$CA,$74,$2A
    166  5182				  -	      .byte	$CA,$74,$2A
    167  5182				  -
    168  5182				  -	      .byte	$1A,$24,$2A
    169  5182				  -	      .byte	$1A,$24,$2A
    170  5182				  -	      .byte	$1A,$24,$2A
    171  5182				  -	      .byte	$1A,$24,$2A
    172  5182				  -	      .byte	$1A,$24,$2A
    173  5182				  -	      .byte	$AA,$24,$68
    174  5182				  -	      .byte	$AA,$24,$68
    175  5182				  -	      .byte	$AA,$24,$68
    176  5182				  -	      .byte	$AA,$24,$68
    177  5182				  -	      .byte	$AA,$24,$68
    178  5182				  -
    179  5182				  -	      .byte	$28,$74,$68
    180  5182				  -	      .byte	$28,$74,$68
    181  5182				  -	      .byte	$28,$74,$68
    182  5182				  -	      .byte	$28,$74,$68
    183  5182				  -	      .byte	$28,$74,$68
    184  5182				  -	      .byte	$28,$74,$4A
    185  5182				  -	      .byte	$28,$74,$4A
    186  5182				  -	      .byte	$28,$74,$4A
    187  5182				  -	      .byte	$28,$74,$4A
    188  5182				  -	      .byte	$28,$74,$4A
    189  5182					      endif
    190  5182
    191  5182							; created by /anaconda3/envs/Utils4/bin/python /Users/boo/Documents/2600/Utils4/grid.py
    192  5182				   COL_0
    193  5182		       80		      .byte.b	128	;R
    194  5183		       f0		      .byte.b	240	;G
    195  5184		       80		      .byte.b	128	;B
    196  5185		       80		      .byte.b	128	;R
    197  5186		       f0		      .byte.b	240	;G
    198  5187		       80		      .byte.b	128	;B
    199  5188		       80		      .byte.b	128	;R
    200  5189		       f0		      .byte.b	240	;G
    201  518a		       80		      .byte.b	128	;B
    202  518b		       00		      .byte.b	0	;R
    203  518c		       00		      .byte.b	0	;G
    204  518d		       00		      .byte.b	0	;B
    205  518e		       30		      .byte.b	48	;R
    206  518f		       40		      .byte.b	64	;G
    207  5190		       30		      .byte.b	48	;B
    208  5191		       30		      .byte.b	48	;R
    209  5192		       40		      .byte.b	64	;G
    210  5193		       30		      .byte.b	48	;B
    211  5194		       70		      .byte.b	112	;R
    212  5195		       80		      .byte.b	128	;G
    213  5196		       70		      .byte.b	112	;B
    214  5197		       70		      .byte.b	112	;R
    215  5198		       80		      .byte.b	128	;G
    216  5199		       70		      .byte.b	112	;B
    217  519a		       70		      .byte.b	112	;R
    218  519b		       80		      .byte.b	128	;G
    219  519c		       70		      .byte.b	112	;B
    220  519d		       c0		      .byte.b	192	;R
    221  519e		       00		      .byte.b	0	;G
    222  519f		       c0		      .byte.b	192	;B
    223  51a0		       c0		      .byte.b	192	;R
    224  51a1		       00		      .byte.b	0	;G
    225  51a2		       c0		      .byte.b	192	;B
    226  51a3		       c0		      .byte.b	192	;R
    227  51a4		       00		      .byte.b	0	;G
    228  51a5		       c0		      .byte.b	192	;B
    229  51a6		       c0		      .byte.b	192	;R
    230  51a7		       00		      .byte.b	0	;G
    231  51a8		       c0		      .byte.b	192	;B
    232  51a9		       c0		      .byte.b	192	;R
    233  51aa		       00		      .byte.b	0	;G
    234  51ab		       c0		      .byte.b	192	;B
    235  51ac		       c0		      .byte.b	192	;R
    236  51ad		       00		      .byte.b	0	;G
    237  51ae		       c0		      .byte.b	192	;B
    238  51af		       c0		      .byte.b	192	;R
    239  51b0		       00		      .byte.b	0	;G
    240  51b1		       c0		      .byte.b	192	;B
    241  51b2		       c0		      .byte.b	192	;R
    242  51b3		       00		      .byte.b	0	;G
    243  51b4		       c0		      .byte.b	192	;B
    244  51b5		       c0		      .byte.b	192	;R
    245  51b6		       00		      .byte.b	0	;G
    246  51b7		       c0		      .byte.b	192	;B
    247  51b8		       c0		      .byte.b	192	;R
    248  51b9		       00		      .byte.b	0	;G
    249  51ba		       c0		      .byte.b	192	;B
    250  51bb		       e0		      .byte.b	224	;R
    251  51bc		       00		      .byte.b	0	;G
    252  51bd		       e0		      .byte.b	224	;B
    253  51be		       e0		      .byte.b	224	;R
    254  51bf		       00		      .byte.b	0	;G
    255  51c0		       e0		      .byte.b	224	;B
    256  51c1		       70		      .byte.b	112	;R
    257  51c2		       80		      .byte.b	128	;G
    258  51c3		       70		      .byte.b	112	;B
    259  51c4		       10		      .byte.b	16	;R
    260  51c5		       20		      .byte.b	32	;G
    261  51c6		       10		      .byte.b	16	;B
    262  51c7		       10		      .byte.b	16	;R
    263  51c8		       20		      .byte.b	32	;G
    264  51c9		       10		      .byte.b	16	;B
    265  51ca		       10		      .byte.b	16	;R
    266  51cb		       20		      .byte.b	32	;G
    267  51cc		       10		      .byte.b	16	;B
    268  51cd		       10		      .byte.b	16	;R
    269  51ce		       20		      .byte.b	32	;G
    270  51cf		       10		      .byte.b	16	;B
    271  51d0		       10		      .byte.b	16	;R
    272  51d1		       20		      .byte.b	32	;G
    273  51d2		       10		      .byte.b	16	;B
    274  51d3		       30		      .byte.b	48	;R
    275  51d4		       40		      .byte.b	64	;G
    276  51d5		       30		      .byte.b	48	;B
    277  51d6		       30		      .byte.b	48	;R
    278  51d7		       40		      .byte.b	64	;G
    279  51d8		       30		      .byte.b	48	;B
    280  51d9		       30		      .byte.b	48	;R
    281  51da		       40		      .byte.b	64	;G
    282  51db		       30		      .byte.b	48	;B
    283  51dc		       30		      .byte.b	48	;R
    284  51dd		       c0		      .byte.b	192	;G
    285  51de		       30		      .byte.b	48	;B
    286  51df		       e0		      .byte.b	224	;R
    287  51e0		       00		      .byte.b	0	;G
    288  51e1		       e0		      .byte.b	224	;B
    289  51e2		       e0		      .byte.b	224	;R
    290  51e3		       00		      .byte.b	0	;G
    291  51e4		       e0		      .byte.b	224	;B
    292  51e5		       c0		      .byte.b	192	;R
    293  51e6		       00		      .byte.b	0	;G
    294  51e7		       c0		      .byte.b	192	;B
    295  51e8		       00		      .byte.b	0	;R
    296  51e9		       00		      .byte.b	0	;G
    297  51ea		       00		      .byte.b	0	;B
    298  51eb		       00		      .byte.b	0	;R
    299  51ec		       00		      .byte.b	0	;G
    300  51ed		       00		      .byte.b	0	;B
    301  51ee		       00		      .byte.b	0	;R
    302  51ef		       00		      .byte.b	0	;G
    303  51f0		       00		      .byte.b	0	;B
    304  51f1		       00		      .byte.b	0	;R
    305  51f2		       c0		      .byte.b	192	;G
    306  51f3		       00		      .byte.b	0	;B
    307  51f4		       00		      .byte.b	0	;R
    308  51f5		       c0		      .byte.b	192	;G
    309  51f6		       00		      .byte.b	0	;B
    310  51f7		       00		      .byte.b	0	;R
    311  51f8		       c0		      .byte.b	192	;G
    312  51f9		       00		      .byte.b	0	;B
    313  51fa				   COL_1
    314  51fa		       f8		      .byte.b	248	;R
    315  51fb		       c0		      .byte.b	192	;G
    316  51fc		       c7		      .byte.b	199	;B
    317  51fd		       f8		      .byte.b	248	;R
    318  51fe		       c0		      .byte.b	192	;G
    319  51ff		       c7		      .byte.b	199	;B
    320  5200		       f8		      .byte.b	248	;R
    321  5201		       c0		      .byte.b	192	;G
    322  5202		       c7		      .byte.b	199	;B
    323  5203		       00		      .byte.b	0	;R
    324  5204		       00		      .byte.b	0	;G
    325  5205		       00		      .byte.b	0	;B
    326  5206		       30		      .byte.b	48	;R
    327  5207		       09		      .byte.b	9	;G
    328  5208		       01		      .byte.b	1	;B
    329  5209		       30		      .byte.b	48	;R
    330  520a		       09		      .byte.b	9	;G
    331  520b		       01		      .byte.b	1	;B
    332  520c		       70		      .byte.b	112	;R
    333  520d		       09		      .byte.b	9	;G
    334  520e		       01		      .byte.b	1	;B
    335  520f		       78		      .byte.b	120	;R
    336  5210		       05		      .byte.b	5	;G
    337  5211		       01		      .byte.b	1	;B
    338  5212		       78		      .byte.b	120	;R
    339  5213		       05		      .byte.b	5	;G
    340  5214		       01		      .byte.b	1	;B
    341  5215		       78		      .byte.b	120	;R
    342  5216		       85		      .byte.b	133	;G
    343  5217		       01		      .byte.b	1	;B
    344  5218		       4c		      .byte.b	76	;R
    345  5219		       a3		      .byte.b	163	;G
    346  521a		       01		      .byte.b	1	;B
    347  521b		       4c		      .byte.b	76	;R
    348  521c		       a3		      .byte.b	163	;G
    349  521d		       01		      .byte.b	1	;B
    350  521e		       4c		      .byte.b	76	;R
    351  521f		       a3		      .byte.b	163	;G
    352  5220		       01		      .byte.b	1	;B
    353  5221		       44		      .byte.b	68	;R
    354  5222		       a3		      .byte.b	163	;G
    355  5223		       01		      .byte.b	1	;B
    356  5224		       44		      .byte.b	68	;R
    357  5225		       a3		      .byte.b	163	;G
    358  5226		       01		      .byte.b	1	;B
    359  5227		       44		      .byte.b	68	;R
    360  5228		       a3		      .byte.b	163	;G
    361  5229		       01		      .byte.b	1	;B
    362  522a		       44		      .byte.b	68	;R
    363  522b		       a3		      .byte.b	163	;G
    364  522c		       01		      .byte.b	1	;B
    365  522d		       44		      .byte.b	68	;R
    366  522e		       a3		      .byte.b	163	;G
    367  522f		       01		      .byte.b	1	;B
    368  5230		       44		      .byte.b	68	;R
    369  5231		       a3		      .byte.b	163	;G
    370  5232		       01		      .byte.b	1	;B
    371  5233		       44		      .byte.b	68	;R
    372  5234		       a3		      .byte.b	163	;G
    373  5235		       01		      .byte.b	1	;B
    374  5236		       44		      .byte.b	68	;R
    375  5237		       a3		      .byte.b	163	;G
    376  5238		       01		      .byte.b	1	;B
    377  5239		       44		      .byte.b	68	;R
    378  523a		       23		      .byte.b	35	;G
    379  523b		       01		      .byte.b	1	;B
    380  523c		       44		      .byte.b	68	;R
    381  523d		       23		      .byte.b	35	;G
    382  523e		       01		      .byte.b	1	;B
    383  523f		       44		      .byte.b	68	;R
    384  5240		       23		      .byte.b	35	;G
    385  5241		       01		      .byte.b	1	;B
    386  5242		       44		      .byte.b	68	;R
    387  5243		       23		      .byte.b	35	;G
    388  5244		       01		      .byte.b	1	;B
    389  5245		       44		      .byte.b	68	;R
    390  5246		       23		      .byte.b	35	;G
    391  5247		       01		      .byte.b	1	;B
    392  5248		       44		      .byte.b	68	;R
    393  5249		       23		      .byte.b	35	;G
    394  524a		       01		      .byte.b	1	;B
    395  524b		       64		      .byte.b	100	;R
    396  524c		       13		      .byte.b	19	;G
    397  524d		       01		      .byte.b	1	;B
    398  524e		       24		      .byte.b	36	;R
    399  524f		       13		      .byte.b	19	;G
    400  5250		       01		      .byte.b	1	;B
    401  5251		       24		      .byte.b	36	;R
    402  5252		       13		      .byte.b	19	;G
    403  5253		       01		      .byte.b	1	;B
    404  5254		       3c		      .byte.b	60	;R
    405  5255		       03		      .byte.b	3	;G
    406  5256		       01		      .byte.b	1	;B
    407  5257		       1c		      .byte.b	28	;R
    408  5258		       c3		      .byte.b	195	;G
    409  5259		       01		      .byte.b	1	;B
    410  525a		       dc		      .byte.b	220	;R
    411  525b		       23		      .byte.b	35	;G
    412  525c		       c1		      .byte.b	193	;B
    413  525d		       dc		      .byte.b	220	;R
    414  525e		       23		      .byte.b	35	;G
    415  525f		       c1		      .byte.b	193	;B
    416  5260		       cc		      .byte.b	204	;R
    417  5261		       23		      .byte.b	35	;G
    418  5262		       c1		      .byte.b	193	;B
    419  5263		       c8		      .byte.b	200	;R
    420  5264		       25		      .byte.b	37	;G
    421  5265		       c1		      .byte.b	193	;B
    422  5266		       00		      .byte.b	0	;R
    423  5267		       00		      .byte.b	0	;G
    424  5268		       00		      .byte.b	0	;B
    425  5269		       7e		      .byte.b	126	;R
    426  526a		       f0		      .byte.b	240	;G
    427  526b		       71		      .byte.b	113	;B
    428  526c		       7e		      .byte.b	126	;R
    429  526d		       f0		      .byte.b	240	;G
    430  526e		       71		      .byte.b	113	;B
    431  526f		       7e		      .byte.b	126	;R
    432  5270		       f0		      .byte.b	240	;G
    433  5271		       71		      .byte.b	113	;B
    434  5272				   COL_2
    435  5272		       3f		      .byte.b	63	;R
    436  5273		       c7		      .byte.b	199	;G
    437  5274		       f8		      .byte.b	248	;B
    438  5275		       3f		      .byte.b	63	;R
    439  5276		       c7		      .byte.b	199	;G
    440  5277		       f8		      .byte.b	248	;B
    441  5278		       3f		      .byte.b	63	;R
    442  5279		       c7		      .byte.b	199	;G
    443  527a		       f8		      .byte.b	248	;B
    444  527b		       00		      .byte.b	0	;R
    445  527c		       00		      .byte.b	0	;G
    446  527d		       00		      .byte.b	0	;B
    447  527e		       60		      .byte.b	96	;R
    448  527f		       fd		      .byte.b	253	;G
    449  5280		       0c		      .byte.b	12	;B
    450  5281		       60		      .byte.b	96	;R
    451  5282		       fd		      .byte.b	253	;G
    452  5283		       0c		      .byte.b	12	;B
    453  5284		       70		      .byte.b	112	;R
    454  5285		       fd		      .byte.b	253	;G
    455  5286		       04		      .byte.b	4	;B
    456  5287		       f0		      .byte.b	240	;R
    457  5288		       ff		      .byte.b	255	;G
    458  5289		       06		      .byte.b	6	;B
    459  528a		       f0		      .byte.b	240	;R
    460  528b		       ff		      .byte.b	255	;G
    461  528c		       06		      .byte.b	6	;B
    462  528d		       f0		      .byte.b	240	;R
    463  528e		       ff		      .byte.b	255	;G
    464  528f		       06		      .byte.b	6	;B
    465  5290		       90		      .byte.b	144	;R
    466  5291		       bf		      .byte.b	191	;G
    467  5292		       07		      .byte.b	7	;B
    468  5293		       90		      .byte.b	144	;R
    469  5294		       bf		      .byte.b	191	;G
    470  5295		       07		      .byte.b	7	;B
    471  5296		       90		      .byte.b	144	;R
    472  5297		       bf		      .byte.b	191	;G
    473  5298		       07		      .byte.b	7	;B
    474  5299		       10		      .byte.b	16	;R
    475  529a		       37		      .byte.b	55	;G
    476  529b		       03		      .byte.b	3	;B
    477  529c		       10		      .byte.b	16	;R
    478  529d		       37		      .byte.b	55	;G
    479  529e		       03		      .byte.b	3	;B
    480  529f		       10		      .byte.b	16	;R
    481  52a0		       37		      .byte.b	55	;G
    482  52a1		       03		      .byte.b	3	;B
    483  52a2		       10		      .byte.b	16	;R
    484  52a3		       33		      .byte.b	51	;G
    485  52a4		       01		      .byte.b	1	;B
    486  52a5		       10		      .byte.b	16	;R
    487  52a6		       33		      .byte.b	51	;G
    488  52a7		       01		      .byte.b	1	;B
    489  52a8		       10		      .byte.b	16	;R
    490  52a9		       37		      .byte.b	55	;G
    491  52aa		       03		      .byte.b	3	;B
    492  52ab		       10		      .byte.b	16	;R
    493  52ac		       37		      .byte.b	55	;G
    494  52ad		       03		      .byte.b	3	;B
    495  52ae		       10		      .byte.b	16	;R
    496  52af		       37		      .byte.b	55	;G
    497  52b0		       03		      .byte.b	3	;B
    498  52b1		       10		      .byte.b	16	;R
    499  52b2		       3f		      .byte.b	63	;G
    500  52b3		       03		      .byte.b	3	;B
    501  52b4		       10		      .byte.b	16	;R
    502  52b5		       3f		      .byte.b	63	;G
    503  52b6		       07		      .byte.b	7	;B
    504  52b7		       10		      .byte.b	16	;R
    505  52b8		       3f		      .byte.b	63	;G
    506  52b9		       07		      .byte.b	7	;B
    507  52ba		       10		      .byte.b	16	;R
    508  52bb		       3f		      .byte.b	63	;G
    509  52bc		       06		      .byte.b	6	;B
    510  52bd		       10		      .byte.b	16	;R
    511  52be		       3f		      .byte.b	63	;G
    512  52bf		       06		      .byte.b	6	;B
    513  52c0		       10		      .byte.b	16	;R
    514  52c1		       3f		      .byte.b	63	;G
    515  52c2		       06		      .byte.b	6	;B
    516  52c3		       30		      .byte.b	48	;R
    517  52c4		       7d		      .byte.b	125	;G
    518  52c5		       04		      .byte.b	4	;B
    519  52c6		       20		      .byte.b	32	;R
    520  52c7		       6d		      .byte.b	109	;G
    521  52c8		       04		      .byte.b	4	;B
    522  52c9		       20		      .byte.b	32	;R
    523  52ca		       6d		      .byte.b	109	;G
    524  52cb		       04		      .byte.b	4	;B
    525  52cc		       e0		      .byte.b	224	;R
    526  52cd		       ed		      .byte.b	237	;G
    527  52ce		       04		      .byte.b	4	;B
    528  52cf		       c0		      .byte.b	192	;R
    529  52d0		       dd		      .byte.b	221	;G
    530  52d1		       0c		      .byte.b	12	;B
    531  52d2		       c0		      .byte.b	192	;R
    532  52d3		       dd		      .byte.b	221	;G
    533  52d4		       0c		      .byte.b	12	;B
    534  52d5		       c0		      .byte.b	192	;R
    535  52d6		       dd		      .byte.b	221	;G
    536  52d7		       0c		      .byte.b	12	;B
    537  52d8		       80		      .byte.b	128	;R
    538  52d9		       9d		      .byte.b	157	;G
    539  52da		       0c		      .byte.b	12	;B
    540  52db		       80		      .byte.b	128	;R
    541  52dc		       9d		      .byte.b	157	;G
    542  52dd		       0c		      .byte.b	12	;B
    543  52de		       00		      .byte.b	0	;R
    544  52df		       00		      .byte.b	0	;G
    545  52e0		       00		      .byte.b	0	;B
    546  52e1		       fc		      .byte.b	252	;R
    547  52e2		       1c		      .byte.b	28	;G
    548  52e3		       e3		      .byte.b	227	;B
    549  52e4		       fc		      .byte.b	252	;R
    550  52e5		       1c		      .byte.b	28	;G
    551  52e6		       e3		      .byte.b	227	;B
    552  52e7		       fc		      .byte.b	252	;R
    553  52e8		       1c		      .byte.b	28	;G
    554  52e9		       e3		      .byte.b	227	;B
    555  52ea				   COL_3
    556  52ea		       00		      .byte.b	0	;R
    557  52eb		       10		      .byte.b	16	;G
    558  52ec		       10		      .byte.b	16	;B
    559  52ed		       00		      .byte.b	0	;R
    560  52ee		       10		      .byte.b	16	;G
    561  52ef		       10		      .byte.b	16	;B
    562  52f0		       00		      .byte.b	0	;R
    563  52f1		       10		      .byte.b	16	;G
    564  52f2		       10		      .byte.b	16	;B
    565  52f3		       00		      .byte.b	0	;R
    566  52f4		       00		      .byte.b	0	;G
    567  52f5		       00		      .byte.b	0	;B
    568  52f6		       c0		      .byte.b	192	;R
    569  52f7		       c0		      .byte.b	192	;G
    570  52f8		       c0		      .byte.b	192	;B
    571  52f9		       c0		      .byte.b	192	;R
    572  52fa		       c0		      .byte.b	192	;G
    573  52fb		       c0		      .byte.b	192	;B
    574  52fc		       c0		      .byte.b	192	;R
    575  52fd		       c0		      .byte.b	192	;G
    576  52fe		       c0		      .byte.b	192	;B
    577  52ff		       c0		      .byte.b	192	;R
    578  5300		       d0		      .byte.b	208	;G
    579  5301		       c0		      .byte.b	192	;B
    580  5302		       c0		      .byte.b	192	;R
    581  5303		       d0		      .byte.b	208	;G
    582  5304		       c0		      .byte.b	192	;B
    583  5305		       c0		      .byte.b	192	;R
    584  5306		       d0		      .byte.b	208	;G
    585  5307		       c0		      .byte.b	192	;B
    586  5308		       50		      .byte.b	80	;R
    587  5309		       f0		      .byte.b	240	;G
    588  530a		       40		      .byte.b	64	;B
    589  530b		       50		      .byte.b	80	;R
    590  530c		       f0		      .byte.b	240	;G
    591  530d		       40		      .byte.b	64	;B
    592  530e		       50		      .byte.b	80	;R
    593  530f		       f0		      .byte.b	240	;G
    594  5310		       40		      .byte.b	64	;B
    595  5311		       50		      .byte.b	80	;R
    596  5312		       f0		      .byte.b	240	;G
    597  5313		       40		      .byte.b	64	;B
    598  5314		       50		      .byte.b	80	;R
    599  5315		       f0		      .byte.b	240	;G
    600  5316		       40		      .byte.b	64	;B
    601  5317		       50		      .byte.b	80	;R
    602  5318		       f0		      .byte.b	240	;G
    603  5319		       40		      .byte.b	64	;B
    604  531a		       d0		      .byte.b	208	;R
    605  531b		       f0		      .byte.b	240	;G
    606  531c		       c0		      .byte.b	192	;B
    607  531d		       d0		      .byte.b	208	;R
    608  531e		       f0		      .byte.b	240	;G
    609  531f		       c0		      .byte.b	192	;B
    610  5320		       d0		      .byte.b	208	;R
    611  5321		       f0		      .byte.b	240	;G
    612  5322		       c0		      .byte.b	192	;B
    613  5323		       d0		      .byte.b	208	;R
    614  5324		       f0		      .byte.b	240	;G
    615  5325		       c0		      .byte.b	192	;B
    616  5326		       d0		      .byte.b	208	;R
    617  5327		       f0		      .byte.b	240	;G
    618  5328		       c0		      .byte.b	192	;B
    619  5329		       d0		      .byte.b	208	;R
    620  532a		       f0		      .byte.b	240	;G
    621  532b		       c0		      .byte.b	192	;B
    622  532c		       50		      .byte.b	80	;R
    623  532d		       f0		      .byte.b	240	;G
    624  532e		       40		      .byte.b	64	;B
    625  532f		       50		      .byte.b	80	;R
    626  5330		       f0		      .byte.b	240	;G
    627  5331		       40		      .byte.b	64	;B
    628  5332		       50		      .byte.b	80	;R
    629  5333		       f0		      .byte.b	240	;G
    630  5334		       40		      .byte.b	64	;B
    631  5335		       50		      .byte.b	80	;R
    632  5336		       f0		      .byte.b	240	;G
    633  5337		       40		      .byte.b	64	;B
    634  5338		       50		      .byte.b	80	;R
    635  5339		       f0		      .byte.b	240	;G
    636  533a		       40		      .byte.b	64	;B
    637  533b		       50		      .byte.b	80	;R
    638  533c		       f0		      .byte.b	240	;G
    639  533d		       40		      .byte.b	64	;B
    640  533e		       50		      .byte.b	80	;R
    641  533f		       f0		      .byte.b	240	;G
    642  5340		       40		      .byte.b	64	;B
    643  5341		       50		      .byte.b	80	;R
    644  5342		       f0		      .byte.b	240	;G
    645  5343		       40		      .byte.b	64	;B
    646  5344		       d0		      .byte.b	208	;R
    647  5345		       f0		      .byte.b	240	;G
    648  5346		       c0		      .byte.b	192	;B
    649  5347		       d0		      .byte.b	208	;R
    650  5348		       f0		      .byte.b	240	;G
    651  5349		       c0		      .byte.b	192	;B
    652  534a		       d0		      .byte.b	208	;R
    653  534b		       f0		      .byte.b	240	;G
    654  534c		       c0		      .byte.b	192	;B
    655  534d		       d0		      .byte.b	208	;R
    656  534e		       f0		      .byte.b	240	;G
    657  534f		       c0		      .byte.b	192	;B
    658  5350		       d0		      .byte.b	208	;R
    659  5351		       f0		      .byte.b	240	;G
    660  5352		       c0		      .byte.b	192	;B
    661  5353		       c0		      .byte.b	192	;R
    662  5354		       d0		      .byte.b	208	;G
    663  5355		       c0		      .byte.b	192	;B
    664  5356		       00		      .byte.b	0	;R
    665  5357		       00		      .byte.b	0	;G
    666  5358		       00		      .byte.b	0	;B
    667  5359		       00		      .byte.b	0	;R
    668  535a		       70		      .byte.b	112	;G
    669  535b		       70		      .byte.b	112	;B
    670  535c		       00		      .byte.b	0	;R
    671  535d		       70		      .byte.b	112	;G
    672  535e		       70		      .byte.b	112	;B
    673  535f		       00		      .byte.b	0	;R
    674  5360		       70		      .byte.b	112	;G
    675  5361		       70		      .byte.b	112	;B
    676  5362				   COL_4
    677  5362		       1f		      .byte.b	31	;R
    678  5363		       fc		      .byte.b	252	;G
    679  5364		       1c		      .byte.b	28	;B
    680  5365		       1f		      .byte.b	31	;R
    681  5366		       fc		      .byte.b	252	;G
    682  5367		       1c		      .byte.b	28	;B
    683  5368		       1f		      .byte.b	31	;R
    684  5369		       fc		      .byte.b	252	;G
    685  536a		       1c		      .byte.b	28	;B
    686  536b		       00		      .byte.b	0	;R
    687  536c		       00		      .byte.b	0	;G
    688  536d		       00		      .byte.b	0	;B
    689  536e		       80		      .byte.b	128	;R
    690  536f		       c1		      .byte.b	193	;G
    691  5370		       86		      .byte.b	134	;B
    692  5371		       80		      .byte.b	128	;R
    693  5372		       c1		      .byte.b	193	;G
    694  5373		       86		      .byte.b	134	;B
    695  5374		       c0		      .byte.b	192	;R
    696  5375		       e1		      .byte.b	225	;G
    697  5376		       ce		      .byte.b	206	;B
    698  5377		       e0		      .byte.b	224	;R
    699  5378		       f0		      .byte.b	240	;G
    700  5379		       ef		      .byte.b	239	;B
    701  537a		       e0		      .byte.b	224	;R
    702  537b		       f0		      .byte.b	240	;G
    703  537c		       ef		      .byte.b	239	;B
    704  537d		       e0		      .byte.b	224	;R
    705  537e		       f0		      .byte.b	240	;G
    706  537f		       ef		      .byte.b	239	;B
    707  5380		       20		      .byte.b	32	;R
    708  5381		       34		      .byte.b	52	;G
    709  5382		       29		      .byte.b	41	;B
    710  5383		       20		      .byte.b	32	;R
    711  5384		       34		      .byte.b	52	;G
    712  5385		       29		      .byte.b	41	;B
    713  5386		       20		      .byte.b	32	;R
    714  5387		       34		      .byte.b	52	;G
    715  5388		       29		      .byte.b	41	;B
    716  5389		       60		      .byte.b	96	;R
    717  538a		       74		      .byte.b	116	;G
    718  538b		       68		      .byte.b	104	;B
    719  538c		       60		      .byte.b	96	;R
    720  538d		       74		      .byte.b	116	;G
    721  538e		       68		      .byte.b	104	;B
    722  538f		       60		      .byte.b	96	;R
    723  5390		       74		      .byte.b	116	;G
    724  5391		       68		      .byte.b	104	;B
    725  5392		       e0		      .byte.b	224	;R
    726  5393		       f4		      .byte.b	244	;G
    727  5394		       e8		      .byte.b	232	;B
    728  5395		       e0		      .byte.b	224	;R
    729  5396		       f4		      .byte.b	244	;G
    730  5397		       e8		      .byte.b	232	;B
    731  5398		       c0		      .byte.b	192	;R
    732  5399		       e4		      .byte.b	228	;G
    733  539a		       c8		      .byte.b	200	;B
    734  539b		       c0		      .byte.b	192	;R
    735  539c		       e4		      .byte.b	228	;G
    736  539d		       c8		      .byte.b	200	;B
    737  539e		       c0		      .byte.b	192	;R
    738  539f		       e4		      .byte.b	228	;G
    739  53a0		       c8		      .byte.b	200	;B
    740  53a1		       c0		      .byte.b	192	;R
    741  53a2		       e4		      .byte.b	228	;G
    742  53a3		       c8		      .byte.b	200	;B
    743  53a4		       20		      .byte.b	32	;R
    744  53a5		       34		      .byte.b	52	;G
    745  53a6		       28		      .byte.b	40	;B
    746  53a7		       20		      .byte.b	32	;R
    747  53a8		       34		      .byte.b	52	;G
    748  53a9		       28		      .byte.b	40	;B
    749  53aa		       20		      .byte.b	32	;R
    750  53ab		       34		      .byte.b	52	;G
    751  53ac		       28		      .byte.b	40	;B
    752  53ad		       20		      .byte.b	32	;R
    753  53ae		       34		      .byte.b	52	;G
    754  53af		       28		      .byte.b	40	;B
    755  53b0		       20		      .byte.b	32	;R
    756  53b1		       34		      .byte.b	52	;G
    757  53b2		       28		      .byte.b	40	;B
    758  53b3		       60		      .byte.b	96	;R
    759  53b4		       72		      .byte.b	114	;G
    760  53b5		       6c		      .byte.b	108	;B
    761  53b6		       60		      .byte.b	96	;R
    762  53b7		       72		      .byte.b	114	;G
    763  53b8		       64		      .byte.b	100	;B
    764  53b9		       60		      .byte.b	96	;R
    765  53ba		       72		      .byte.b	114	;G
    766  53bb		       64		      .byte.b	100	;B
    767  53bc		       e0		      .byte.b	224	;R
    768  53bd		       f0		      .byte.b	240	;G
    769  53be		       e7		      .byte.b	231	;B
    770  53bf		       c0		      .byte.b	192	;R
    771  53c0		       e0		      .byte.b	224	;G
    772  53c1		       c3		      .byte.b	195	;B
    773  53c2		       c0		      .byte.b	192	;R
    774  53c3		       e0		      .byte.b	224	;G
    775  53c4		       c3		      .byte.b	195	;B
    776  53c5		       c0		      .byte.b	192	;R
    777  53c6		       e0		      .byte.b	224	;G
    778  53c7		       c3		      .byte.b	195	;B
    779  53c8		       80		      .byte.b	128	;R
    780  53c9		       c0		      .byte.b	192	;G
    781  53ca		       81		      .byte.b	129	;B
    782  53cb		       80		      .byte.b	128	;R
    783  53cc		       c0		      .byte.b	192	;G
    784  53cd		       81		      .byte.b	129	;B
    785  53ce		       00		      .byte.b	0	;R
    786  53cf		       00		      .byte.b	0	;G
    787  53d0		       00		      .byte.b	0	;B
    788  53d1		       07		      .byte.b	7	;R
    789  53d2		       3f		      .byte.b	63	;G
    790  53d3		       07		      .byte.b	7	;B
    791  53d4		       07		      .byte.b	7	;R
    792  53d5		       3f		      .byte.b	63	;G
    793  53d6		       07		      .byte.b	7	;B
    794  53d7		       07		      .byte.b	7	;R
    795  53d8		       3f		      .byte.b	63	;G
    796  53d9		       07		      .byte.b	7	;B
    797  53da				   COL_5
    798  53da		       f1		      .byte.b	241	;R
    799  53db		       70		      .byte.b	112	;G
    800  53dc		       8e		      .byte.b	142	;B
    801  53dd		       f1		      .byte.b	241	;R
    802  53de		       70		      .byte.b	112	;G
    803  53df		       8e		      .byte.b	142	;B
    804  53e0		       f1		      .byte.b	241	;R
    805  53e1		       70		      .byte.b	112	;G
    806  53e2		       8e		      .byte.b	142	;B
    807  53e3		       00		      .byte.b	0	;R
    808  53e4		       00		      .byte.b	0	;G
    809  53e5		       00		      .byte.b	0	;B
    810  53e6		       18		      .byte.b	24	;R
    811  53e7		       20		      .byte.b	32	;G
    812  53e8		       18		      .byte.b	24	;B
    813  53e9		       18		      .byte.b	24	;R
    814  53ea		       20		      .byte.b	32	;G
    815  53eb		       18		      .byte.b	24	;B
    816  53ec		       1c		      .byte.b	28	;R
    817  53ed		       20		      .byte.b	32	;G
    818  53ee		       1c		      .byte.b	28	;B
    819  53ef		       3c		      .byte.b	60	;R
    820  53f0		       41		      .byte.b	65	;G
    821  53f1		       3c		      .byte.b	60	;B
    822  53f2		       3c		      .byte.b	60	;R
    823  53f3		       41		      .byte.b	65	;G
    824  53f4		       3c		      .byte.b	60	;B
    825  53f5		       3c		      .byte.b	60	;R
    826  53f6		       41		      .byte.b	65	;G
    827  53f7		       3c		      .byte.b	60	;B
    828  53f8		       64		      .byte.b	100	;R
    829  53f9		       8a		      .byte.b	138	;G
    830  53fa		       65		      .byte.b	101	;B
    831  53fb		       64		      .byte.b	100	;R
    832  53fc		       8a		      .byte.b	138	;G
    833  53fd		       65		      .byte.b	101	;B
    834  53fe		       64		      .byte.b	100	;R
    835  53ff		       8a		      .byte.b	138	;G
    836  5400		       65		      .byte.b	101	;B
    837  5401		       44		      .byte.b	68	;R
    838  5402		       8a		      .byte.b	138	;G
    839  5403		       45		      .byte.b	69	;B
    840  5404		       44		      .byte.b	68	;R
    841  5405		       8a		      .byte.b	138	;G
    842  5406		       45		      .byte.b	69	;B
    843  5407		       44		      .byte.b	68	;R
    844  5408		       8a		      .byte.b	138	;G
    845  5409		       45		      .byte.b	69	;B
    846  540a		       44		      .byte.b	68	;R
    847  540b		       8a		      .byte.b	138	;G
    848  540c		       45		      .byte.b	69	;B
    849  540d		       44		      .byte.b	68	;R
    850  540e		       8a		      .byte.b	138	;G
    851  540f		       45		      .byte.b	69	;B
    852  5410		       44		      .byte.b	68	;R
    853  5411		       8a		      .byte.b	138	;G
    854  5412		       45		      .byte.b	69	;B
    855  5413		       44		      .byte.b	68	;R
    856  5414		       8a		      .byte.b	138	;G
    857  5415		       45		      .byte.b	69	;B
    858  5416		       44		      .byte.b	68	;R
    859  5417		       8a		      .byte.b	138	;G
    860  5418		       45		      .byte.b	69	;B
    861  5419		       44		      .byte.b	68	;R
    862  541a		       8a		      .byte.b	138	;G
    863  541b		       45		      .byte.b	69	;B
    864  541c		       44		      .byte.b	68	;R
    865  541d		       8a		      .byte.b	138	;G
    866  541e		       45		      .byte.b	69	;B
    867  541f		       44		      .byte.b	68	;R
    868  5420		       8a		      .byte.b	138	;G
    869  5421		       45		      .byte.b	69	;B
    870  5422		       44		      .byte.b	68	;R
    871  5423		       8a		      .byte.b	138	;G
    872  5424		       45		      .byte.b	69	;B
    873  5425		       44		      .byte.b	68	;R
    874  5426		       8a		      .byte.b	138	;G
    875  5427		       45		      .byte.b	69	;B
    876  5428		       44		      .byte.b	68	;R
    877  5429		       8a		      .byte.b	138	;G
    878  542a		       45		      .byte.b	69	;B
    879  542b		       4c		      .byte.b	76	;R
    880  542c		       92		      .byte.b	146	;G
    881  542d		       4d		      .byte.b	77	;B
    882  542e		       48		      .byte.b	72	;R
    883  542f		       92		      .byte.b	146	;G
    884  5430		       49		      .byte.b	73	;B
    885  5431		       48		      .byte.b	72	;R
    886  5432		       92		      .byte.b	146	;G
    887  5433		       49		      .byte.b	73	;B
    888  5434		       78		      .byte.b	120	;R
    889  5435		       82		      .byte.b	130	;G
    890  5436		       79		      .byte.b	121	;B
    891  5437		       70		      .byte.b	112	;R
    892  5438		       82		      .byte.b	130	;G
    893  5439		       71		      .byte.b	113	;B
    894  543a		       70		      .byte.b	112	;R
    895  543b		       82		      .byte.b	130	;G
    896  543c		       71		      .byte.b	113	;B
    897  543d		       70		      .byte.b	112	;R
    898  543e		       82		      .byte.b	130	;G
    899  543f		       71		      .byte.b	113	;B
    900  5440		       60		      .byte.b	96	;R
    901  5441		       82		      .byte.b	130	;G
    902  5442		       61		      .byte.b	97	;B
    903  5443		       20		      .byte.b	32	;R
    904  5444		       41		      .byte.b	65	;G
    905  5445		       20		      .byte.b	32	;B
    906  5446		       00		      .byte.b	0	;R
    907  5447		       00		      .byte.b	0	;G
    908  5448		       00		      .byte.b	0	;B
    909  5449		       c7		      .byte.b	199	;R
    910  544a		       c0		      .byte.b	192	;G
    911  544b		       38		      .byte.b	56	;B
    912  544c		       c7		      .byte.b	199	;R
    913  544d		       c0		      .byte.b	192	;G
    914  544e		       38		      .byte.b	56	;B
    915  544f		       c7		      .byte.b	199	;R
    916  5450		       c0		      .byte.b	192	;G
    917  5451		       38		      .byte.b	56	;B
    918  5452
    919  5452
      0  5452					      CHECK_BANK_SIZE	"INITBANK"
      1  5452		       04 52	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $452 , FREE= $3ae
      2  5452					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5452				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5452				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5452				  -	      ERR
      6  5452					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 4
      0  5452					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  5452							;    Sokoboo - a Sokoban implementation
      2  5452							;    using a generic tile-based display engine for the Atari 2600
      3  5452							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  5452							;
      5  5452							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  5452							;
      7  5452							;    Code related to the generic tile-based display engine was developed by
      8  5452							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  5452							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  5452							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  5452							;
     12  5452							;    Code related to music and sound effects uses the TIATracker music player
     13  5452							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  5452							;    directory for Apache licensing details.
     15  5452							;
     16  5452							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  5452							;    See the copyright notices in the License directory for a list of level
     18  5452							;    contributors.
     19  5452							;
     20  5452							;    Except where otherwise indicated, this software is released under the
     21  5452							;    following licensing arrangement...
     22  5452							;
     23  5452							;    This program is free software: you can redistribute it and/or modify
     24  5452							;    it under the terms of the GNU General Public License as published by
     25  5452							;    the Free Software Foundation, either version 3 of the License, or
     26  5452							;    (at your option) any later version.
     27  5452							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  5452
     29  5452							;    This program is distributed in the hope that it will be useful,
     30  5452							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  5452							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  5452							;    GNU General Public License for more details.
     33  5452
      0  5452					      NEWBANK	INITBANK
      1  5b03 ????				      SEG	INITBANK
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   INITBANK   SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	INITBANK
     35  5800
     36  5800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  5801
      0  5801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  5801		       00 0b	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  5801					      SUBROUTINE
      3  5801				   BoardLineStartLO
     39  5801
     40  5801							; Gives the start address (LO) of each board line
     41  5801					      if	1
     42  5801				   .BOARD_LOCATION SET	Board
     43  5801					      REPEAT	SIZE_BOARD_Y
     44  5801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5801					      ENDIF
     47  5801		       00		      .byte.b	<.BOARD_LOCATION
     48  5801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5801					      REPEND
     44  5802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5802					      ENDIF
     47  5802		       28		      .byte.b	<.BOARD_LOCATION
     48  5802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5802					      REPEND
     44  5803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5803					      ENDIF
     47  5803		       50		      .byte.b	<.BOARD_LOCATION
     48  5803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5803					      REPEND
     44  5804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5804					      ENDIF
     47  5804		       78		      .byte.b	<.BOARD_LOCATION
     48  5804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5804					      REPEND
     44  5805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5805					      ENDIF
     47  5805		       a0		      .byte.b	<.BOARD_LOCATION
     48  5805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5805					      REPEND
     44  5806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5806					      ENDIF
     47  5806		       c8		      .byte.b	<.BOARD_LOCATION
     48  5806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5806					      REPEND
     44  5807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5807					      ENDIF
     47  5807		       00		      .byte.b	<.BOARD_LOCATION
     48  5807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5807					      REPEND
     44  5808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5808					      ENDIF
     47  5808		       28		      .byte.b	<.BOARD_LOCATION
     48  5808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5808					      REPEND
     44  5809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5809					      ENDIF
     47  5809		       50		      .byte.b	<.BOARD_LOCATION
     48  5809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5809					      REPEND
     44  580a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580a					      ENDIF
     47  580a		       78		      .byte.b	<.BOARD_LOCATION
     48  580a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580a					      REPEND
     44  580b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580b					      ENDIF
     47  580b		       a0		      .byte.b	<.BOARD_LOCATION
     48  580b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580b					      REPEND
     44  580c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580c					      ENDIF
     47  580c		       c8		      .byte.b	<.BOARD_LOCATION
     48  580c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580c					      REPEND
     44  580d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580d					      ENDIF
     47  580d		       00		      .byte.b	<.BOARD_LOCATION
     48  580d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580d					      REPEND
     44  580e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580e					      ENDIF
     47  580e		       28		      .byte.b	<.BOARD_LOCATION
     48  580e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580e					      REPEND
     44  580f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580f					      ENDIF
     47  580f		       50		      .byte.b	<.BOARD_LOCATION
     48  580f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580f					      REPEND
     44  5810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5810					      ENDIF
     47  5810		       78		      .byte.b	<.BOARD_LOCATION
     48  5810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5810					      REPEND
     44  5811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5811					      ENDIF
     47  5811		       a0		      .byte.b	<.BOARD_LOCATION
     48  5811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5811					      REPEND
     44  5812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5812					      ENDIF
     47  5812		       c8		      .byte.b	<.BOARD_LOCATION
     48  5812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5812					      REPEND
     44  5813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5813					      ENDIF
     47  5813		       00		      .byte.b	<.BOARD_LOCATION
     48  5813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5813					      REPEND
     44  5814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5814					      ENDIF
     47  5814		       28		      .byte.b	<.BOARD_LOCATION
     48  5814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5814					      REPEND
     44  5815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5815					      ENDIF
     47  5815		       50		      .byte.b	<.BOARD_LOCATION
     48  5815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5815					      REPEND
     44  5816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5816					      ENDIF
     47  5816		       78		      .byte.b	<.BOARD_LOCATION
     48  5816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  5817					      REPEND
      0  5817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  5817					      LIST	ON
     51  5817
     52  5817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  5817					      endif
     54  5817
     55  5817							;------------------------------------------------------------------------------
     56  5817
     57  5817				   BoardLineStartHiR
     58  5817
     59  5817							; Gives the start address (HI) of each board line
     60  5817							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  5817							; the board overlays multiple banks!
     62  5817
     63  5817				   .BOARD_LOCATION SET	Board
     64  5817					      REPEAT	SIZE_BOARD_Y
     65  5817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5817					      ENDIF
     68  5817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5817					      REPEND
     65  5818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5818					      ENDIF
     68  5818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5818					      REPEND
     65  5819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5819					      ENDIF
     68  5819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5819					      REPEND
     65  581a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581a					      ENDIF
     68  581a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581a					      REPEND
     65  581b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581b					      ENDIF
     68  581b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581b					      REPEND
     65  581c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581c					      ENDIF
     68  581c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581c					      REPEND
     65  581d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581d					      ENDIF
     68  581d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581d					      REPEND
     65  581e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581e					      ENDIF
     68  581e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581e					      REPEND
     65  581f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581f					      ENDIF
     68  581f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581f					      REPEND
     65  5820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5820					      ENDIF
     68  5820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5820					      REPEND
     65  5821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5821					      ENDIF
     68  5821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5821					      REPEND
     65  5822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5822					      ENDIF
     68  5822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5822					      REPEND
     65  5823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5823					      ENDIF
     68  5823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5823					      REPEND
     65  5824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5824					      ENDIF
     68  5824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5824					      REPEND
     65  5825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5825					      ENDIF
     68  5825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5825					      REPEND
     65  5826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5826					      ENDIF
     68  5826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5826					      REPEND
     65  5827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5827					      ENDIF
     68  5827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5827					      REPEND
     65  5828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5828					      ENDIF
     68  5828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5828					      REPEND
     65  5829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5829					      ENDIF
     68  5829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5829					      REPEND
     65  582a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  582a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  582a					      ENDIF
     68  582a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  582a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  582a					      REPEND
     65  582b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  582b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  582b					      ENDIF
     68  582b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  582b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  582b					      REPEND
     65  582c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  582c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  582c					      ENDIF
     68  582c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  582c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  582d					      REPEND
      0  582d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  582d					      LIST	ON
     72  582d							;------------------------------------------------------------------------------
     73  582d
     74  582d				   BoardLineStartHiW
     75  582d
     76  582d							; Gives the start address (HI) of each board line
     77  582d							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  582d							; the board overlays multiple banks!
     79  582d
     80  582d				   .BOARD_LOCATION SET	Board
     81  582d					      REPEAT	SIZE_BOARD_Y
     82  582d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  582d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  582d					      ENDIF
     85  582d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  582d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  582d					      REPEND
     82  582e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  582e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  582e					      ENDIF
     85  582e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  582e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  582e					      REPEND
     82  582f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  582f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  582f					      ENDIF
     85  582f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  582f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  582f					      REPEND
     82  5830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5830					      ENDIF
     85  5830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5830					      REPEND
     82  5831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5831					      ENDIF
     85  5831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5831					      REPEND
     82  5832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5832					      ENDIF
     85  5832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5832					      REPEND
     82  5833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5833					      ENDIF
     85  5833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5833					      REPEND
     82  5834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5834					      ENDIF
     85  5834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5834					      REPEND
     82  5835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5835					      ENDIF
     85  5835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5835					      REPEND
     82  5836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5836					      ENDIF
     85  5836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5836					      REPEND
     82  5837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5837					      ENDIF
     85  5837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5837					      REPEND
     82  5838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5838					      ENDIF
     85  5838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5838					      REPEND
     82  5839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5839					      ENDIF
     85  5839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5839					      REPEND
     82  583a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583a					      ENDIF
     85  583a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583a					      REPEND
     82  583b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583b					      ENDIF
     85  583b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583b					      REPEND
     82  583c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583c					      ENDIF
     85  583c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583c					      REPEND
     82  583d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583d					      ENDIF
     85  583d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583d					      REPEND
     82  583e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583e					      ENDIF
     85  583e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583e					      REPEND
     82  583f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583f					      ENDIF
     85  583f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583f					      REPEND
     82  5840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5840					      ENDIF
     85  5840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5840					      REPEND
     82  5841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5841					      ENDIF
     85  5841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5841					      REPEND
     82  5842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5842					      ENDIF
     85  5842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  5843					      REPEND
      0  5843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  5843					      LIST	ON
     89  5843
     90  5843							;------------------------------------------------------------------------------
     91  5843				  -	      IF	MULTI_BANK_BOARD = YES
     92  5843				  -BoardBank
     93  5843					      ENDIF
     94  5843							; Gives the RAM bank of the start of the board row for a given row.
     95  5843
     96  5843				   .BOARD_LOCATION SET	Board - RAM_3E
     97  5843					      REPEAT	SIZE_BOARD_Y
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  5843					      REPEND
    106  5843				  -	      IF	MULTI_BANK_BOARD = YES
    107  5843				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  5843					      ENDIF
    109  5843
    110  5843
    111  5843							;------------------------------------------------------------------------------
    112  5843
    113  5843				   CopyROMShadowToRAM_F000
    114  5843		       a9 f0		      lda	#>$F000
    115  5845
      0  5845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  5845		       00 0b	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  5845					      SUBROUTINE
      3  5845				   CopyROMShadowToRAM
    117  5845
    118  5845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  5845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  5845							; of the variable contents from ROM declarations, but still allows access to them as
    121  5845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  5845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  5845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  5845							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  5845							; banks -- by the very code itself.
    126  5845
    127  5845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  5845		       85 c1		      sta	Board_AddressR+1
    129  5847		       86 db		      stx	O_ROM_Source_Bank	; source bank
    130  5849		       84 c5		      sty	RAM_Bank	; destination bank
    131  584b
    132  584b		       a0 00		      ldy	#0
    133  584d		       84 c0		      sty	Board_AddressR
    134  584f		       84 c2		      sty	Board_AddressW
    135  5851		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  5853		       85 c3		      sta	Board_AddressW+1
    137  5855
    138  5855							; Iterate 4 pages (1K) for complete bank copy
    139  5855
    140  5855		       a9 04		      lda	#4
    141  5857		       85 da		      sta	O_CopyCount
    142  5859
    143  5859		       84 dc	   CopyPage   sty	O_Index
    144  585b		       a5 db		      lda	O_ROM_Source_Bank
    145  585d		       20 0f f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  5860							;tax
    147  5860		       a4 dc		      ldy	O_Index
    148  5862		       a6 c5		      ldx	RAM_Bank
    149  5864		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  5867
    151  5867		       a4 dc		      ldy	O_Index
    152  5869		       c8		      iny
    153  586a		       d0 ed		      bne	CopyPage
    154  586c
    155  586c		       e6 c1		      inc	Board_AddressR+1
    156  586e		       e6 c3		      inc	Board_AddressW+1
    157  5870
    158  5870		       c6 da		      dec	O_CopyCount
    159  5872		       d0 e5		      bne	CopyPage
    160  5874
    161  5874		       a4 c5		      ldy	RAM_Bank	; TODO: remove!?
    162  5876		       60		      rts
    163  5877
    164  5877
    165  5877							;------------------------------------------------------------------------------
      0  5877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  5877		       00 0b	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  5877					      SUBROUTINE
      3  5877				   SetPlatformColours
    167  5877
    168  5877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  5877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  5877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  5877							; addressing will not violate the page-crossing restriction of 3E.
    172  5877
    173  5877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  5877
    175  5877		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  5879		       85 c2		      sta	Board_AddressW
    177  587b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  587d		       85 c3		      sta	Board_AddressW+1
    179  587f
    180  587f							; first, set the x index (with last one being a RTS ($60))
    181  587f
    182  587f		       a6 c5		      ldx	RAM_Bank
    183  5881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  5883		       d0 07		      bne	.skipPatch
    185  5885		       a9 60		      lda	#$60	; rts
    186  5887		       a0 41		      ldy	#<SELFMOD_X
    187  5889		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  588c				   .skipPatch
    189  588c
    190  588c		       a2 02		      ldx	#3-1
    191  588e				   .loopColor
    192  588e		       86 da		      stx	colorIdx
    193  5890							; set PF colors
    194  5890		       b5 bd		      lda	color,x
    195  5892		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    196  5895							;tax
    197  5895		       a6 c5		      ldx	RAM_Bank
    198  5897		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    199  589a							; set player colors
    200  589a		       a6 da		      ldx	colorIdx
    201  589c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    202  589f		       a4 81		      ldy	Platform
    203  58a1		       c0 02		      cpy	#PAL
    204  58a3		       90 02		      bcc	.platform0
    205  58a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    206  58a7				   .platform0
    207  58a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    208  58aa							;tax
    209  58aa		       a6 c5		      ldx	RAM_Bank
    210  58ac		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    211  58af							; loop
    212  58af		       a6 da		      ldx	colorIdx
    213  58b1		       ca		      dex
    214  58b2		       10 da		      bpl	.loopColor
    215  58b4
    216  58b4		       a4 c5		      ldy	RAM_Bank
    217  58b6		       60		      rts
    218  58b7
    219  58b7				   SelfModColOfsTbl
    220  58b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    221  58ba				   SelfModePlayerTbl
    222  58ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    223  58bd				   SelfModPlayerColOfsTbl
    224  58bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    225  58c0
    226  58c0
    227  58c0				   DrawLineStartLO
    228  58c0
    229  58c0							; Gives the start address of each line in the draw flags buffer
    230  58c0
    231  58c0				   .DRAW_LOCATION SET	DrawFlag
    232  58c0					      REPEAT	SCREEN_LINES
    233  58c0		       50		      .byte.b	<.DRAW_LOCATION
    234  58c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c0					      REPEND
    233  58c1		       5a		      .byte.b	<.DRAW_LOCATION
    234  58c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c1					      REPEND
    233  58c2		       64		      .byte.b	<.DRAW_LOCATION
    234  58c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c2					      REPEND
    233  58c3		       6e		      .byte.b	<.DRAW_LOCATION
    234  58c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c3					      REPEND
    233  58c4		       78		      .byte.b	<.DRAW_LOCATION
    234  58c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c4					      REPEND
    233  58c5		       82		      .byte.b	<.DRAW_LOCATION
    234  58c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c5					      REPEND
    233  58c6		       8c		      .byte.b	<.DRAW_LOCATION
    234  58c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c6					      REPEND
    233  58c7		       96		      .byte.b	<.DRAW_LOCATION
    234  58c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    235  58c8					      REPEND
    236  58c8
    237  58c8
    238  58c8							;------------------------------------------------------------------------------
    239  58c8
      0  58c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  58c8		       00 0b	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  58c8					      SUBROUTINE
      3  58c8				   GetBoardAddressRW
    241  58c8							; Must share same bank as BoardLineStart tables
    242  58c8
    243  58c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    244  58cb		       85 c0		      sta	Board_AddressR	; 3
    245  58cd		       85 c2		      sta	Board_AddressW	; 3
    246  58cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    247  58d2		       85 c1		      sta	Board_AddressR+1	; 3	     READ address
    248  58d4		       09 04		      ora	#>RAM_WRITE	; 2
    249  58d6		       85 c3		      sta	Board_AddressW+1	; 3	     WRITE address
    250  58d8				  -	      IF	MULTI_BANK_BOARD = YES
    251  58d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    252  58d8					      ELSE
    253  58d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    254  58da					      ENDIF
    255  58da		       60		      rts		; 6 = 32[-2]
    256  58db
    257  58db							;------------------------------------------------------------------------------
    258  58db
      0  58db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  58db		       00 0b	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  58db					      SUBROUTINE
      3  58db				   GetBoardAddressR
    260  58db
    261  58db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    262  58de		       85 c0		      sta	Board_AddressR	; 3
    263  58e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    264  58e3		       85 c1		      sta	Board_AddressR+1	; 3	 READ address
    265  58e5				  -	      IF	MULTI_BANK_BOARD = YES
    266  58e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    267  58e5					      ELSE
    268  58e5		       a9 0d		      lda	#BANK_BOARD	; 2
    269  58e7					      ENDIF
    270  58e7		       60		      rts		; 6[-2]
    271  58e8
    272  58e8							;------------------------------------------------------------------------------
    273  58e8
      0  58e8					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  58e8		       00 0b	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  58e8					      SUBROUTINE
      3  58e8				   GetBoardAddressW
    275  58e8
    276  58e8							; Must share same bank as BoardLineStart tables
    277  58e8
    278  58e8		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    279  58eb		       85 c2		      sta	Board_AddressW	;3
    280  58ed		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    281  58f0		       85 c3		      sta	Board_AddressW+1	;3 WRITE address
    282  58f2				  -	      IF	MULTI_BANK_BOARD = YES
    283  58f2				  -	      ldx	BoardBank,y	;4 switch this on return
    284  58f2					      ELSE
    285  58f2		       a2 0d		      ldx	#BANK_BOARD	;2
    286  58f4					      ENDIF
    287  58f4		       60	   QRet       rts		;6
    288  58f5
    289  58f5							;-------------------------------------------------------------------------------
    290  58f5
    291  58f5
    292  58f5							;------------------------------------------------------------------------------
    293  58f5
      0  58f5					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  58f5		       00 0b	   BANK_PushBox =	_CURRENT_BANK
      2  58f5					      SUBROUTINE
      3  58f5				   PushBox
    295  58f5
    296  58f5							; X = restoration character for square we are moving TO
    297  58f5							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    298  58f5
    299  58f5		       85 c4		      sta	ROM_Bank
    300  58f7
    301  58f7		       a5 a5		      lda	ManPushCounter
    302  58f9		       c9 01		      cmp	#PUSH_LIMIT
    303  58fb		       90 6c		      bcc	cannotPush
    304  58fd
    305  58fd		       86 dc		      stx	restorationCharacter	; BOX'S NEW CHAR
    306  58ff
    307  58ff							; Determine if the box is pushable
    308  58ff							; we use the joystick to calculate the subsequent square
    309  58ff
    310  58ff		       a5 90		      lda	BufferedJoystick
    311  5901		       4a		      lsr
    312  5902		       4a		      lsr
    313  5903		       4a		      lsr
    314  5904		       4a		      lsr
    315  5905		       48		      pha
    316  5906		       a8		      tay
    317  5907
    318  5907		       18		      clc
    319  5908		       a5 8d		      lda	POS_Y_NEW
    320  590a		       79 92 f2 	      adc	JoyMoveY,y
    321  590d		       a8		      tay
    322  590e		       20 c8 f0 	      jsr	GetBoardAddressRW
    323  5911
    324  5911		       68		      pla
    325  5912		       a8		      tay
    326  5913
    327  5913		       18		      clc
    328  5914		       a5 8c		      lda	POS_X_NEW
    329  5916		       79 86 f2 	      adc	JoyMoveX,y
    330  5919		       48		      pha
    331  591a		       a8		      tay
    332  591b
    333  591b				  -	      IF	MULTI_BANK_BOARD = YES
    334  591b				  -	      lda	RAM_Bank
    335  591b					      ELSE
    336  591b		       a9 0d		      lda	#BANK_BOARD	; 2
    337  591d					      ENDIF
    338  591d		       20 14 f8 	      jsr	GetBoardCharacter	;6+20(A)
    339  5920		       68		      pla
    340  5921		       a8		      tay
    341  5922
    342  5922		       a9 02		      lda	#CHARACTER_BOX
    343  5924		       e0 00		      cpx	#CHARACTER_BLANK
    344  5926		       f0 13		      beq	canPushTarget
    345  5928
    346  5928		       e0 03		      cpx	#CHARACTER_TARGET
    347  592a		       f0 04		      beq	decreaseTargets
    348  592c		       e0 04		      cpx	#CHARACTER_TARGET2
    349  592e		       d0 39		      bne	cannotPush
    350  5930
    351  5930							; Box is now on a target - so decrease the remaining targets
    352  5930
    353  5930		       f8	   decreaseTargets sed
    354  5931		       38		      sec
    355  5932		       a5 b9		      lda	targetsRequired
    356  5934		       e9 01		      sbc	#1
    357  5936		       85 b9		      sta	targetsRequired
    358  5938		       d8		      cld
    359  5939
    360  5939		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    361  593b		       48	   canPushTarget pha
    362  593c
    363  593c							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    364  593c							; then we increase targets (as there is one more to get)
    365  593c
    366  593c		       a5 dc		      lda	restorationCharacter
    367  593e		       c9 03		      cmp	#CHARACTER_TARGET
    368  5940		       d0 09		      bne	notOnTargetAlready
    369  5942
    370  5942							; increase the required targets as box is leaving one
    371  5942
    372  5942		       f8		      sed
    373  5943		       18		      clc
    374  5944		       a5 b9		      lda	targetsRequired
    375  5946		       69 01		      adc	#1
    376  5948		       85 b9		      sta	targetsRequired
    377  594a		       d8		      cld
    378  594b
    379  594b				   notOnTargetAlready
    380  594b
    381  594b
    382  594b		       68		      pla
    383  594c
    384  594c
    385  594c				  -	      IF	MULTI_BANK_BOARD = YES
    386  594c				  -	      ldx	RAM_Bank
    387  594c					      ELSE
    388  594c		       a2 0d		      ldx	#BANK_BOARD	; 2
    389  594e					      ENDIF
    390  594e		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)
    391  5951
    392  5951		       a5 8f		      lda	POS_VAR	; player's restoration character
    393  5953		       48		      pha
    394  5954
    395  5954		       a6 8d		      ldx	POS_Y_NEW
    396  5956		       86 8b		      stx	POS_Y
    397  5958		       a4 8c		      ldy	POS_X_NEW
    398  595a		       84 8a		      sty	POS_X
    399  595c		       a5 dc		      lda	restorationCharacter
    400  595e		       85 8f		      sta	POS_VAR
    401  5960
    402  5960		       20 fa f8 	      jsr	RestoreOriginalCharacter	; put back BOX's restoration character
    403  5963
    404  5963		       68		      pla
    405  5964		       85 8f		      sta	POS_VAR
    406  5966
    407  5966							;START_SOUND SOUND_BOX
    408  5966
    409  5966		       4c 59 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    410  5969
    411  5969		       e6 a5	   cannotPush inc	ManPushCounter
    412  596b		       60		      rts
    413  596c
    414  596c							;------------------------------------------------------------------------------
    415  596c
    416  596c							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    417  596c							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    418  596c
    419  596c							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    420  596c
    421  596c							; if the creature dies then jump NextObject
    422  596c
    423  596c
    424  596c
    425  596c		       ff	   RDirY      .byte.b	-1	;,0,1,0
    426  596d		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    427  596f		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    428  5973		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    429  5977		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    430  5985
    431  5985
    432  5985							;------------------------------------------------------------------------------
    433  5985
    434  5985							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    435  5985							; I don't particularly know why; probably because of the level variable-size array and the values
    436  5985							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    437  5985
    438  5985		       00 00	   MANMODE_STARTUP =	0
    439  5985		       00 01	   MANMODE_NORMAL =	1
    440  5985		       00 02	   MANMODE_DEAD =	2
    441  5985		       00 03	   MANMODE_WAITING =	3
    442  5985		       00 04	   MANMODE_WAITING2 =	4
    443  5985		       00 05	   MANMODE_WAITING_NT =	5
    444  5985		       00 06	   MANMODE_WAITING_NT2 =	6
    445  5985		       00 07	   MANMODE_NEXTLEVEL =	7
    446  5985		       00 08	   MANMODE_NEXTLEVEL2 =	8
    447  5985		       00 09	   MANMODE_SWITCH =	9
    448  5985
      0  5985					      DEFINE_SUBROUTINE	ManProcess
      1  5985		       00 0b	   BANK_ManProcess =	_CURRENT_BANK
      2  5985					      SUBROUTINE
      3  5985				   ManProcess
    450  5985
    451  5985							; ManMode tells the player what it is currently doing.  State machine.
    452  5985
    453  5985							; Check the switches....
    454  5985							; RESET to restart this level
    455  5985							; SELECT to start next level
    456  5985
    457  5985		       ad 82 02 	      lda	SWCHB
    458  5988		       29 03		      and	#3
    459  598a		       aa		      tax
    460  598b		       bd a4 f1 	      lda	newMode,x
    461  598e		       30 02		      bmi	skipModeChange
    462  5990		       85 9f		      sta	ManMode
    463  5992				   skipModeChange
    464  5992
    465  5992		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    466  5995
    467  5995		       a4 9f		      ldy	ManMode
    468  5997		       b9 a8 f1 	      lda	ManActionLO,y
    469  599a		       85 da		      sta	actionVector
    470  599c		       b9 b2 f1 	      lda	ManActionHI,y
    471  599f		       85 db		      sta	actionVector+1
    472  59a1		       6c da 00 	      jmp	(actionVector)
    473  59a4
    474  59a4		       ff 09 04 ff newMode    .byte.b	-1, MANMODE_SWITCH, MANMODE_WAITING2, -1
    475  59a8
    476  59a8				   ManActionLO
    477  59a8		       bc		      .byte.b	<manStartup	; 0		 no timer
    478  59a9		       eb		      .byte.b	<normalMan	; 1		 timer
    479  59aa		       f0		      .byte.b	<deadMan	; 2		 timer
    480  59ab		       e4		      .byte.b	<waitingMan	; 3		 timer
    481  59ac		       e4		      .byte.b	<waitingManPress	; 4		 timer
    482  59ad		       e4		      .byte.b	<waitingMan	; 5		 no timer
    483  59ae		       e4		      .byte.b	<waitingManPress	; 6		 no timer
    484  59af		       5e		      .byte.b	<nextLevelMan	; 7		 no timer
    485  59b0		       6f		      .byte.b	<nextLevelMan2	; 8		 no timer
    486  59b1		       7a		      .byte.b	<switchLevels	; 9		 no timer
    487  59b2
    488  59b2				   ManActionHI
    489  59b2		       f1		      .byte.b	>manStartup	; no timer
    490  59b3		       f1		      .byte.b	>normalMan	; timer
    491  59b4		       f1		      .byte.b	>deadMan	; timer
    492  59b5		       f1		      .byte.b	>waitingMan	; timer
    493  59b6		       f1		      .byte.b	>waitingManPress	; timer
    494  59b7		       f1		      .byte.b	>waitingMan	; no timer
    495  59b8		       f1		      .byte.b	>waitingManPress	; no timer
    496  59b9		       fc		      .byte.b	>nextLevelMan	; no timer
    497  59ba		       fc		      .byte.b	>nextLevelMan2	; no timer
    498  59bb		       fc		      .byte.b	>switchLevels	;9  no timer
    499  59bc
    500  59bc							;------------------------------------------------------------------------------
      0  59bc					      DEFINE_SUBROUTINE	manStartup
      1  59bc		       00 0b	   BANK_manStartup =	_CURRENT_BANK
      2  59bc					      SUBROUTINE
      3  59bc				   manStartup
    502  59bc
    503  59bc		       a5 9b		      lda	ManX
    504  59be		       85 8c		      sta	POS_X_NEW	;NewX
    505  59c0		       85 8a		      sta	POS_X
    506  59c2		       a5 9c		      lda	ManY
    507  59c4		       85 8d		      sta	POS_Y_NEW	;NewY
    508  59c6		       85 8b		      sta	POS_Y
    509  59c8
    510  59c8		       e6 9a		      inc	manAnimationIndex
    511  59ca		       a6 9a		      ldx	manAnimationIndex	; animation index
    512  59cc		       bd dc f1 	      lda	.ManStartup-1,x
    513  59cf		       30 09		      bmi	CreateThePlayer
    514  59d1		       85 8e		      sta	POS_Type
    515  59d3
    516  59d3		       a9 ff		      lda	#$FF
    517  59d5		       85 a0		      sta	ManDelayCount	; anything, just non-0
    518  59d7
    519  59d7		       4c 3a f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    520  59da
    521  59da				   CreateThePlayer
    522  59da
    523  59da		       e6 9f		      inc	ManMode	; --> MANMODE_NORMAL
    524  59dc				   RTS_CF
    525  59dc		       60		      rts
    526  59dd
    527  59dd				   .ManStartup
    528  59dd		       09		      .byte.b	CHARACTER_NOGO
    529  59de		       09		      .byte.b	CHARACTER_NOGO
    530  59df		       06		      .byte.b	CHARACTER_STEEL
    531  59e0							;    .byte CHARACTER_STEEL
    532  59e0		       09		      .byte.b	CHARACTER_NOGO
    533  59e1							;    .byte CHARACTER_NOGO
    534  59e1		       06		      .byte.b	CHARACTER_STEEL
    535  59e2							;    .byte CHARACTER_NOGO
    536  59e2							;    .byte CHARACTER_STEEL
    537  59e2							;    .byte CHARACTER_NOGO
    538  59e2							;    .byte CHARACTER_STEEL
    539  59e2							;    .byte CHARACTER_NOGO
    540  59e2							;    .byte CHARACTER_STEEL
    541  59e2							;    .byte CHARACTER_NOGO
    542  59e2							;    .byte CHARACTER_STEEL
    543  59e2							;    .byte CHARACTER_NOGO
    544  59e2							;    .byte CHARACTER_STEEL
    545  59e2							;.byte CHARACTER_NOGO
    546  59e2		       05		      .byte.b	CHARACTER_MANOCCUPIED
    547  59e3		       ff		      .byte.b	-1
    548  59e4
    549  59e4							;------------------------------------------------------------------------------
    550  59e4
    551  59e4				   waitingMan
    552  59e4				   waitingManPress
    553  59e4
    554  59e4							;		  lda #50
    555  59e4							;		  sta ColourTimer
    556  59e4
    557  59e4
    558  59e4		       a5 ca		      lda	NextLevelTrigger
    559  59e6		       09 40		      ora	#BIT_NEXTLIFE
    560  59e8		       85 ca		      sta	NextLevelTrigger
    561  59ea		       60		      rts
    562  59eb
    563  59eb
    564  59eb							;------------------------------------------------------------------------------
    565  59eb							; Normal man state
    566  59eb
    567  59eb
    568  59eb				   normalMan
    569  59eb
    570  59eb							; Timer is still running, so we see if the player is to die for any reason
    571  59eb
    572  59eb							;		  bit demoMode
    573  59eb							;		  bmi stayAlive
    574  59eb							; SELECT pressed?
    575  59eb							;		  lda SWCHB
    576  59eb							;		  eor #$FF
    577  59eb							;		  and #3
    578  59eb							;		  bne Time0			  ; EITHER select or reset are pressed
    579  59eb							;		  lsr
    580  59eb							;		  lsr
    581  59eb							;		  bcc Time0			  ; suicide!
    582  59eb				   stayAlive
    583  59eb
    584  59eb							;------------------------------------------------------------------------------
    585  59eb
    586  59eb							;ldx ManY
    587  59eb							;ldy ManX
    588  59eb
    589  59eb							;lda BoardLineStartLO,x
    590  59eb							;sta Board_AddressR
    591  59eb							;lda BoardLineStartHiR,x
    592  59eb							;sta Board_AddressR+1
    593  59eb
    594  59eb				  -	      IF	MULTI_BANK_BOARD = YES
    595  59eb				  -			;lda BoardBank,x		  ;4
    596  59eb				  -			;sta RAM_Bank			  ;3
    597  59eb					      ELSE
    598  59eb							;lda #BANK_BOARD		  ;2
    599  59eb					      ENDIF
    600  59eb							;jsr GetBoardCharacter 	  ;6+20(A)
    601  59eb
    602  59eb							;lda CharToType,x
    603  59eb							;cmp #TYPE_MAN
    604  59eb							;beq PlayerAlive
    605  59eb		       4c fb f1 	      jmp	PlayerAlive	;sok
    606  59ee
    607  59ee							; character he's on isn't a MAN character, so he dies...
    608  59ee
    609  59ee				   Time0
    610  59ee
    611  59ee		       e6 9f		      inc	ManMode	; #1 -- player dead!
    612  59f0
    613  59f0
    614  59f0		       a5 9b	   deadMan    lda	ManX
    615  59f2		       85 8a		      sta	POS_X
    616  59f4		       a5 9c		      lda	ManY
    617  59f6		       85 8b		      sta	POS_Y
    618  59f8
    619  59f8							;jsr BlankPlayerFrame
    620  59f8
    621  59f8							; and becomes a man waiting for resurrection...
    622  59f8
    623  59f8		       e6 9f		      inc	ManMode
    624  59fa
    625  59fa				   timeTooShortToDie
    626  59fa		       60		      rts
    627  59fb
    628  59fb							;------------------------------------------------------------------------------
    629  59fb
    630  59fb				   PlayerAlive
    631  59fb
    632  59fb							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    633  59fb							; before exiting via (for example) look-around option :)
    634  59fb
    635  59fb		       a5 9b		      lda	ManX
    636  59fd		       85 8c		      sta	POS_X_NEW
    637  59ff		       a5 9c		      lda	ManY
    638  5a01		       85 8d		      sta	POS_Y_NEW
    639  5a03
    640  5a03
    641  5a03
    642  5a03							;------------------------------------------------------------------------------
    643  5a03							; Look around is triggered by holding down the fire button for a while, without any other
    644  5a03							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    645  5a03							; is active. Otherwise, it is counting down to the time where it will trigger.
    646  5a03
    647  5a03		       00 00	   LOOK_DELAY =	0
    648  5a03
    649  5a03
    650  5a03							;------------------------------------------------------------------------------
    651  5a03							; Take-back is a press/release of the button, with the press being limited in duratino
    652  5a03							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    653  5a03							; "look-around mode"
    654  5a03
    655  5a03		       a5 92		      lda	BufferedButton
    656  5a05		       30 36		      bmi	noLook	; button?
    657  5a07
    658  5a07							; button pressed, so in looking-around mode
    659  5a07
    660  5a07		       a2 ff		      ldx	#$FF
    661  5a09		       86 92		      stx	BufferedButton	; "release" button
    662  5a0b
    663  5a0b		       a5 a6		      lda	LookingAround
    664  5a0d		       30 02		      bmi	LookAround
    665  5a0f		       86 a6		      stx	LookingAround
    666  5a11				   LookAround
    667  5a11
    668  5a11							; Use the joystick as a window-scroller to change the viewport
    669  5a11
    670  5a11		       a5 90		      lda	BufferedJoystick
    671  5a13		       4a		      lsr
    672  5a14		       4a		      lsr
    673  5a15		       4a		      lsr
    674  5a16		       4a		      lsr
    675  5a17		       a8		      tay
    676  5a18
    677  5a18		       b9 86 f2 	      lda	JoyMoveX,y
    678  5a1b		       19 92 f2 	      ora	JoyMoveY,y
    679  5a1e		       f0 1c		      beq	AbandonY
    680  5a20
    681  5a20		       a9 fe		      lda	#$FE
    682  5a22		       85 a6		      sta	LookingAround
    683  5a24
    684  5a24		       b9 86 f2 	      lda	JoyMoveX,y
    685  5a27							;asl
    686  5a27		       18		      clc
    687  5a28		       65 97		      adc	BoardScrollX
    688  5a2a		       c5 94		      cmp	BoardEdge_Right
    689  5a2c		       b0 02		      bcs	AbandonX
    690  5a2e		       85 97		      sta	BoardScrollX
    691  5a30
    692  5a30		       b9 92 f2    AbandonX   lda	JoyMoveY,y
    693  5a33							;asl
    694  5a33		       18		      clc
    695  5a34		       65 96		      adc	BoardScrollY
    696  5a36		       c5 95		      cmp	BoardEdge_Bottom
    697  5a38		       b0 02		      bcs	AbandonY
    698  5a3a		       85 96		      sta	BoardScrollY
    699  5a3c
    700  5a3c		       60	   AbandonY   rts
    701  5a3d
    702  5a3d		       a5 a6	   noLook     lda	LookingAround
    703  5a3f		       c9 ff		      cmp	#$FF
    704  5a41		       d0 00		      bne	bProcComp
    705  5a43
    706  5a43							; button was presssed and now released and we didn't actually look around
    707  5a43							; TODO -- takeback here
    708  5a43							;jsr restorePreviousManPosition
    709  5a43							;lda #2
    710  5a43							;sta ColourTimer
    711  5a43
    712  5a43		       a2 00	   bProcComp  ldx	#0
    713  5a45		       86 a6		      stx	LookingAround
    714  5a47
    715  5a47							;------------------------------------------------------------------------------
    716  5a47
    717  5a47							; control the scrolling via the joystick
    718  5a47
    719  5a47		       a5 a4		      lda	ManLastDirection
    720  5a49		       29 07		      and	#DIRECTION_BITS
    721  5a4b		       a8		      tay
    722  5a4c
    723  5a4c		       a5 90		      lda	BufferedJoystick	; joystick
    724  5a4e		       25 91		      and	BufferedJoystick+1
    725  5a50
    726  5a50		       a2 00		      ldx	#0
    727  5a52		       0a	   .loopDirs  asl
    728  5a53		       90 07		      bcc	.dirFound
    729  5a55		       88		      dey
    730  5a56		       e8		      inx
    731  5a57		       e0 04		      cpx	#4
    732  5a59		       d0 f7		      bne	.loopDirs
    733  5a5b		       18		      clc
    734  5a5c				   .dirFound
    735  5a5c		       a5 8c		      lda	POS_X_NEW	;NewX
    736  5a5e		       7d 9f f2 	      adc	JoyDirX,x
    737  5a61		       85 8c		      sta	POS_X_NEW	;NewX
    738  5a63		       a5 8d		      lda	POS_Y_NEW	;NewY
    739  5a65		       18		      clc
    740  5a66		       7d 9d f2 	      adc	JoyDirY,x
    741  5a69		       85 8d		      sta	POS_Y_NEW	;NewY
    742  5a6b
    743  5a6b		       98		      tya
    744  5a6c		       f0 12		      beq	noMovement	; animation OK
    745  5a6e
    746  5a6e		       8a		      txa
    747  5a6f		       45 a4		      eor	ManLastDirection
    748  5a71		       29 07		      and	#DIRECTION_BITS
    749  5a73		       45 a4		      eor	ManLastDirection
    750  5a75		       85 a4		      sta	ManLastDirection
    751  5a77		       bd 81 f2 	      lda	ManAnimTblLo,x
    752  5a7a		       85 a1		      sta	ManAnimation
    753  5a7c							;lda ManAnimTblHi,x
    754  5a7c							;sta ManAnimation+1
    755  5a7c		       a9 00		      lda	#0
    756  5a7e		       85 a0		      sta	ManDelayCount
    757  5a80				   phase0		;jsr MovePlayer
    758  5a80				   noMovement		;ldx MAN_Player
    759  5a80
    760  5a80		       60	   DFS_rts    rts
    761  5a81
    762  5a81
    763  5a81				   ManAnimTblLo
    764  5a81		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    765  5a86							;ManAnimTblHi
    766  5a86							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    767  5a86
    768  5a86
    769  5a86
    770  5a86		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    771  5a92		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    772  5a9d
    773  5a9d				   JoyDirY
    774  5a9d		       00 00		      .byte.b	0,0	;,1,-1,0
    775  5a9f				   JoyDirX
    776  5a9f		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    777  5aa4
    778  5aa4
    779  5aa4							;------------------------------------------------------------------------------
    780  5aa4
    781  5aa4
      0  5aa4					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  5aa4		       00 0b	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  5aa4					      SUBROUTINE
      3  5aa4				   DrawFullScreen
    783  5aa4
    784  5aa4							; 83[-7] + 2484[-89] = 2567[-96]
    785  5aa4
    786  5aa4
    787  5aa4		       ad 84 02 	      lda	INTIM	; 4
    788  5aa7		       c9 23		      cmp	#SEGTIME_BDF	; 2
    789  5aa9		       90 d5		      bcc	DFS_rts	; 2/3
      0  5aab					      STRESS_TIME	SEGTIME_BDF
      1  5aab				  -	      IF	TEST_SEGTIME_BDF = 1
      2  5aab				  -
      3  5aab				  -
      4  5aab				  -
      5  5aab				  -
      6  5aab				  -
      7  5aab				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  5aab				  -	      bne	. - 7
      9  5aab					      ENDIF
    791  5aab
    792  5aab		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    793  5aad		       85 db		      sta	BDF_DrawFlagAddress+1	; 3
    794  5aaf		       85 dd		      sta	BDF_DrawFlagAddress2+1	; 3
    795  5ab1
    796  5ab1		       ba		      tsx		; 2
    797  5ab2		       86 e4		      stx	DHS_Stack	; 3
    798  5ab4
    799  5ab4		       e6 89		      inc	ScreenDrawPhase	; 5
    800  5ab6
    801  5ab6		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    802  5ab7		       a2 08		      ldx	#SCREEN_LINES	; 2
    803  5ab9		       8a		      txa		; 2 = *32
    804  5aba
    805  5aba							; fall through
    806  5aba
    807  5aba							;------------------------------------------------------------------------------
    808  5aba
      0  5aba					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = *59[-7 if not multi-bank-board]
      1  5aba		       00 0b	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  5aba					      SUBROUTINE
      3  5aba				   DrawScreenRowPreparation
    810  5aba
    811  5aba							;clc
    812  5aba		       ca		      dex		; 2
    813  5abb		       86 e3		      stx	DHS_Line	; 3
    814  5abd		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    815  5abf		       a8		      tay		; 2 = 10
    816  5ac0
    817  5ac0							;clc
    818  5ac0		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    819  5ac3		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
    820  5ac5		       85 de		      sta	BDF_BoardAddress	; 3
    821  5ac7		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    822  5ac9		       85 e0		      sta	BDF_BoardAddress2	; 3
    823  5acb
    824  5acb		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    825  5ace		       85 df		      sta	BDF_BoardAddress+1	; 3
    826  5ad0		       85 e1		      sta	BDF_BoardAddress2+1	; 3 = 25
    827  5ad2
    828  5ad2		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
    829  5ad5		       85 da		      sta	BDF_DrawFlagAddress	; 3
    830  5ad7		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    831  5ad9		       85 dc		      sta	BDF_DrawFlagAddress2	; 3 = 12
    832  5adb
    833  5adb				  -	      IF	MULTI_BANK_BOARD = YES
    834  5adb				  -	      lda	BoardBank-1,y	; 4
    835  5adb				  -	      sta	BDF_BoardBank	; 3
    836  5adb					      ENDIF
    837  5adb		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    838  5add		       4c 5d fa 	      jmp	CopyRow2	; 3 = 12[-7]
    839  5ae0
    840  5ae0							;------------------------------------------------------------------------------
    841  5ae0
      0  5ae0					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  5ae0		       00 0b	   BANK_VectorProcess =	_CURRENT_BANK
      2  5ae0					      SUBROUTINE
      3  5ae0				   VectorProcess
    843  5ae0
    844  5ae0							;sta ROM_Bank			  ;3		  processors can assume bank is stored
    845  5ae0
    846  5ae0		       bd ee f2 	      lda	OSPointerHI,x	;4
    847  5ae3		       85 db		      sta	POS_Vector+1	;3
    848  5ae5		       bd ed f2 	      lda	OSPointerLO,x	;4
    849  5ae8		       85 da		      sta	POS_Vector	;3
    850  5aea
    851  5aea		       6c da 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
    852  5aed							;		 NOTE: Bank is either INITBANK or FIXED.
    853  5aed
    854  5aed
    855  5aed				   OBJTYPE    SET	0
    856  5aed					      MAC	define
    857  5aed				   TYPE_{1}   =	OBJTYPE
    858  5aed				   OBJTYPE    .SET	OBJTYPE + 1
    859  5aed					      ENDM
    860  5aed
    861  5aed							; If adding/removing types, the following must also be updated...
    862  5aed							;   InitialFace[...]		     in UnpackLevel.asm
    863  5aed							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
    864  5aed							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
    865  5aed							;   OSPointerLO[...]		     in BANK_INITBANK.asm
    866  5aed							;   OSPointerHI[...]		     in BANK_INITBANK.asm
    867  5aed							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
    868  5aed							;   Sortable[...]		     in BANK_FIXED.asm
    869  5aed
    870  5aed
      0  5aed					      DEFINE	MAN
      1  5aed		       00 00	   TYPE_MAN   =	OBJTYPE
      2  5aed				   OBJTYPE    .SET	OBJTYPE + 1
    872  5aed							;DEFINE CIRCLE
    873  5aed							;DEFINE CIRCLE_HELPER
    874  5aed							;DEFINE CIRCLE_DRAWER
    875  5aed
      0  5aed					      DEFINE	MAXIMUM
      1  5aed		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  5aed				   OBJTYPE    .SET	OBJTYPE + 1
    877  5aed
    878  5aed
      0  5aed					      DEFINE_SUBROUTINE	OSPointerLO
      1  5aed		       00 0b	   BANK_OSPointerLO =	_CURRENT_BANK
      2  5aed					      SUBROUTINE
      3  5aed				   OSPointerLO
    880  5aed		       c8		      .byte.b	<PROCESS_MAN
    881  5aee							;.byte <PROCESS_CIRCLE
    882  5aee							;.byte <PROCESS_CIRCLE_HELPER
    883  5aee
    884  5aee				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
    885  5aee				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
    886  5aee				  -	      ERR
    887  5aee					      ENDIF
    888  5aee
    889  5aee
      0  5aee					      DEFINE_SUBROUTINE	OSPointerHI
      1  5aee		       00 0b	   BANK_OSPointerHI =	_CURRENT_BANK
      2  5aee					      SUBROUTINE
      3  5aee				   OSPointerHI
    891  5aee		       f8		      .byte.b	>PROCESS_MAN
    892  5aef							;.byte >PROCESS_CIRCLE
    893  5aef							;.byte >PROCESS_CIRCLE_HELPER
    894  5aef
    895  5aef				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
    896  5aef				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
    897  5aef				  -	      ERR
    898  5aef					      ENDIF
    899  5aef
    900  5aef							;------------------------------------------------------------------------------
    901  5aef
      0  5aef					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  5aef		       00 0b	   BANK_MoveVecLO =	_CURRENT_BANK
      2  5aef					      SUBROUTINE
      3  5aef				   MoveVecLO
    903  5aef
    904  5aef		       85		      .byte.b	<MOVE_BLANK
    905  5af0		       85		      .byte.b	<MOVE_SOIL
    906  5af1		       cf		      .byte.b	<MOVE_BOX
    907  5af2		       85		      .byte.b	<MOVE_TARGET
    908  5af3		       85		      .byte.b	<MOVE_TARGET
    909  5af4		       ca		      .byte.b	<MOVE_GENERIC	;man occupied
    910  5af5		       ca		      .byte.b	<MOVE_GENERIC	;steel
    911  5af6		       ca		      .byte.b	<MOVE_GENERIC	;wall
    912  5af7		       da		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
    913  5af8		       ca		      .byte.b	<MOVE_GENERIC	;nogo
    914  5af9
    915  5af9				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
    916  5af9				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
    917  5af9				  -	      ERR
    918  5af9					      ENDIF
    919  5af9
    920  5af9
    921  5af9
      0  5af9					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  5af9		       00 0b	   BANK_MoveVecHI =	_CURRENT_BANK
      2  5af9					      SUBROUTINE
      3  5af9				   MoveVecHI
    923  5af9
    924  5af9		       f9		      .byte.b	>MOVE_BLANK
    925  5afa		       f9		      .byte.b	>MOVE_SOIL
    926  5afb		       f9		      .byte.b	>MOVE_BOX
    927  5afc		       f9		      .byte.b	>MOVE_TARGET
    928  5afd		       f9		      .byte.b	>MOVE_TARGET
    929  5afe		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
    930  5aff		       f9		      .byte.b	>MOVE_GENERIC	;steel
    931  5b00		       f9		      .byte.b	>MOVE_GENERIC	;wall
    932  5b01		       f9		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
    933  5b02		       f9		      .byte.b	>MOVE_GENERIC	;nogo
    934  5b03
    935  5b03				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
    936  5b03				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
    937  5b03				  -	      EXIT
    938  5b03					      ENDIF
    939  5b03
    940  5b03
    941  5b03
      0  5b03					      CHECK_BANK_SIZE	"INITBANK"
      1  5b03		       03 03	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $303 , FREE= $4fd
      2  5b03					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5b03				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5b03				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5b03				  -	      ERR
      6  5b03					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 4
      0  5b03					      include	"BANK_FIXED.asm"
      1  5b03							;    Sokoboo - a Sokoban implementation
      2  5b03							;    using a generic tile-based display engine for the Atari 2600
      3  5b03							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  5b03							;
      5  5b03							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  5b03							;
      7  5b03							;    Code related to the generic tile-based display engine was developed by
      8  5b03							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  5b03							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  5b03							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  5b03							;
     12  5b03							;    Code related to music and sound effects uses the TIATracker music player
     13  5b03							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  5b03							;    directory for Apache licensing details.
     15  5b03							;
     16  5b03							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  5b03							;    See the copyright notices in the License directory for a list of level
     18  5b03							;    contributors.
     19  5b03							;
     20  5b03							;    Except where otherwise indicated, this software is released under the
     21  5b03							;    following licensing arrangement...
     22  5b03							;
     23  5b03							;    This program is free software: you can redistribute it and/or modify
     24  5b03							;    it under the terms of the GNU General Public License as published by
     25  5b03							;    the Free Software Foundation, either version 3 of the License, or
     26  5b03							;    (at your option) any later version.
     27  5b03							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  5b03
     29  5b03							;    This program is distributed in the hope that it will be useful,
     30  5b03							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  5b03							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  5b03							;    GNU General Public License for more details.
     33  5b03
     34  5b03							;------------------------------------------------------------------------------
     35  5b03							;###############################  FIXED BANK  #################################
     36  5b03							;------------------------------------------------------------------------------
     37  5b03
     38  5b03
     39  5b03				   ORIGIN     SET	FIXED_BANK
     40  5b03
      0  5b03					      NEWBANK	THE_FIXED_BANK
      1  7dc1 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       a9 09		      lda	#BANK_SCORING
     51  7802		       85 3e		      sta	SET_BANK_RAM
     52  7804		       20 cf f2 	      jsr	DrawTime
     53  7807		       20 ba f2 	      jsr	DrawTargetsRequired
     54  780a		       a5 c4		      lda	ROM_Bank
     55  780c		       85 3f		      sta	SET_BANK
     56  780e		       60		      rts
     57  780f
     58  780f							;------------------------------------------------------------------------------
     59  780f
      0  780f					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780f		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780f					      SUBROUTINE
      3  780f				   GetROMByte
     61  780f
     62  780f							; a = ROM bank to retrieve
     63  780f							; y = page index
     64  780f							; ROM_Bank = bank to return to
     65  780f							; (Board_AddressR) = page
     66  780f							; out a = byte from (Board_AddressR)
     67  780f
     68  780f		       85 3f		      sta	SET_BANK	;3
     69  7811		       4c 16 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     70  7814
     71  7814							;------------------------------------------------------------------------------
     72  7814
      0  7814					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7814		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7814					      SUBROUTINE
      3  7814				   GetBoardCharacter
     74  7814
     75  7814							; call from ROM bank
     76  7814							; switches back to ROM_Bank on exit
     77  7814
     78  7814							; pass A = bank containing character
     79  7814							; Y = x character position
     80  7814							; (Board_AddressR) points to character position
     81  7814							; returns character from board
     82  7814
     83  7814
     84  7814		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     85  7816
     86  7816				   GetBoardCharacter2		;=17(A)
     87  7816
     88  7816		       b3 c0		      lax	(Board_AddressR),y	;5
     89  7818		       a4 c4		      ldy	ROM_Bank	;3
     90  781a		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     91  781c		       60		      rts		;6   and go back
     92  781d
     93  781d							;---------------------------------------------------------------------------
     94  781d
      0  781d					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781d		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781d					      SUBROUTINE
      3  781d				   PutBoardCharacter
     96  781d
     97  781d		       86 3e		      stx	SET_BANK_RAM	; 3
     98  781f
     99  781f				   PutBoardCharacterSB		; =18
    100  781f		       91 c2		      sta	(Board_AddressW),y	; 6
    101  7821		       a5 c4		      lda	ROM_Bank	; 3
    102  7823		       85 3f		      sta	SET_BANK	; 3
    103  7825		       60		      rts		; 6 = 21
    104  7826
    105  7826							;---------------------------------------------------------------------------
    106  7826
      0  7826					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7826		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7826					      SUBROUTINE
      3  7826				   GetBoardCharacter__CALL_FROM_RAM__
    108  7826
    109  7826		       a4 8b		      ldy	POS_Y	;3
    110  7828
    111  7828		       a9 0b		      lda	#BANK_GetBoardAddressR	;
    112  782a		       85 3f		      sta	SET_BANK	;
    113  782c		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    114  782f
    115  782f
    116  782f							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    117  782f
    118  782f		       85 3e		      sta	SET_BANK_RAM	;3
    119  7831		       a4 8a		      ldy	POS_X	;3
    120  7833		       b3 c0		      lax	(Board_AddressR),y	;5
    121  7835		       a4 c5		      ldy	RAM_Bank	;3
    122  7837		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    123  7839		       60		      rts		;6		 and go back
    124  783a
    125  783a							;---------------------------------------------------------------------------
    126  783a
      0  783a					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783a		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783a					      SUBROUTINE
      3  783a				   PutBoardCharacterFromRAM
    128  783a
    129  783a							; POS_Y  = row
    130  783a							; POS_Type = character to write
    131  783a							; POS_X     = column
    132  783a							; RAM_Bank = caller's bank
    133  783a
    134  783a		       a4 8b		      ldy	POS_Y	;3
    135  783c
    136  783c		       a9 0b		      lda	#BANK_GetBoardAddressW	;
    137  783e		       85 3f		      sta	SET_BANK	;
    138  7840		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    139  7843
    140  7843		       86 3e		      stx	SET_BANK_RAM	;3
    141  7845
    142  7845		       a4 8a		      ldy	POS_X	;3
    143  7847		       a5 8e		      lda	POS_Type	;3
    144  7849		       91 c2		      sta	(Board_AddressW),y	;6
    145  784b		       a4 c5		      ldy	RAM_Bank	;3
    146  784d		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    147  784f		       60		      rts		;6
    148  7850
    149  7850
    150  7850							;---------------------------------------------------------------------------
    151  7850
      0  7850					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  7850		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7850					      SUBROUTINE
      3  7850				   ProcessObjStack
    153  7850
    154  7850		       ad 84 02 	      lda	INTIM	;4
    155  7853		       c9 02		      cmp	#MINIMUM_SEGTIME	;2
    156  7855		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  7857					      STRESS_TIME	MINIMUM_SEGTIME
      1  7857				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  7857				  -
      3  7857				  -
      4  7857				  -
      5  7857				  -
      6  7857				  -
      7  7857				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7857				  -	      bne	. - 7
      9  7857					      ENDIF
    158  7857
    159  7857		       a5 85		      lda	ObjStackNum	;3
    160  7859		       49 01		      eor	#1	;2
    161  785b		       aa		      tax		;2
    162  785c
    163  785c		       a5 cd		      lda	ObjIterator	;3
    164  785e		       d5 86		      cmp	ObjStackPtr,x	;5
    165  7860		       b0 2e		      bcs	nextPhase	;2/3
    166  7862
    167  7862
    168  7862							; Process an object...
    169  7862							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    170  7862
    171  7862		       bc 57 f9 	      ldy	BankObjStack,x	;4
    172  7865		       84 3e		      sty	SET_BANK_RAM	;3
    173  7867
    174  7867		       aa		      tax		;2
    175  7868		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    176  786b
    177  786b		       b9 00 10 	      lda	ObjStackX,y	;4
    178  786e		       85 8a		      sta	POS_X	;3
    179  7870		       b9 80 10 	      lda	ObjStackY,y	;4
    180  7873		       85 8b		      sta	POS_Y	;3
    181  7875		       b9 00 11 	      lda	ObjStackVar,y	;4
    182  7878		       85 8f		      sta	POS_VAR	;3
    183  787a		       be 00 12 	      ldx	ObjStackType,y	;4
    184  787d		       86 8e		      stx	POS_Type	;3
    185  787f
    186  787f		       a9 0b		      lda	#BANK_VectorProcess	;2
    187  7881		       85 3f		      sta	SET_BANK	;3
    188  7883
    189  7883		       bd ee f2 	      lda	OSPointerHI,x	;4
    190  7886		       85 db		      sta	POS_Vector+1	;3
    191  7888		       bd ed f2 	      lda	OSPointerLO,x	;4
    192  788b		       85 da		      sta	POS_Vector	;3
    193  788d
    194  788d		       6c da 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    195  7890
    196  7890
    197  7890							;---------------------------------------------------------------------------
    198  7890							; Now process the blank stack.  This stack holds all the recently blanked squares
    199  7890							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    200  7890							; by these objects are added again to the blank stack.
    201  7890
    202  7890				   nextPhase
    203  7890
    204  7890							;clc
    205  7890							;lda circle_d
    206  7890							;adc #255
    207  7890							;sta circle_d
    208  7890							;bcc nocirc
    209  7890							;nocirc
    210  7890
    211  7890		       e6 89		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    212  7892		       60	   EarlyAbort rts		;6
    213  7893
    214  7893							;---------------------------------------------------------------------------
    215  7893
      0  7893					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  7893		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7893					      SUBROUTINE
      3  7893				   SwitchObjects
    217  7893
    218  7893							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    219  7893							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    220  7893							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    221  7893
    222  7893		       ad 84 02 	      lda	INTIM	; 4
    223  7896		       c9 02		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    224  7898		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  789a					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  789a				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  789a				  -
      3  789a				  -
      4  789a				  -
      5  789a				  -
      6  789a				  -
      7  789a				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  789a				  -	      bne	. - 7
      9  789a					      ENDIF
    226  789a
    227  789a							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    228  789a							; we're at the throttle cutoff do we switch game-frames.
    229  789a
    230  789a							;sec
    231  789a		       a5 b7		      lda	Throttle	;3
    232  789c		       e9 a0		      sbc	#MAX_THROTTLE	;2
    233  789e		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    234  78a0
    235  78a0							; Time is up. But we may be in a level which requires perfect sorting
    236  78a0							; So we check for these levels, and wait for the sort to complete for those.
    237  78a0
    238  78a0		       24 b6		      bit	levelDisplay	;3
    239  78a2		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    240  78a4
    241  78a4							; We have a level which requires the sort to go to completion
    242  78a4							; Check to see if the sort is finished...
    243  78a4
    244  78a4		       a4 cc		      ldy	sortPtr	;3
    245  78a6		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    246  78a8		       a4 cb		      ldy	sortRequired	;3
    247  78aa		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    248  78ac
    249  78ac		       85 b7	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    250  78ae
    251  78ae							; Pause the game with B/W switch:
    252  78ae
    253  78ae		       a5 80		      lda	gameMode
    254  78b0		       30 14		      bmi	.paused	; pause flag set
    255  78b2
    256  78b2							; Now that we have completed processing the object stack, we switch
    257  78b2							; the stack bank pointers for the next time around.
    258  78b2
    259  78b2		       a5 85		      lda	ObjStackNum	;3
    260  78b4		       49 01		      eor	#1	;2
    261  78b6		       aa		      tax		;2
    262  78b7		       86 85		      stx	ObjStackNum	;3		 swap stacks @here
    263  78b9
    264  78b9							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    265  78b9							; this code is finished, so we don't want it to do something unexpected!
    266  78b9
    267  78b9		       a0 ff		      ldy	#<(-1)	;2
    268  78bb		       84 cb		      sty	sortRequired	;3
    269  78bd		       c8		      iny		;2		 Y==0
    270  78be		       84 cc		      sty	sortPtr	;3
    271  78c0
    272  78c0							; Initialise the iterator and stack pointer for next time around.
    273  78c0							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    274  78c0							; necessary to initialise both.
    275  78c0
    276  78c0		       84 cd		      sty	ObjIterator	;3		 Y==0
    277  78c2		       94 86		      sty	ObjStackPtr,x	;4
    278  78c4
    279  78c4		       84 89		      sty	ScreenDrawPhase	;3
    280  78c6				   .paused
    281  78c6		       60	   quickExit  rts		;6
    282  78c7
    283  78c7							;---------------------------------------------------------------------------
    284  78c7
    285  78c7				  -	      if	0
    286  78c7				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
    287  78c7				  -
    288  78c7				  -	      ldy	#CHARACTER_BLANK
    289  78c7				  -	      lda	circle_d+1
    290  78c7				  -			;jsr DrawCircle
    291  78c7				  -			;bcc finCircle
    292  78c7				  -			;lda #TYPE_CIRCLE_DRAWER
    293  78c7				  -			;sta POS_Type
    294  78c7				  -			;jsr InsertObjectStack
    295  78c7				  -finCircle  jmp	NextObject
    296  78c7				  -
    297  78c7				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
    298  78c7				  -
    299  78c7				  -	      lda	INTIM
    300  78c7				  -	      cmp	#SEGTIME_CIRCLE_HELPER
    301  78c7				  -	      bcc	EarlyAbort
    302  78c7				  -
    303  78c7				  -
    304  78c7				  -	      jmp	NextObject	; and die
    305  78c7				  -
    306  78c7				  -
    307  78c7				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE
    308  78c7				  -
    309  78c7				  -	      lda	INTIM
    310  78c7				  -	      cmp	#SEGTIME_CIRCLE
    311  78c7				  -	      bcc	EarlyAbort
    312  78c7				  -
    313  78c7				  -	      clc
    314  78c7				  -	      lda	circle_d
    315  78c7				  -	      adc	#255
    316  78c7				  -	      sta	circle_d
    317  78c7				  -	      bcc	inactiveCircle
    318  78c7				  -
    319  78c7				  -	      inc	circle_d+1
    320  78c7				  -	      lda	circle_d+1
    321  78c7				  -	      cmp	#20
    322  78c7				  -	      beq	circleComplete
    323  78c7				  -			; time to fire off another "ring" of the clearing circle
    324  78c7				  -
    325  78c7				  -			;sta POS_VAR		    ; diameter for helper to use
    326  78c7				  -			;lda #TYPE_CIRCLE_HELPER
    327  78c7				  -			;sta POS_Type
    328  78c7				  -			;jsr InsertObjectStack
    329  78c7				  -
    330  78c7				  -
    331  78c7				  -			; a = radius
    332  78c7				  -
    333  78c7				  -	      ldy	#CHARACTER_BLANK
    334  78c7				  -	      sty	circ_char
    335  78c7				  -
    336  78c7				  -	      lda	circle_d+1
    337  78c7				  -	      sec
    338  78c7				  -	      sbc	#1
    339  78c7				  -	      sta	circ_x
    340  78c7				  -	      eor	#255
    341  78c7				  -	      clc
    342  78c7				  -	      adc	#1
    343  78c7				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    344  78c7				  -
    345  78c7				  -	      lda	#0
    346  78c7				  -	      sta	circ_y
    347  78c7				  -
    348  78c7				  -			;lda circle_d+1		     ; radius
    349  78c7				  -			;lda #TYPE_CIRCLE_DRAWER
    350  78c7				  -			;sta POS_Type
    351  78c7				  -			;jsr InsertObjectStack
    352  78c7				  -
    353  78c7				  -	      ldy	#CHARACTER_BLANK
    354  78c7				  -	      lda	circle_d+1
    355  78c7				  -			;	      sec
    356  78c7				  -			;	      sbc #1
    357  78c7				  -	      jsr	DrawCircle
    358  78c7				  -
    359  78c7				  -			;	      ldy #CHARACTER_STEEL
    360  78c7				  -			;		sty circ_char
    361  78c7				  -	      lda	circle_d+1
    362  78c7				  -	      sta	circ_x
    363  78c7				  -	      eor	#255
    364  78c7				  -	      clc
    365  78c7				  -	      adc	#1
    366  78c7				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    367  78c7				  -
    368  78c7				  -	      lda	#0
    369  78c7				  -	      sta	circ_y
    370  78c7				  -
    371  78c7				  -			;lda circle_d+1		     ; radius
    372  78c7				  -			;lda #TYPE_CIRCLE_DRAWER
    373  78c7				  -			;sta POS_Type
    374  78c7				  -			;jsr InsertObjectStack
    375  78c7				  -
    376  78c7				  -			;	      ldy #CHARACTER_BLANK
    377  78c7				  -			;	      lda circle_d+1
    378  78c7				  -			;	      ;jsr DrawCircle
    379  78c7				  -
    380  78c7				  -
    381  78c7				  -
    382  78c7				  -			;			      inc circle_d+1
    383  78c7				  -			;			      ldy #CHARACTER_STEEL
    384  78c7				  -			;			      lda circle_d+1
    385  78c7				  -			;			      jsr DrawCircle
    386  78c7				  -
    387  78c7				  -inactiveCircle lda	#TYPE_CIRCLE
    388  78c7				  -	      sta	POS_Type
    389  78c7				  -	      jsr	InsertObjectStack
    390  78c7				  -
    391  78c7				  -circleComplete jmp	NextObject
    392  78c7					      endif
    393  78c7
    394  78c7							;---------------------------------------------------------------------------
    395  78c7
    396  78c7		       60	   EarlyAbort4 rts
    397  78c8
      0  78c8					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78c8		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78c8					      SUBROUTINE
      3  78c8				   PROCESS_MAN
    399  78c8
    400  78c8		       ad 84 02 	      lda	INTIM
    401  78cb		       c9 18		      cmp	#SEGTIME_MAN
    402  78cd		       90 f8		      bcc	EarlyAbort4
      0  78cf					      STRESS_TIME	SEGTIME_MAN
      1  78cf				  -	      IF	TEST_SEGTIME_MAN = 1
      2  78cf				  -
      3  78cf				  -
      4  78cf				  -
      5  78cf				  -
      6  78cf				  -
      7  78cf				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78cf				  -	      bne	. - 7
      9  78cf					      ENDIF
    404  78cf
    405  78cf		       a9 0b		      lda	#BANK_ManProcess
    406  78d1		       85 c4		      sta	ROM_Bank
    407  78d3		       85 3f		      sta	SET_BANK
    408  78d5		       20 85 f1 	      jsr	ManProcess
    409  78d8
    410  78d8		       20 59 f9 	      jsr	MovePlayer	; 6+{}
    411  78db
    412  78db		       a5 9f		      lda	ManMode
    413  78dd		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    414  78df		       b0 08		      bcs	notComplete
    415  78e1		       a5 b9		      lda	targetsRequired
    416  78e3		       d0 04		      bne	notComplete
    417  78e5		       a9 07		      lda	#MANMODE_NEXTLEVEL
    418  78e7		       85 9f		      sta	ManMode
    419  78e9				   notComplete
    420  78e9
    421  78e9
    422  78e9		       a9 03		      lda	#BANK_TrackPlayer	;
    423  78eb		       85 3f		      sta	SET_BANK	;
    424  78ed		       20 8d f4 	      jsr	TrackPlayer	;11+145
    425  78f0
    426  78f0		       a9 00		      lda	#TYPE_MAN	; 2
    427  78f2		       85 8e		      sta	POS_Type	; 3
    428  78f4
    429  78f4		       20 29 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    430  78f7		       4c 1c f9    gnobj      jmp	NextObject
    431  78fa
    432  78fa							;---------------------------------------------------------------------------
    433  78fa
      0  78fa					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  78fa		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  78fa					      SUBROUTINE
      3  78fa				   RestoreOriginalCharacter
    435  78fa
    436  78fa		       a6 8b		      ldx	POS_Y	;3
    437  78fc		       a4 8a		      ldy	POS_X	;3
    438  78fe
    439  78fe		       a9 0b		      lda	#BANK_BoardLineStartLO	;2
    440  7900		       85 3f		      sta	SET_BANK	;3
    441  7902
    442  7902		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    443  7905		       85 c2		      sta	Board_AddressW	;3
    444  7907		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    445  790a		       85 c3		      sta	Board_AddressW+1	;3 WRITE address
    446  790c				  -	      IF	MULTI_BANK_BOARD = YES
    447  790c				  -	      lda	BoardBank,x	;4 switch this on return
    448  790c					      ELSE
    449  790c		       a9 0d		      lda	#BANK_BOARD	;2
    450  790e					      ENDIF
    451  790e		       85 3e		      sta	SET_BANK_RAM	;3
    452  7910
    453  7910		       a5 8f		      lda	POS_VAR
    454  7912		       91 c2		      sta	(Board_AddressW),y	;6 clear vacated board position
    455  7914
    456  7914		       a5 c4		      lda	ROM_Bank	;3
    457  7916		       85 3f		      sta	SET_BANK	;3
    458  7918		       60	   EarlyAbortBOX rts		;6
    459  7919
    460  7919
    461  7919							;---------------------------------------------------------------------------
    462  7919
    463  7919							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    464  7919							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    465  7919
    466  7919							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    467  7919
    468  7919							; if the creature dies then jump NextObject
    469  7919
    470  7919
    471  7919		       20 29 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    472  791c
    473  791c		       e6 cd	   NextObject inc	ObjIterator	; 5
    474  791e							;		  dec ObjStackPtr,x		  ; 6
    475  791e		       4c 50 f8 	      jmp	ProcessObjStack	; 3 = 16
    476  7921
    477  7921							;---------------------------------------------------------------------------
    478  7921
      0  7921					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  7921		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  7921					      SUBROUTINE
      3  7921				   InsertObjectStackFromRAM
    480  7921
    481  7921		       20 29 f9 	      jsr	InsertObjectStack	;6+76(B)
    482  7924		       a5 c5		      lda	RAM_Bank	;3
    483  7926		       85 3e		      sta	SET_BANK_RAM	;3
    484  7928
    485  7928		       60	   NotEnoughTime rts		;6
    486  7929
    487  7929							;---------------------------------------------------------------------------
    488  7929
      0  7929					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7929		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7929					      SUBROUTINE
      3  7929				   InsertObjectStack
    490  7929							; POS_X     x position
    491  7929							; POS_Y     y position
    492  7929							; POS_VAR   direction or other variable
    493  7929							; POS_Type  type of object
    494  7929
    495  7929		       a6 85		      ldx	ObjStackNum	; 3
    496  792b		       bc 57 f9 	      ldy	BankObjStack,x	; 4
    497  792e		       84 3e		      sty	SET_BANK_RAM	; 3
    498  7930		       b4 86		      ldy	ObjStackPtr,x	; 4 = 14
    499  7932
    500  7932
    501  7932		       a5 8b		      lda	POS_Y	; 3
    502  7934		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    503  7937		       a5 8a		      lda	POS_X	; 3
    504  7939		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    505  793c		       a5 8f		      lda	POS_VAR	; 3
    506  793e		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    507  7941		       a5 8e		      lda	POS_Type	; 3
    508  7943		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    509  7946
    510  7946							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    511  7946							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    512  7946							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    513  7946
    514  7946
    515  7946				  -	      IF	TYPE_MAN != 0
    516  7946				  -	      cmp	#TYPE_MAN	; 2
    517  7946					      ENDIF
    518  7946		       f0 04		      beq	alwaysAllowMan	; 2/3
    519  7948
    520  7948		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    521  794a		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    522  794c				   alwaysAllowMan
    523  794c
    524  794c		       98		      tya		; 2
    525  794d		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    526  7950
    527  7950		       f6 86		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    528  7952
    529  7952		       a4 c4	   insertDone ldy	ROM_Bank	; 3
    530  7954		       84 3f		      sty	SET_BANK	; 3
    531  7956
    532  7956				   ManIsDead2
    533  7956
    534  7956
    535  7956
    536  7956		       60		      rts		; 6 = 29
    537  7957
    538  7957							;---------------------------------------------------------------------------
    539  7957
    540  7957		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    541  7959
    542  7959							;---------------------------------------------------------------------------
    543  7959
    544  7959				   MovePlayer
    545  7959		       a5 9f		      lda	ManMode
    546  795b		       c9 02		      cmp	#MANMODE_DEAD
    547  795d		       b0 f7		      bcs	ManIsDead2
    548  795f
    549  795f		       a4 8d		      ldy	POS_Y_NEW
    550  7961
    551  7961		       a9 0b		      lda	#BANK_GetBoardAddressRW	;2
    552  7963		       85 3f		      sta	SET_BANK	;3
    553  7965		       85 c4		      sta	ROM_Bank	;3
    554  7967		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    555  796a				  -	      IF	MULTI_BANK_BOARD = YES
    556  796a				  -	      stx	RAM_Bank
    557  796a					      ENDIF
    558  796a		       86 3e		      stx	SET_BANK_RAM	; 3
    559  796c
    560  796c		       a4 8c		      ldy	POS_X_NEW
    561  796e		       b3 c0		      lax	(Board_AddressR),y
    562  7970
    563  7970		       a9 0b		      lda	#BANK_MoveVecLO
    564  7972		       85 3f		      sta	SET_BANK
    565  7974
    566  7974		       bd ef f2 	      lda	MoveVecLO,x
    567  7977		       85 da		      sta	MAN_Move
    568  7979		       bd f9 f2 	      lda	MoveVecHI,x
    569  797c		       85 db		      sta	MAN_Move+1
    570  797e
    571  797e				  -	      IF	MULTI_BANK_BOARD = YES
    572  797e				  -	      lda	RAM_Bank
    573  797e					      ELSE
    574  797e		       a9 0d		      lda	#BANK_BOARD
    575  7980					      ENDIF
    576  7980		       85 3e		      sta	SET_BANK_RAM
    577  7982		       6c da 00 	      jmp	(MAN_Move)
    578  7985
    579  7985							;---------------------------------------------------------------------------
    580  7985
      0  7985					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  7985		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  7985					      SUBROUTINE
      3  7985				   MOVE_BLANK
      0  7985					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  7985		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  7985					      SUBROUTINE
      3  7985				   MOVE_SOIL
      0  7985					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  7985		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  7985					      SUBROUTINE
      3  7985				   MOVE_TARGET
    584  7985
    585  7985		       a4 8c		      ldy	POS_X_NEW
    586  7987		       b1 c0		      lda	(Board_AddressR),y	; what's on the board under man?
    587  7989		       48		      pha
    588  798a
    589  798a		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    590  798c		       91 c2		      sta	(Board_AddressW),y
    591  798e
    592  798e		       a6 9c		      ldx	ManY
    593  7990		       86 8b		      stx	POS_Y
    594  7992		       a4 9b		      ldy	ManX
    595  7994		       84 8a		      sty	POS_X
    596  7996
    597  7996		       20 fa f8 	      jsr	RestoreOriginalCharacter
    598  7999
    599  7999		       68		      pla
    600  799a		       85 8f		      sta	POS_VAR	; save 'restore' characte
    601  799c
    602  799c		       a9 0e		      lda	#BANK_TAKEBACK
    603  799e		       85 3e		      sta	SET_BANK_RAM
    604  79a0
    605  79a0		       a6 bc		      ldx	moveCounterBinary
    606  79a2
    607  79a2		       a5 8c		      lda	POS_X_NEW
    608  79a4		       85 9b		      sta	ManX
    609  79a6		       9d 00 14 	      sta	RAM_WRITE+TakeBackX,x
    610  79a9
    611  79a9		       a5 8d		      lda	POS_Y_NEW
    612  79ab		       85 9c		      sta	ManY	; actually MOVE!
    613  79ad		       9d 00 15 	      sta	RAM_WRITE+TakeBackY,x
    614  79b0
    615  79b0		       a5 8f		      lda	POS_VAR	; replace char
    616  79b2		       9d 00 16 	      sta	RAM_WRITE+TakeBackA,x
    617  79b5
    618  79b5		       a5 c5		      lda	RAM_Bank
    619  79b7		       85 3e		      sta	SET_BANK_RAM
    620  79b9
    621  79b9							; Move counter..
    622  79b9
    623  79b9		       e6 bc		      inc	moveCounterBinary
    624  79bb
    625  79bb		       f8		      sed
    626  79bc		       18		      clc
    627  79bd		       a5 ba		      lda	moveCounter
    628  79bf		       69 01		      adc	#1
    629  79c1		       85 ba		      sta	moveCounter
    630  79c3		       a5 bb		      lda	moveCounter+1
    631  79c5		       69 00		      adc	#0
    632  79c7		       85 bb		      sta	moveCounter+1
    633  79c9		       d8		      cld
    634  79ca
    635  79ca		       a9 00	   MOVE_GENERIC lda	#0	; 2
    636  79cc		       85 a5		      sta	ManPushCounter	; 3
    637  79ce
    638  79ce		       60	   timeExit   rts		; 6 = 11
    639  79cf
    640  79cf							;---------------------------------------------------------------------------
    641  79cf
      0  79cf					      DEFINE_SUBROUTINE	MOVE_BOX
      1  79cf		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  79cf					      SUBROUTINE
      3  79cf				   MOVE_BOX
    643  79cf
    644  79cf		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    645  79d1		       a9 0b		      lda	#BANK_PushBox
    646  79d3		       85 c4		      sta	ROM_Bank
    647  79d5		       85 3f		      sta	SET_BANK
    648  79d7		       4c f5 f0 	      jmp	PushBox
    649  79da
      0  79da					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  79da		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  79da					      SUBROUTINE
      3  79da				   MOVE_BOX_ON_TARGET
    651  79da
    652  79da		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    653  79dc		       a9 0b		      lda	#BANK_PushBox
    654  79de		       85 c4		      sta	ROM_Bank
    655  79e0		       85 3f		      sta	SET_BANK
    656  79e2		       4c f5 f0 	      jmp	PushBox
    657  79e5
    658  79e5							;---------------------------------------------------------------------------
    659  79e5
      0  79e5					      DEFINE_SUBROUTINE	restorePreviousManPosition
      1  79e5		       00 0f	   BANK_restorePreviousManPosition =	_CURRENT_BANK
      2  79e5					      SUBROUTINE
      3  79e5				   restorePreviousManPosition
    661  79e5
    662  79e5		       a6 bc		      ldx	moveCounterBinary
    663  79e7		       f0 21		      beq	noMovesToTake
    664  79e9		       ca		      dex
    665  79ea		       c6 bc		      dec	moveCounterBinary
    666  79ec
    667  79ec		       a9 0e		      lda	#BANK_TAKEBACK
    668  79ee		       85 3e		      sta	SET_BANK_RAM
    669  79f0
    670  79f0		       bd 00 10 	      lda	TakeBackX,x
    671  79f3		       85 8a		      sta	POS_X
    672  79f5		       85 8c		      sta	POS_X_NEW
    673  79f7		       bd 00 11 	      lda	TakeBackY,x
    674  79fa		       85 8b		      sta	POS_Y
    675  79fc		       85 8d		      sta	POS_Y_NEW
    676  79fe		       bd 00 12 	      lda	TakeBackA,x
    677  7a01		       85 8f		      sta	POS_VAR
    678  7a03
    679  7a03							; Put character @ X,Y
    680  7a03		       20 fa f8 	      jsr	RestoreOriginalCharacter
    681  7a06
    682  7a06		       a5 c4		      lda	ROM_Bank
    683  7a08		       85 3f		      sta	SET_BANK
    684  7a0a
    685  7a0a		       60	   noMovesToTake rts
    686  7a0b
    687  7a0b							;---------------------------------------------------------------------------
    688  7a0b
      0  7a0b					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a0b		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a0b					      SUBROUTINE
      3  7a0b				   StealCharDraw
    690  7a0b
    691  7a0b		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    692  7a0d		       85 3e		      sta	SET_BANK_RAM	; 3
    693  7a0f		       a4 84		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    694  7a11		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    695  7a13
    696  7a13				   ExitStealCharDraw
    697  7a13
    698  7a13							; fall through...
    699  7a13
    700  7a13							;---------------------------------------------------------------------------
    701  7a13
      0  7a13					      DEFINE_SUBROUTINE	TimeSlice
      1  7a13		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a13					      SUBROUTINE
      3  7a13				   TimeSlice
    703  7a13
    704  7a13							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    705  7a13							; going ahead if there's insufficient time. This allows the previous character drawing to
    706  7a13							; be much smaller in time, as they don't have to include the timeslice code overhead.
    707  7a13
    708  7a13		       ad 84 02 	      lda	INTIM	; 4
    709  7a16		       c9 03		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    710  7a18		       90 b4		      bcc	timeExit	; 2(3)
    711  7a1a
    712  7a1a							; Uses the phase variable to vector to the correct processing code for the given timeslice
    713  7a1a							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    714  7a1a							; it should increment ScreenDrawPhase.
    715  7a1a
    716  7a1a							; Switched-in bank(s) are undefined after this function is called!
    717  7a1a
    718  7a1a		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    719  7a1c		       85 3f		      sta	SET_BANK	; 3
    720  7a1e
    721  7a1e		       a6 89		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    722  7a20		       bd 14 f5 	      lda	TS_PhaseVectorLO,x	; 4
    723  7a23		       85 da		      sta	TS_Vector	; 3
    724  7a25		       bd 19 f5 	      lda	TS_PhaseVectorHI,x	; 4
    725  7a28		       85 db		      sta	TS_Vector+1	; 3
    726  7a2a
    727  7a2a		       bd 1e f5 	      lda	TS_PhaseBank,x	; 4
    728  7a2d		       85 3f		      sta	SET_BANK	; 3		 switch bank
    729  7a2f
    730  7a2f		       6c da 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    731  7a32
    732  7a32							; = 55 minimum return time (if segtime abort)
    733  7a32
    734  7a32							;---------------------------------------------------------------------------
    735  7a32
    736  7a32
    737  7a32				   DrawAnother
    738  7a32
    739  7a32		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    740  7a34		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    741  7a36
    742  7a36		       a4 84		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    743  7a38
    744  7a38		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    745  7a3b		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    746  7a3e		       29 7f		      and	#~128	; 2
    747  7a40		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    748  7a43
    749  7a43		       88		      dey		; 2
    750  7a44		       84 84		      sty	DrawStackPointer	; 3	     one less to draw
    751  7a46		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    752  7a48
    753  7a48				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    754  7a48
    755  7a48		       ad 84 02 	      lda	INTIM	; 4
    756  7a4b		       c9 03		      cmp	#SEGTIME_SCD_MIN	; 2
    757  7a4d		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    758  7a4f
    759  7a4f		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    760  7a52		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    761  7a55
    762  7a55		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    763  7a58		       85 3e		      sta	SET_BANK_RAM	; 3
    764  7a5a		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    765  7a5d
    766  7a5d
    767  7a5d
    768  7a5d
      0  7a5d					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7a5d		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7a5d					      SUBROUTINE
      3  7a5d				   DrawFullScreenMain
    770  7a5d
    771  7a5d							; Check the screen for all those characters that need to be redrawn
    772  7a5d							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    773  7a5d							; the drawflags array is different to the ScreenBuffer array entry, then the
    774  7a5d							; screenbuffer will need redrawing.
    775  7a5d
    776  7a5d				   CopyRow2
    777  7a5d
    778  7a5d				  -	      IF	MULTI_BANK_BOARD = YES
    779  7a5d				  -	      lda	BDF_BoardBank	; 3
    780  7a5d					      ELSE
    781  7a5d		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    782  7a5f					      ENDIF
    783  7a5f		       85 3e		      sta	SET_BANK_RAM	; 3
    784  7a61		       b3 de		      lax	(BDF_BoardAddress),y	; 5
    785  7a63		       9a		      txs		; 2
    786  7a64		       b3 e0		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
    787  7a66
    788  7a66		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    789  7a68		       85 3e		      sta	SET_BANK_RAM	; 3
    790  7a6a		       bd cd f1 	      lda	CharReplacement,x	; 4
    791  7a6d		       91 dc		      sta	(BDF_DrawFlagAddress2),y	; 6
    792  7a6f		       ba		      tsx		; 2
    793  7a70		       bd cd f1 	      lda	CharReplacement,x	; 4
    794  7a73		       91 da		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
    795  7a75
    796  7a75		       88		      dey		; 2
    797  7a76		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
    798  7a78							; total: 5*(50[-1])-1 = 244 *OR*  249 (MB)
    799  7a78
    800  7a78		       a7 e3		      lax	DHS_Line	; 3
    801  7a7a		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    802  7a7c
    803  7a7c		       a0 0b		      ldy	#BANK_DrawScreenRowPreparation	;2
    804  7a7e		       84 3f		      sty	SET_BANK	; 3
    805  7a80		       4c ba f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
    806  7a83
    807  7a83							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    808  7a83
    809  7a83
      0  7a83					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7a83					      LIST	ON
    811  7a83
    812  7a83		       a6 e4	   .exitCopy  ldx	DHS_Stack	; 3
    813  7a85		       9a		      txs		; 2
    814  7a86
    815  7a86							; fall through
    816  7a86
      0  7a86					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7a86		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7a86					      SUBROUTINE
      3  7a86				   BuildDrawStack
    818  7a86
    819  7a86		       a9 08		      lda	#BANK_DRAW_BUFFERS
    820  7a88		       85 3e		      sta	SET_BANK_RAM
    821  7a8a		       4c f1 f0 	      jmp	DrawStackUpdate
    822  7a8d
    823  7a8d							;---------------------------------------------------------------------------
    824  7a8d
      0  7a8d					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7a8d		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7a8d					      SUBROUTINE
      3  7a8d				   DrawAIntoStack
    826  7a8d
    827  7a8d		       a9 08		      lda	#BANK_DRAW_BUFFERS
    828  7a8f		       85 3e		      sta	SET_BANK_RAM
    829  7a91		       4c 1a f1 	      jmp	DrawIntoStack
    830  7a94
    831  7a94
    832  7a94							;---------------------------------------------------------------------------
    833  7a94
    834  7a94
    835  7a94				   Reset
      0  7a94					      CLEAN_START
      1  7a94		       78		      sei
      2  7a95		       d8		      cld
      3  7a96
      4  7a96		       a2 00		      ldx	#0
      5  7a98		       8a		      txa
      6  7a99		       a8		      tay
      7  7a9a		       ca	   .CLEAR_STACK dex
      8  7a9b		       9a		      txs
      9  7a9c		       48		      pha
     10  7a9d		       d0 fb		      bne	.CLEAR_STACK
     11  7a9f
    837  7a9f
    838  7a9f							;lda #2
    839  7a9f							;sta VSYNC
    840  7a9f							;lda #%01000010		  ; bit6 is not required
    841  7a9f							;sta VBLANK			  ; end of screen - enter blanking
    842  7a9f
    843  7a9f							; Scoring bank is copied once (not per game, not per level...)
    844  7a9f							; otherwise non-SaveKey high score gets zapped
    845  7a9f
    846  7a9f		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
    847  7aa1		       a0 09		      ldy	#BANK_SCORING
    848  7aa3		       20 8d fc 	      jsr	CopyROM2RAM_F000
    849  7aa6
    850  7aa6				   Restart		; go here on RESET + SELECT
    851  7aa6
    852  7aa6
    853  7aa6				   Title
    854  7aa6		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
    855  7aa8		       9a		      txs
    856  7aa9
    857  7aa9							; temporary vars from title screen are used to init level
    858  7aa9		       a9 03		      lda	#BANK_Cart_Init	; 2
    859  7aab		       85 3f		      sta	SET_BANK	; 3
    860  7aad		       20 98 f3 	      jsr	Cart_Init	; 6+x
    861  7ab0
    862  7ab0
    863  7ab0							;---------------------------------------------------------------------------
    864  7ab0
    865  7ab0
    866  7ab0		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
    867  7ab0
    868  7ab0		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
    869  7ab2		       a0 0a		      ldy	#BANK_DECODE_LEVEL
    870  7ab4		       20 8d fc 	      jsr	CopyROM2RAM_F000
    871  7ab7
    872  7ab7
    873  7ab7							;---------------------------------------------------------------------------
    874  7ab7							; Once-only game initialisation goes here...
    875  7ab7							; now we have two players so things get a bit tricky
    876  7ab7
    877  7ab7		       a9 09		      lda	#BANK_SCORING
    878  7ab9		       85 3e		      sta	SET_BANK_RAM
    879  7abb		       20 63 f3 	      jsr	GameInitialise
    880  7abe
    881  7abe
    882  7abe							;---------------------------------------------------------------------------
    883  7abe
------- FILE sound/intro1_init.asm LEVEL 3 PASS 4
      0  7abe					      include	"sound/intro1_init.asm"
      1  7abe							; TIATracker music player
      2  7abe							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7abe							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7abe							; Email: andre.wichmann@gmx.de
      5  7abe							;
      6  7abe							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7abe							; you may not use this file except in compliance with the License.
      8  7abe							; You may obtain a copy of the License at
      9  7abe							;
     10  7abe							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7abe							;
     12  7abe							; Unless required by applicable law or agreed to in writing, software
     13  7abe							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7abe							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7abe							; See the License for the specific language governing permissions and
     16  7abe							; limitations under the License.
     17  7abe
     18  7abe							; Song author: 
     19  7abe							; Song name: 
     20  7abe
     21  7abe							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7abe
     23  7abe							; =====================================================================
     24  7abe							; Initialize music.
     25  7abe							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7abe							; tt_SequenceTable for each channel.
     27  7abe							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7abe							; All other variables can start with any value.
     29  7abe							; =====================================================================
     30  7abe		       a9 00		      lda	#0
     31  7ac0		       85 d0		      sta	tt_cur_pat_index_c0
     32  7ac2		       a9 05		      lda	#5
     33  7ac4		       85 d1		      sta	tt_cur_pat_index_c1
     34  7ac6							; the rest should be 0 already from startup code. If not,
     35  7ac6							; set the following variables to 0 manually:
     36  7ac6							; - tt_timer
     37  7ac6							; - tt_cur_pat_index_c0
     38  7ac6							; - tt_cur_pat_index_c1
     39  7ac6							; - tt_cur_note_index_c0
     40  7ac6							; - tt_cur_note_index_c1
     41  7ac6
------- FILE BANK_FIXED.asm
    885  7ac6
      0  7ac6					      SET_PLATFORM
      1  7ac6
      2  7ac6
      3  7ac6
      4  7ac6
      5  7ac6		       ad 82 02 	      lda	SWCHB
      6  7ac9		       2a		      rol
      7  7aca		       2a		      rol
      8  7acb		       2a		      rol
      9  7acc		       29 03		      and	#%11
     10  7ace		       49 02		      eor	#PAL
     11  7ad0		       85 81		      sta	Platform
    887  7ad2
    888  7ad2		       a9 0a		      lda	#BANK_TitleScreen
    889  7ad4		       85 3f		      sta	SET_BANK
    890  7ad6		       20 00 f0 	      jsr	TitleSequence
    891  7ad9
    892  7ad9				   RestartLevelNextPlayer
    893  7ad9
    894  7ad9
    895  7ad9							; a player has lost a life.
    896  7ad9							; store his vars, swap to other player, continue
    897  7ad9
    898  7ad9							;lda #BANK_SCORING
    899  7ad9							;sta SET_BANK_RAM
    900  7ad9							;jsr SwapPlayers
    901  7ad9
    902  7ad9		       a9 03		      lda	#BANK_SwapPlayersGeneric
    903  7adb		       85 3f		      sta	SET_BANK
    904  7add		       20 ef f3 	      jsr	SwapPlayersGeneric
    905  7ae0
    906  7ae0				   NextLevelLevel
    907  7ae0				   skipDemoCheck
    908  7ae0
    909  7ae0							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
    910  7ae0							; including those for general systems function. But NOT those which do not need re-initialising between
    911  7ae0							; levels.
    912  7ae0		       a9 03		      lda	#BANK_LevelInit	; 2
    913  7ae2		       85 3f		      sta	SET_BANK	; 3
    914  7ae4		       20 3e f4 	      jsr	LevelInit	; 6+x
    915  7ae7
    916  7ae7		       a9 00		      lda	#0
    917  7ae9		       85 da		      sta	base_x
    918  7aeb		       85 db		      sta	base_y
    919  7aed
    920  7aed		       a9 0a		      lda	#BANK_DECODE_LEVEL
    921  7aef		       85 3e		      sta	SET_BANK_RAM
    922  7af1		       20 29 f2 	      jsr	UnpackLevel
    923  7af4
    924  7af4							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
    925  7af4
    926  7af4		       a9 28		      lda	#SIZE_BOARD_X
    927  7af6		       85 94		      sta	BoardLimit_Width
    928  7af8		       a9 16		      lda	#SIZE_BOARD_Y
    929  7afa		       85 95		      sta	BoardLimit_Height
    930  7afc
    931  7afc							; Setup player animation and scroll limits.
    932  7afc							; Mangle the board colours based on level
    933  7afc
    934  7afc		       a9 03		      lda	#BANK_CreateCreatures	; 2
    935  7afe		       85 3f		      sta	SET_BANK	; 3
    936  7b00		       20 07 f4 	      jsr	CreateCreatures	; 6+x
    937  7b03
    938  7b03							; Setup the various digit and display pointers
    939  7b03							; Grab current player's score/level from backup
    940  7b03
    941  7b03		       a9 09		      lda	#BANK_SCORING
    942  7b05		       85 3e		      sta	SET_BANK_RAM
    943  7b07		       20 95 f2 	      jsr	GeneralScoringSetups
    944  7b0a							;lda ROM_Bank
    945  7b0a							;sta SET_BANK
    946  7b0a
    947  7b0a							; copy the screen draw ROM shadow to RAM
    948  7b0a
    949  7b0a		       a0 07		      ldy	#SCREEN_LINES-1
    950  7b0c		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
    951  7b0e		       20 8d fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
    952  7b11		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
    953  7b14		       88		      dey
    954  7b15		       10 f5		      bpl	CopyScreenBanks
    955  7b17
    956  7b17		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    957  7b19		       a0 08		      ldy	#BANK_DRAW_BUFFERS
    958  7b1b		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
    959  7b1e
    960  7b1e							;---------------------------------------------------------------------------
    961  7b1e
    962  7b1e		       a9 03		      lda	#BANK_Resync	; 2
    963  7b20		       85 3f		      sta	SET_BANK	; 3
    964  7b22		       20 69 f4 	      jsr	Resync	; 6+x
    965  7b25
    966  7b25
    967  7b25
    968  7b25				   NewFrameStart
    969  7b25
    970  7b25		       24 ca		      bit	NextLevelTrigger
    971  7b27		       10 b7		      bpl	NextLevelLevel	; game-triggered next level
    972  7b29		       70 ae		      bvs	RestartLevelNextPlayer	; loss of life
    973  7b2b
    974  7b2b							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
    975  7b2b
    976  7b2b		       a9 0e		      lda	#%1110	; VSYNC ON
    977  7b2d		       85 42	   .loopVSync sta	WSYNC
    978  7b2f		       85 40		      sta	VSYNC
    979  7b31		       4a		      lsr
    980  7b32		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
    981  7b34
    982  7b34							; moved *after* the loop since this allows to *increase* timer values by 1!
    983  7b34
    984  7b34		       a6 81		      ldx	Platform
    985  7b36		       bc 5a fc 	      ldy	VBlankTime,x
    986  7b39		       8c 96 02 	      sty	TIM64T
    987  7b3c
    988  7b3c
------- FILE sound/intro1_player.asm LEVEL 3 PASS 4
      0  7b3c					      include	"sound/intro1_player.asm"
      1  7b3c							; TIATracker music player
      2  7b3c							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b3c							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b3c							; Email: andre.wichmann@gmx.de
      5  7b3c							;
      6  7b3c							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b3c							; you may not use this file except in compliance with the License.
      8  7b3c							; You may obtain a copy of the License at
      9  7b3c							;
     10  7b3c							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b3c							;
     12  7b3c							; Unless required by applicable law or agreed to in writing, software
     13  7b3c							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b3c							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b3c							; See the License for the specific language governing permissions and
     16  7b3c							; limitations under the License.
     17  7b3c
     18  7b3c							; Song author: 
     19  7b3c							; Song name: 
     20  7b3c
     21  7b3c							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b3c
     23  7b3c							; =====================================================================
     24  7b3c							; TIATracker Player
     25  7b3c							; =====================================================================
     26  7b3c				   tt_PlayerStart
     27  7b3c
     28  7b3c							; PLANNED PLAYER VARIANTS:
     29  7b3c							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7b3c							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7b3c							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7b3c							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7b3c							;	 pattern size and max ADSR size
     34  7b3c							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7b3c							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7b3c							;	 (saves table and decode routine)
     37  7b3c							; - Speed: Inline tt_CalcInsIndex
     38  7b3c							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7b3c							;	 Might also save the need for cur_note_index
     40  7b3c
     41  7b3c
     42  7b3c							; ---------------------------------------------------------------------
     43  7b3c							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7b3c							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7b3c							; ---------------------------------------------------------------------
     46  7b3c					      MAC	tt_fetch_current_note
     47  7b3c							; construct ptr to pattern
     48  7b3c				   .constructPatPtr
     49  7b3c					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7b3c					      lda	tt_SequenceTable,y
     51  7b3c					      IF	TT_USE_GOTO = 1
     52  7b3c					      bpl	.noPatternGoto
     53  7b3c					      and	#%01111111	; mask out goto bit to get pattern number
     54  7b3c					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7b3c					      bpl	.constructPatPtr	; unconditional
     56  7b3c				   .noPatternGoto
     57  7b3c					      ENDIF
     58  7b3c					      tay
     59  7b3c					      lda	tt_PatternPtrLo,y
     60  7b3c					      sta	tt_ptr
     61  7b3c					      lda	tt_PatternPtrHi,y
     62  7b3c					      sta	tt_ptr+1
     63  7b3c							; get new note
     64  7b3c					      IF	TT_USE_OVERLAY = 0
     65  7b3c					      ldy	tt_cur_note_index_c0,x
     66  7b3c					      ELSE
     67  7b3c							; If the V flag is set and if the new note is an instrument,
     68  7b3c							; it means it got pre-fetched by an overlay percussion, it has
     69  7b3c							; to remain in sustain.
     70  7b3c					      clv
     71  7b3c							; check if note had been pre-fetched by overlay perc already
     72  7b3c					      lda	tt_cur_note_index_c0,x
     73  7b3c					      bpl	.notPrefetched
     74  7b3c							; If so, remove flag
     75  7b3c					      and	#%01111111
     76  7b3c					      sta	tt_cur_note_index_c0,x
     77  7b3c							; Set V flag for later
     78  7b3c					      bit	tt_Bit6Set
     79  7b3c				   .notPrefetched
     80  7b3c					      tay
     81  7b3c					      ENDIF
     82  7b3c					      lda	(tt_ptr),y
     83  7b3c							; pre-process new note
     84  7b3c							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7b3c							; 0/0: End of pattern
     86  7b3c					      bne	.noEndOfPattern
     87  7b3c							; End of pattern: Advance to next pattern
     88  7b3c					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7b3c					      inc	tt_cur_pat_index_c0,x
     90  7b3c					      bne	.constructPatPtr	; unconditional
     91  7b3c				   .noEndOfPattern
     92  7b3c					      ENDM
     93  7b3c
     94  7b3c
     95  7b3c							; ---------------------------------------------------------------------
     96  7b3c							; Music player entry. Call once per frame.
     97  7b3c							; ---------------------------------------------------------------------
     98  7b3c				   tt_Player  SUBROUTINE
     99  7b3c							; ==================== Sequencer ====================
    100  7b3c							; Decrease speed timer
    101  7b3c		       c6 cf		      dec	tt_timer
    102  7b3e		       10 6e		      bpl	.noNewNote
    103  7b40
    104  7b40							; Timer ran out: Do sequencer
    105  7b40							; Advance to next note
    106  7b40		       a2 01		      ldx	#1	; 2 channels
    107  7b42				   .advanceLoop
    108  7b42					      IF	TT_USE_OVERLAY = 1
    109  7b42		       20 58 fb 	      jsr	tt_FetchNote
    110  7b45				  -	      ELSE
    111  7b45				  -	      TT_FETCH_CURRENT_NOTE
    112  7b45					      ENDIF
    113  7b45							; Parse new note from pattern
    114  7b45		       c9 10		      cmp	#TT_INS_PAUSE
    115  7b47					      IF	TT_USE_SLIDE = 0
    116  7b47		       90 55		      bcc	.finishedNewNote
    117  7b49		       d0 3d		      bne	.newNote
    118  7b4b				  -	      ELSE
    119  7b4b				  -	      beq	.pause
    120  7b4b				  -	      bcs	.newNote
    121  7b4b				  -
    122  7b4b				  -			; --- slide/hold ---
    123  7b4b				  -			; Adjust frequency and hold note in sustain.
    124  7b4b				  -			; composer/tracker has to make sure that no unwanted
    125  7b4b				  -			; under/overflow happens.
    126  7b4b				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7b4b				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7b4b				  -	      sec
    129  7b4b				  -	      sbc	#8
    130  7b4b				  -	      sta	tt_cur_ins_c0,x
    131  7b4b				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7b4b					      ENDIF
    133  7b4b
    134  7b4b							; --- pause ---
    135  7b4b				   .pause
    136  7b4b							; Get release index for current instrument. Since a pause can
    137  7b4b							; only follow an instrument, we don't need to handle percussion
    138  7b4b							; or commands.
    139  7b4b		       b5 d6		      lda	tt_cur_ins_c0,x
    140  7b4d		       20 e6 fb 	      jsr	tt_CalcInsIndex
    141  7b50		       b9 a4 fc 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7b53							; Put it into release. Skip junk byte so index no longer indicates
    143  7b53							; sustain phase.
    144  7b53		       18		      clc
    145  7b54		       69 01		      adc	#1
    146  7b56		       90 44		      bcc	.storeADIndex	; unconditional
    147  7b58
    148  7b58							; ---------------------------------------------------------------------
    149  7b58							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7b58							; TT_USE_OVERLAY is not used.
    151  7b58							; Interleaved here so player can be inlined.
    152  7b58							; ---------------------------------------------------------------------
    153  7b58					      IF	TT_USE_OVERLAY = 1
    154  7b58				   tt_FetchNote
      0  7b58					      TT_FETCH_CURRENT_NOTE
      1  7b58
      2  7b58				   .constructPatPtr
      3  7b58		       b4 d0		      ldy	tt_cur_pat_index_c0,x
      4  7b5a		       b9 b7 fd 	      lda	tt_SequenceTable,y
      5  7b5d					      IF	TT_USE_GOTO = 1
      6  7b5d		       10 06		      bpl	.noPatternGoto
      7  7b5f		       29 7f		      and	#%01111111
      8  7b61		       95 d0		      sta	tt_cur_pat_index_c0,x
      9  7b63		       10 f3		      bpl	.constructPatPtr
     10  7b65				   .noPatternGoto
     11  7b65					      ENDIF
     12  7b65		       a8		      tay
     13  7b66		       b9 ad fd 	      lda	tt_PatternPtrLo,y
     14  7b69		       85 d8		      sta	tt_ptr
     15  7b6b		       b9 b2 fd 	      lda	tt_PatternPtrHi,y
     16  7b6e		       85 d9		      sta	tt_ptr+1
     17  7b70
     18  7b70				  -	      IF	TT_USE_OVERLAY = 0
     19  7b70				  -	      ldy	tt_cur_note_index_c0,x
     20  7b70					      ELSE
     21  7b70
     22  7b70
     23  7b70
     24  7b70		       b8		      clv
     25  7b71
     26  7b71		       b5 d2		      lda	tt_cur_note_index_c0,x
     27  7b73		       10 07		      bpl	.notPrefetched
     28  7b75
     29  7b75		       29 7f		      and	#%01111111
     30  7b77		       95 d2		      sta	tt_cur_note_index_c0,x
     31  7b79
     32  7b79		       2c ec fb 	      bit	tt_Bit6Set
     33  7b7c				   .notPrefetched
     34  7b7c		       a8		      tay
     35  7b7d					      ENDIF
     36  7b7d		       b1 d8		      lda	(tt_ptr),y
     37  7b7f
     38  7b7f
     39  7b7f
     40  7b7f		       d0 06		      bne	.noEndOfPattern
     41  7b81
     42  7b81		       95 d2		      sta	tt_cur_note_index_c0,x
     43  7b83		       f6 d0		      inc	tt_cur_pat_index_c0,x
     44  7b85		       d0 d1		      bne	.constructPatPtr
     45  7b87				   .noEndOfPattern
    156  7b87		       60		      rts
    157  7b88					      ENDIF
    158  7b88
    159  7b88
    160  7b88							; --- start instrument or percussion ---
    161  7b88				   .newNote
    162  7b88		       95 d6		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7b8a							; Instrument or percussion?
    164  7b8a		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7b8c		       b0 06		      bcs	.startInstrument
    166  7b8e
    167  7b8e							; --- start percussion ---
    168  7b8e							; Get index of envelope
    169  7b8e		       a8		      tay
    170  7b8f							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7b8f		       b9 c8 fc 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7b92		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7b94
    174  7b94							; --- start instrument ---
    175  7b94				   .startInstrument
    176  7b94					      IF	TT_USE_OVERLAY = 1
    177  7b94							; If V flag is set, this note had been pre-fetched. That means
    178  7b94							; it should remain in sustain.
    179  7b94		       70 08		      bvs	.finishedNewNote
    180  7b96					      ENDIF
    181  7b96							; Put note into attack/decay
    182  7b96		       20 e6 fb 	      jsr	tt_CalcInsIndex
    183  7b99		       b9 9a fc 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7b9c				   .storeADIndex
    185  7b9c		       95 d4		      sta	tt_envelope_index_c0,x
    186  7b9e
    187  7b9e							; --- Finished parsing new note ---
    188  7b9e				   .finishedNewNote
    189  7b9e							; increase note index into pattern
    190  7b9e		       f6 d2		      inc	tt_cur_note_index_c0,x
    191  7ba0							; loop over channels
    192  7ba0				   .sequencerNextChannel
    193  7ba0		       ca		      dex
    194  7ba1		       10 9f		      bpl	.advanceLoop
    195  7ba3
    196  7ba3							; Reset timer value
    197  7ba3				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7ba3				  -			; Get timer value for current pattern in channel 0
    199  7ba3				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7ba3				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7ba3				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7ba3				  -	      lda	tt_PatternSpeeds,y
    203  7ba3				  -	      sta	tt_timer
    204  7ba3				  -	      ELSE
    205  7ba3				  -			; Test for odd/even frame
    206  7ba3				  -	      lda	tt_cur_note_index_c0
    207  7ba3				  -	      lsr
    208  7ba3				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7ba3				  -	      bcc	.evenFrame
    210  7ba3				  -	      and	#$0f	; does not affect carry flag
    211  7ba3				  -	      bcs	.storeFunkTempo
    212  7ba3				  -.evenFrame
    213  7ba3				  -	      lsr
    214  7ba3				  -	      lsr
    215  7ba3				  -	      lsr
    216  7ba3				  -	      lsr
    217  7ba3				  -.storeFunkTempo
    218  7ba3				  -	      sta	tt_timer
    219  7ba3				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7ba3				  -
    221  7ba3					      ELSE
    222  7ba3							; Global tempo
    223  7ba3		       a2 04		      ldx	#TT_SPEED-1
    224  7ba5					      IF	TT_USE_FUNKTEMPO = 1
    225  7ba5		       a5 d2		      lda	tt_cur_note_index_c0
    226  7ba7		       4a		      lsr
    227  7ba8		       90 02		      bcc	.noOddFrame
    228  7baa		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7bac				   .noOddFrame
    230  7bac					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7bac		       86 cf		      stx	tt_timer
    232  7bae					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7bae
    234  7bae							; No new note to process
    235  7bae				   .noNewNote
    236  7bae
    237  7bae							; ==================== Update registers ====================
    238  7bae		       a2 01		      ldx	#1	; 2 channels
    239  7bb0				   .updateLoop
    240  7bb0							; Percussion or melodic instrument?
    241  7bb0		       b5 d6		      lda	tt_cur_ins_c0,x
    242  7bb2				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7bb2				  -			; This branch can be removed if track starts with a note in each channel
    244  7bb2				  -	      beq	.afterAudioUpdate
    245  7bb2					      ENDIF
    246  7bb2		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7bb4		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7bb6
    249  7bb6							; --- Percussion: Get envelope index ---
    250  7bb6		       b4 d4		      ldy	tt_envelope_index_c0,x
    251  7bb8							; Set AUDC and AUDV value from envelope
    252  7bb8		       b9 f1 fc 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7bbb		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7bbd		       f6 d4		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7bbf				   .endOfPercussion
    256  7bbf		       95 59		      sta	AUDV0,x
    257  7bc1		       4a		      lsr
    258  7bc2		       4a		      lsr
    259  7bc3		       4a		      lsr
    260  7bc4		       4a		      lsr
    261  7bc5		       95 55		      sta	AUDC0,x
    262  7bc7							; Set AUDF
    263  7bc7		       b9 db fc 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7bca							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7bca		       95 57		      sta	AUDF0,x
    266  7bcc					      IF	TT_USE_OVERLAY = 1
    267  7bcc		       10 48		      bpl	.afterAudioUpdate
    268  7bce							; Overlay percussion: Fetch next note out of order
    269  7bce		       20 58 fb 	      jsr	tt_FetchNote
    270  7bd1							; Only do something if it's a melodic instrument
    271  7bd1		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7bd3		       90 41		      bcc	.afterAudioUpdate
    273  7bd5							; Instrument: Put into sustain
    274  7bd5		       95 d6		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7bd7		       20 e6 fb 	      jsr	tt_CalcInsIndex
    276  7bda		       b9 9f fc 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7bdd		       95 d4		      sta	tt_envelope_index_c0,x
    278  7bdf							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7bdf		       16 d2		      asl	tt_cur_note_index_c0,x
    280  7be1		       38		      sec
    281  7be2		       76 d2		      ror	tt_cur_note_index_c0,x
    282  7be4		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7be6				  -	      ELSE
    284  7be6				  -	      jmp	.afterAudioUpdate
    285  7be6					      ENDIF
    286  7be6
    287  7be6
    288  7be6							; ---------------------------------------------------------------------
    289  7be6							; Helper subroutine to minimize ROM footprint.
    290  7be6							; Interleaved here so player routine can be inlined.
    291  7be6							; ---------------------------------------------------------------------
    292  7be6				   tt_CalcInsIndex
    293  7be6							; move upper 3 bits to lower 3
    294  7be6		       4a		      lsr
    295  7be7		       4a		      lsr
    296  7be8		       4a		      lsr
    297  7be9		       4a		      lsr
    298  7bea		       4a		      lsr
    299  7beb		       a8		      tay
    300  7bec				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7bec		       60		      rts
    302  7bed
    303  7bed
    304  7bed				   .instrument
    305  7bed							; --- Melodic instrument ---
    306  7bed							; Compute index into ADSR indexes and master Ctrl tables
    307  7bed		       20 e6 fb 	      jsr	tt_CalcInsIndex
    308  7bf0							; Set AUDC with master value for this instrument, while we are at it
    309  7bf0		       b9 95 fc 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7bf3		       95 55		      sta	AUDC0,x
    311  7bf5							; advance ADSR counter and compare to end of Sustain
    312  7bf5		       b5 d4		      lda	tt_envelope_index_c0,x
    313  7bf7		       d9 a4 fc 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7bfa		       d0 03		      bne	.noEndOfSustain
    315  7bfc							; End of sustain: Go back to start of sustain
    316  7bfc		       b9 9f fc 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7bff				   .noEndOfSustain
    318  7bff		       a8		      tay
    319  7c00							; Set volume from envelope
    320  7c00		       b9 aa fc 	      lda	tt_InsFreqVolTable,y
    321  7c03		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7c05		       c8		      iny		; advance index otherwise
    323  7c06				   .endOfEnvelope
    324  7c06		       94 d4		      sty	tt_envelope_index_c0,x
    325  7c08		       95 59		      sta	AUDV0,x
    326  7c0a							; Now adjust frequency with ADSR value from envelope
    327  7c0a		       4a		      lsr
    328  7c0b		       4a		      lsr
    329  7c0c		       4a		      lsr
    330  7c0d		       4a		      lsr
    331  7c0e		       18		      clc
    332  7c0f		       75 d6		      adc	tt_cur_ins_c0,x
    333  7c11		       38		      sec
    334  7c12		       e9 08		      sbc	#8
    335  7c14		       95 57		      sta	AUDF0,x
    336  7c16
    337  7c16				   .afterAudioUpdate
    338  7c16							; loop over channels
    339  7c16		       ca		      dex
    340  7c17		       10 97		      bpl	.updateLoop
    341  7c19
 Music player size:  $dd
    342  7c19					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
    990  7c19
    991  7c19		       20 0b fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
    992  7c1c
    993  7c1c							;---------------------------------------------------------------------------
    994  7c1c							; START OF DISPLAY
    995  7c1c
    996  7c1c		       a9 09		      lda	#BANK_SCORING	; 2
    997  7c1e		       85 3e		      sta	SET_BANK_RAM	; 3
    998  7c20		       20 d9 f1 	      jsr	DrawDigits	; 6 = 11
    999  7c23
   1000  7c23
   1001  7c23							;---------------------------------------------------------------------------
   1002  7c23							; A 42-cycle timing window in the screen draw code.  Perform any general
   1003  7c23							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1004  7c23							; TJ: Well, not exactly 42 cycles, but it works! :)
   1005  7c23							;	 @09
   1006  7c23							;sta COLUBK		      ; 3     value comes from subroutine
   1007  7c23							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1008  7c23
   1009  7c23							;		  inc Throttle		      ; 5     speed limiter
      0  7c23					      SLEEP	5	;	 TODO: optimize for space
      1  7c23				   .CYCLES    SET	5
      2  7c23
      3  7c23				  -	      IF	.CYCLES < 2
      4  7c23				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c23				  -	      ERR
      6  7c23					      ENDIF
      7  7c23
      8  7c23					      IF	.CYCLES & 1
      9  7c23					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c23		       04 00		      nop	0
     11  7c25				  -	      ELSE
     12  7c25				  -	      bit	VSYNC
     13  7c25					      ENDIF
     14  7c25				   .CYCLES    SET	.CYCLES - 3
     15  7c25					      ENDIF
     16  7c25
     17  7c25					      REPEAT	.CYCLES / 2
     18  7c25		       ea		      nop
     19  7c26					      REPEND
   1011  7c26
   1012  7c26		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1013  7c28		       ca		      dex		; 2	 = $6f, stars effect!
   1014  7c29		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1015  7c2b
   1016  7c2b		       85 44		      sta	NUSIZ0	; 3
   1017  7c2d		       84 65		      sty	VDELP0	; 3	 y = 0!
   1018  7c2f
   1019  7c2f		       c8		      iny		; 2	 this relies on Y == 0 before...
   1020  7c30		       c4 c7		      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1021  7c32		       69 02		      adc	#2	; 2
   1022  7c34		       85 5d		      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1023  7c36
   1024  7c36		       a5 a4		      lda	ManLastDirection	; 3
   1025  7c38		       85 4b		      sta	REFP0	; 3
   1026  7c3a
   1027  7c3a		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1028  7c3c		       85 3e		      sta	SET_BANK_RAM	; 3
   1029  7c3e		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1030  7c41							;	 @66
   1031  7c41		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1032  7c43		       85 3f		      sta	SET_BANK	; 3
   1033  7c45		       20 2f f5 	      jsr	PostScreenCleanup	; 6+x
   1034  7c48
   1035  7c48		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1036  7c4a		       85 3f		      sta	SET_BANK	; 3
   1037  7c4c		       20 92 f2 	      jsr	SelfModDrawPlayers	; 6+x
   1038  7c4f
   1039  7c4f		       20 0b fa 	      jsr	StealCharDraw
   1040  7c52
   1041  7c52		       ad 84 02    OverscanBD lda	INTIM	;4
   1042  7c55		       d0 fb		      bne	OverscanBD	;2/3
   1043  7c57		       4c 25 fb 	      jmp	NewFrameStart
   1044  7c5a				   VBlankTime
   1045  7c5a		       32 32		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1046  7c5c		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1047  7c5e
   1048  7c5e							;---------------------------------------------------------------------------
   1049  7c5e
      0  7c5e					      DEFINE_SUBROUTINE	nextLevelMan
      1  7c5e		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7c5e					      SUBROUTINE
      3  7c5e				   nextLevelMan
   1051  7c5e
   1052  7c5e		       a9 14		      lda	#20
   1053  7c60		       85 a8		      sta	DelayEndOfLevel
   1054  7c62		       a9 14		      lda	#20
   1055  7c64		       85 c6		      sta	ColourTimer
   1056  7c66
   1057  7c66
   1058  7c66		       a9 00		      lda	#0
   1059  7c68		       85 aa		      sta	circle_d
   1060  7c6a		       85 ab		      sta	circle_d+1
   1061  7c6c
   1062  7c6c				  -	      if	0
   1063  7c6c				  -
   1064  7c6c				  -			; Fire up a circle-drawing special-effect object...
   1065  7c6c				  -
   1066  7c6c				  -
   1067  7c6c				  -	      lda	#TYPE_CIRCLE
   1068  7c6c				  -	      sta	POS_Type
   1069  7c6c				  -	      jsr	InsertObjectStack
   1070  7c6c				  -
   1071  7c6c					      endif
   1072  7c6c
   1073  7c6c
   1074  7c6c				  -	      if	0
   1075  7c6c				  -	      lda	#$08
   1076  7c6c				  -	      sta	color
   1077  7c6c				  -	      lda	#$04
   1078  7c6c				  -	      sta	color+1
   1079  7c6c				  -	      lda	#$0A
   1080  7c6c				  -	      sta	color+2
   1081  7c6c					      endif
   1082  7c6c		       e6 9f		      inc	ManMode
   1083  7c6e		       60		      rts
   1084  7c6f
      0  7c6f					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7c6f		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7c6f					      SUBROUTINE
      3  7c6f				   nextLevelMan2
   1086  7c6f
   1087  7c6f				  -	      if	0
   1088  7c6f				  -	      ldy	#SCREEN_LINES-1
   1089  7c6f				  -CopyScreenBank2 ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1090  7c6f				  -	      sty	RAM_Bank
   1091  7c6f				  -	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1092  7c6f				  -	      dey
   1093  7c6f				  -	      bpl	CopyScreenBank2
   1094  7c6f				  -
   1095  7c6f				  -	      ldx	#2
   1096  7c6f				  -fade       lda	color,x
   1097  7c6f				  -	      and	#$F
   1098  7c6f				  -	      bne	nz
   1099  7c6f				  -	      lda	#1
   1100  7c6f				  -	      sta	color,x
   1101  7c6f				  -nz	      dec	color,x
   1102  7c6f				  -zalready   dex
   1103  7c6f				  -	      bpl	fade
   1104  7c6f					      endif
   1105  7c6f
   1106  7c6f							;dec DelayEndOfLevel
   1107  7c6f							;beq goNL3
   1108  7c6f
   1109  7c6f		       e6 ab		      inc	circle_d+1
   1110  7c71		       a5 ab		      lda	circle_d+1
   1111  7c73		       c9 14		      cmp	#20
   1112  7c75		       b0 01		      bcs	goNL3
   1113  7c77
   1114  7c77
   1115  7c77		       60		      rts
   1116  7c78
   1117  7c78				   goNL3
   1118  7c78		       e6 9f		      inc	ManMode
   1119  7c7a
      0  7c7a					      DEFINE_SUBROUTINE	switchLevels
      1  7c7a		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7c7a					      SUBROUTINE
      3  7c7a				   switchLevels
   1121  7c7a
   1122  7c7a							;lda #BANK_NextLevelX
   1123  7c7a							;sta SET_BANK
   1124  7c7a							;jmp NextLevelX
   1125  7c7a
   1126  7c7a							; Now do the actual switching
   1127  7c7a
   1128  7c7a		       a5 ca		      lda	NextLevelTrigger
   1129  7c7c		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1130  7c7e		       85 ca		      sta	NextLevelTrigger
   1131  7c80
   1132  7c80							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1133  7c80							; then increment the level number. This is completely circular, so we eventually wrap
   1134  7c80							; the level back to 0 and start afresh.
   1135  7c80
   1136  7c80		       e6 b4		      inc	levelX
   1137  7c82		       a5 b4		      lda	levelX
   1138  7c84		       c9 86		      cmp	#NUMBEROFLEVELS
   1139  7c86		       90 02		      bcc	.level_ok
   1140  7c88		       a9 00		      lda	#0
   1141  7c8a		       85 b4	   .level_ok  sta	levelX
   1142  7c8c		       60		      rts
   1143  7c8d
   1144  7c8d							;---------------------------------------------------------------------------
   1145  7c8d
   1146  7c8d
      0  7c8d					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7c8d		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7c8d					      SUBROUTINE
      3  7c8d				   CopyROM2RAM_F000
   1148  7c8d
   1149  7c8d		       a9 0b		      lda	#BANK_CopyROMShadowToRAM
   1150  7c8f		       85 3f		      sta	SET_BANK
   1151  7c91		       85 c4		      sta	ROM_Bank
   1152  7c93		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1153  7c96
   1154  7c96
   1155  7c96							;---------------------------------------------------------------------------
   1156  7c96
   1157  7c96							;---------------------------------------------------------------------------
   1158  7c96
   1159  7c96							;include "circle.asm"
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 4
      0  7c96					      include	"sound/intro1_trackdata.asm"
      1  7c96							; TIATracker music player
      2  7c96							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7c96							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7c96							; Email: andre.wichmann@gmx.de
      5  7c96							;
      6  7c96							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7c96							; you may not use this file except in compliance with the License.
      8  7c96							; You may obtain a copy of the License at
      9  7c96							;
     10  7c96							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7c96							;
     12  7c96							; Unless required by applicable law or agreed to in writing, software
     13  7c96							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7c96							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7c96							; See the License for the specific language governing permissions and
     16  7c96							; limitations under the License.
     17  7c96
     18  7c96							; Song author: 
     19  7c96							; Song name: 
     20  7c96
     21  7c96							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7c96
     23  7c96							; =====================================================================
     24  7c96							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7c96							; data.
     26  7c96							; =====================================================================
     27  7c96				   tt_TrackDataStart
     28  7c96
     29  7c96							; =====================================================================
     30  7c96							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7c96							; the index values into these tables for the current instruments played
     32  7c96							; in channel 0 and 1.
     33  7c96							; 
     34  7c96							; Each instrument is defined by:
     35  7c96							; - tt_InsCtrlTable: the AUDC value
     36  7c96							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7c96							;	 defined in tt_InsFreqVolTable
     38  7c96							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7c96							;	 of the envelope
     40  7c96							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7c96							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7c96							;	 the envelope
     43  7c96							; =====================================================================
     44  7c96
     45  7c96							; Instrument master CTRL values
     46  7c96				   tt_InsCtrlTable
     47  7c96		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7c9b
     49  7c9b
     50  7c9b							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7c9b				   tt_InsADIndexes
     52  7c9b		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7ca0
     54  7ca0
     55  7ca0							; Instrument Sustain start indexes into ADSR tables
     56  7ca0				   tt_InsSustainIndexes
     57  7ca0		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7ca5
     59  7ca5
     60  7ca5							; Instrument Release start indexes into ADSR tables
     61  7ca5							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7ca5							; real index, add 1.
     63  7ca5				   tt_InsReleaseIndexes
     64  7ca5		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7caa
     66  7caa
     67  7caa							; AUDVx and AUDFx ADSR envelope values.
     68  7caa							; Each byte encodes the frequency and volume:
     69  7caa							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7caa							;	 8 means no change. Bit 7 is the sign bit.
     71  7caa							; - Bits 3..0: Volume
     72  7caa							; Between sustain and release is one byte that is not used and
     73  7caa							; can be any value.
     74  7caa							; The end of the release phase is encoded by a 0.
     75  7caa				   tt_InsFreqVolTable
     76  7caa							; 0: Pizzicato bassb
     77  7caa		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7cb2		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7cb8							; 1+2: Square2
     80  7cb8		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7cc0		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7cc8							; 3+4: Square
     83  7cc8		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7cd0		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7cd8		       00		      dc.b	$00
     86  7cd9
     87  7cd9
     88  7cd9
     89  7cd9							; =====================================================================
     90  7cd9							; Percussion instrument definitions (up to 15)
     91  7cd9							;
     92  7cd9							; Each percussion instrument is defined by:
     93  7cd9							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7cd9							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7cd9							; - tt_PercFreqTable: The AUDF frequency value
     96  7cd9							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7cd9							; =====================================================================
     98  7cd9
     99  7cd9							; Indexes into percussion definitions signifying the first frame for
    100  7cd9							; each percussion in tt_PercFreqTable.
    101  7cd9							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7cd9							; real index, subtract 1.
    103  7cd9				   tt_PercIndexes
    104  7cd9		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7cdc
    106  7cdc
    107  7cdc							; The AUDF frequency values for the percussion instruments.
    108  7cdc							; If the second to last value is negative (>=128), it means it's an
    109  7cdc							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7cdc							; immediately and starts it in the sustain phase next frame. (Needs
    111  7cdc							; TT_USE_OVERLAY)
    112  7cdc				   tt_PercFreqTable
    113  7cdc							; 0: Kick
    114  7cdc		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7ce4		       00		      dc.b	$00
    116  7ce5							; 1: HH
    117  7ce5		       80 00		      dc.b	$80, $00
    118  7ce7							; 2: Snare
    119  7ce7		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7cef		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7cf2
    122  7cf2
    123  7cf2							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7cf2							; - Bits 7..4: AUDC value
    125  7cf2							; - Bits 3..0: AUDV value
    126  7cf2							; 0 means end of percussion data.
    127  7cf2				   tt_PercCtrlVolTable
    128  7cf2							; 0: Kick
    129  7cf2		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7cfa		       00		      dc.b	$00
    131  7cfb							; 1: HH
    132  7cfb		       87 00		      dc.b	$87, $00
    133  7cfd							; 2: Snare
    134  7cfd		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7d05		       87 86 00 	      dc.b	$87, $86, $00
    136  7d08
    137  7d08
    138  7d08
    139  7d08							; =====================================================================
    140  7d08							; Track definition
    141  7d08							; The track is defined by:
    142  7d08							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7d08							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7d08							;	 as index values
    145  7d08							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7d08							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7d08							;	 for all channels and sub-tracks. The variables
    148  7d08							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7d08							;	 each channel.
    150  7d08							;
    151  7d08							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7d08							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7d08							; to play are specified.
    154  7d08							; =====================================================================
    155  7d08
    156  7d08							; ---------------------------------------------------------------------
    157  7d08							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7d08							; hold the index values into these tables for the current pattern
    159  7d08							; played in channel 0 and 1.
    160  7d08							;
    161  7d08							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7d08							; A note can be either:
    163  7d08							; - Pause: Put melodic instrument into release. Must only follow a
    164  7d08							;	 melodic instrument.
    165  7d08							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7d08							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7d08							;	 by -7..+7 and keep playing it
    168  7d08							; - Play new note with melodic instrument
    169  7d08							; - Play new note with percussion instrument
    170  7d08							; - End of pattern
    171  7d08							;
    172  7d08							; A note is defined by:
    173  7d08							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7d08							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7d08							;	 defined as:
    176  7d08							;	 - 0: End of pattern
    177  7d08							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7d08							;	 - 8: Hold
    179  7d08							;	 - 16: Pause
    180  7d08							;	 - [17..31]: Play percussion instrument 1..15
    181  7d08							;
    182  7d08							; The tracker must ensure that a pause only follows a melodic
    183  7d08							; instrument or a hold/slide.
    184  7d08							; ---------------------------------------------------------------------
    185  7d08		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7d08		       00 08	   TT_INS_HOLD =	8
    187  7d08		       00 10	   TT_INS_PAUSE =	16
    188  7d08		       00 11	   TT_FIRST_PERC =	17
    189  7d08
    190  7d08							; Intro left
    191  7d08				   tt_pattern0
    192  7d08		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7d10		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7d18		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7d20		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7d28		       00		      dc.b	$00
    197  7d29
    198  7d29							; Intro2 L
    199  7d29				   tt_pattern1
    200  7d29		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7d31		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7d39		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7d41		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7d49		       00		      dc.b	$00
    205  7d4a
    206  7d4a							; Intro2-fill L
    207  7d4a				   tt_pattern2
    208  7d4a		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7d52		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7d5a		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7d62		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7d6a		       00		      dc.b	$00
    213  7d6b
    214  7d6b							; Intro right
    215  7d6b				   tt_pattern3
    216  7d6b		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7d73		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7d7b		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7d83		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7d8b		       00		      dc.b	$00
    221  7d8c
    222  7d8c							; Intro2 R
    223  7d8c				   tt_pattern4
    224  7d8c		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7d94		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7d9c		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7da4		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7dac		       00		      dc.b	$00
    229  7dad
    230  7dad
    231  7dad
    232  7dad
    233  7dad							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7dad							; Each byte encodes the speed of one pattern in the order
    235  7dad							; of the tt_PatternPtr tables below.
    236  7dad							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7dad							; the even speed and the high nibble the odd speed.
    238  7dad				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7dad				  -tt_PatternSpeeds
    240  7dad				  -%%PATTERNSPEEDS%%
    241  7dad					      ENDIF
    242  7dad
    243  7dad
    244  7dad							; ---------------------------------------------------------------------
    245  7dad							; Pattern pointers look-up table.
    246  7dad							; ---------------------------------------------------------------------
    247  7dad				   tt_PatternPtrLo
    248  7dad		       08 29 4a 6b	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7db1		       8c		      dc.b	<tt_pattern4
    250  7db2				   tt_PatternPtrHi
    251  7db2		       fd fd fd fd	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7db6		       fd		      dc.b	>tt_pattern4
    253  7db7
    254  7db7
    255  7db7							; ---------------------------------------------------------------------
    256  7db7							; Pattern sequence table. Each byte is an index into the
    257  7db7							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7db7							; definitions can be found. When a pattern has been played completely,
    259  7db7							; the next byte from this table is used to get the address of the next
    260  7db7							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7db7							; into this table for channels 0 and 1.
    262  7db7							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7db7							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7db7							; ---------------------------------------------------------------------
    265  7db7				   tt_SequenceTable
    266  7db7							; ---------- Channel 0 ----------
    267  7db7		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7dbc
    269  7dbc
    270  7dbc							; ---------- Channel 1 ----------
    271  7dbc		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7dc1
    273  7dc1
 Track size:  $12b
    274  7dc1					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1161  7dc1
 FREE BYTES IN FIXED BANK =  $23a
   1162  7dc1					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1163  7dc1
   1164  7dc1							;---------------------------------------------------------------------------
   1165  7dc1							; The reset vectors
   1166  7dc1							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1167  7dc1
   1168  8000 ????				      SEG	InterruptVectors
   1169  7ffc					      ORG	FIXED_BANK + $7FC
   1170  7ffc					      RORG	$7ffC
   1171  7ffc
   1172  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1173  7ffc		       94 fa		      .word.w	Reset	; RESET
   1174  7ffe		       94 fa		      .word.w	Reset	; IRQ	      (not used)
   1175  8000
   1176  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    856  8000
    857  8000					      END
