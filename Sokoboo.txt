------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	xsegtime
     89  0000 ????			   {1}	      SET	{2}-1
     90  0000 ????			   TEST_{1}   =	1
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     94  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
     95  0000 ????						; No other action required.  All code enables/disables automatically.
     96  0000 ????
     97  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
     98  0000 ????						; due to separation of timeslice overhead to separate check
     99  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_DIRECT,8	; TODO: 392@12/2/2012
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_QUICK,9	; TODO: 414@12/2/2012
      1  0000 ????			   SEGTIME_SCD_QUICK SET	9
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_SLOW,12	; TODO: cycles: ~635 @12/2/2012.
      1  0000 ????			   SEGTIME_SCD_SLOW SET	12
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_PF0,5	; TODO: cycle counted ~126 @12/2/2012
      1  0000 ????			   SEGTIME_SCD_PF0 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
    105  0000 ????
    106  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    107  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
    108  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,41	; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	41
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
    110  0000 ????				      ENDIF
    111  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,5	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,5	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
    114  0000 ????
    115  0000 ????
    116  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SORT_TIME,3	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	3
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
    118  0000 ????
    119  0000 ????
    120  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,4	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	4
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
    122  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIMEBLANK,16	;17		 ; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	16
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
    124  0000 ????
    125  0000 ????						; MINIMUM_SEGTIME
    126  0000 ????						; MINIMUM_SEGTIMEBLANK
    127  0000 ????						; SEGTIME_BDF
    128  0000 ????						; SEGTIME_BDS
    129  0000 ????						; SEGTIME_DSL
    130  0000 ????						; SEGTIME_SWITCHOBJECTS
    131  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    133  0000 ????
    134  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    135  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    136  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    137  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    138  0000 ????						; uses ...
    139  0000 ????
    140  0000 ????
    141  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    142  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    143  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    144  0000 ????
    145  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    146  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    147  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    151  0000 ????
    152  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get TARGET)
    153  0000 ????
    154  0000 ????						; push BOX is slowest (besides get TARGET which has an extra timer check)
    155  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    156  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_GET_TARGET,17	; * 14/8/11, required if UpdateScore loops (e.g. 9990->10000)
      1  0000 ????			   SEGTIME_GET_TARGET SET	17
      2  0000 ????	       00 00	   TEST_SEGTIME_GET_TARGET =	0
      0  0000 ????				      SEGTIME	SEGTIME_SWITCHOBJECTS,3	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????	       00 00	   DEBUG      =	NO
     55  0000 ????
     56  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     57  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     58  0000 ????
     59  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     60  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     61  0000 ????			  -	      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????
     65  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     66  0000 ????
     67  0000 ????			   NTSC_MODE  SET	NO
     68  0000 ????
     69  0000 ????			  -	      IF	TJ_MODE
     70  0000 ????			  -NTSC_MODE  SET	NO	; force NTSC or PAL for difficulty switch
     71  0000 ????				      ENDIF
     72  0000 ????				      IF	AD_MODE
     73  0000 ????			   NTSC_MODE  SET	NO
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????						;===================================
     79  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     80  0000 ????						;===================================
     81  0000 ????
     82  0000 ????						;-------------------------------------------------------------------------------
     83  0000 ????						; The following should be YES for the final or DEMO version
     84  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     85  0000 ????
     86  0000 ????						;-------------------------------------------------------------------------------
     87  0000 ????						; The following are optional YES/NO depending on phase of the moon
     88  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     89  0000 ????						;-------------------------------------------------------------------------------
     90  0000 ????
     91  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     92  0000 ????	       00 05	   NUM_LEVELS =	5
     93  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     94  0000 ????
     95  0000 ????			   DEMO_DELAY SET	1	; number of music loops without joystick input before demo kicks in
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     99  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
    100  0000 ????			  -	      IF	FINAL_VERSION = YES
    101  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    102  0000 ????			  -SHOWTARGETP SET	NO	; debug show TARGET on P
    103  0000 ????			  -
    104  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    105  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    106  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    107  0000 ????				      ENDIF
    108  0000 ????
    109  0000 ????						;-------------------------------------------------------------------------------
    110  0000 ????
    111  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    112  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
    113  0000 ????
    114  0000 ????
    115  0000 ????	       00 01	   PUSH_LIMIT =	1	; slowdown when pushing on a BOX
    116  0000 ????
    117  0000 ????						; time bonus countdown constants:
    118  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    119  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    120  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    121  0000 ????
    122  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    123  0000 ????
    124  0000 ????	       00 03	   FACE_LEFT  =	3
    125  0000 ????
    126  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    127  0000 ????
    128  0000 ????						;scoring flags contants:
    129  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    130  0000 ????	       00 00	   DISPLAY_TIME =	%00
    131  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    132  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    133  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    134  0000 ????
    135  0000 ????						;------------------------------------------------------------------------------
    136  0000 ????
    137  0000 ????	       00 01	   MIRRORED_BOX =	YES
    138  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    139  0000 ????	       00 01	   MIRRORED_WALL =	YES
    140  0000 ????
    141  0000 ????						;------------------------------------------------------------------------------
    142  0000 ????
    143  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    144  0000 ????
    145  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    146  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    147  0000 ????
    148  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    149  0000 ????
    150  0000 ????
    151  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    152  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    153  0000 ????
    154  0000 ????
    155  0000 ????						; color constants:
    156  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    157  0000 ????
    158  0000 ????	       00 10	   YELLOW_NTSC =	$10
    159  0000 ????	       00 20	   YELLOW_PAL =	$20
    160  0000 ????
    161  0000 ????
    162  0000 ????	       10 00	   RAM_3E     =	$1000
    163  0000 ????	       04 00	   RAM_SIZE   =	$400
    164  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    165  0000 ????
    166  0000 ????
    167  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    168  0000 ????
    169  0000 ????
    170  0000 ????						; Platform constants:
    171  0000 ????	       00 02	   PAL	      =	%10
    172  0000 ????	       00 02	   PAL_50     =	PAL|0
    173  0000 ????	       00 03	   PAL_60     =	PAL|1
    174  0000 ????
    175  0000 ????
    176  0000 ????				      IF	L276
    177  0000 ????	       00 3e	   VBLANK_TIM_NTSC =	62	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    178  0000 ????			  -	      ELSE
    179  0000 ????			  -VBLANK_TIM_NTSC =	45	; NTSC 262
    180  0000 ????				      ENDIF
    181  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    182  0000 ????
    183  0000 ????				      IF	L276
    184  0000 ????	       00 33	   OVERSCAN_TIM_NTSC =	51	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    185  0000 ????			  -	      ELSE
    186  0000 ????			  -OVERSCAN_TIM_NTSC =	51	; NTSC 262
    187  0000 ????				      ENDIF
    188  0000 ????	       00 46	   OVERSCAN_TIM_PAL =	70	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    189  0000 ????
    190  0000 ????				      IF	L276
    191  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    192  0000 ????			  -	      ELSE
    193  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    194  0000 ????				      ENDIF
    195  0000 ????	       01 38	   SCANLINES_PAL =	312
    196  0000 ????
    197  0000 ????
    198  0000 ????						;------------------------------------------------------------------------------
    199  0000 ????						; MACRO definitions
    200  0000 ????
    201  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    202  0000 ????
    203  0000 ????				      MAC	newbank
    204  0000 ????				      SEG	{1}
    205  0000 ????				      ORG	ORIGIN
    206  0000 ????				      RORG	$F000
    207  0000 ????			   BANK_START SET	*
    208  0000 ????			   {1}	      SET	ORIGIN / 2048
    209  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    210  0000 ????			   _CURRENT_BANK SET	{1}
    211  0000 ????				      ENDM		; bank name
    212  0000 ????
    213  0000 ????				      MAC	define_1k_segment
    214  0000 ????				      ALIGN	$400
    215  0000 ????			   SEGMENT_{1} SET	*
    216  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    217  0000 ????				      ENDM		; {seg name}
    218  0000 ????
    219  0000 ????				      MAC	check_bank_size
    220  0000 ????			   .TEMP      =	* - BANK_START
    221  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    222  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    223  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    224  0000 ????				      ERR
    225  0000 ????				      endif
    226  0000 ????				      ENDM		; name
    227  0000 ????
    228  0000 ????
    229  0000 ????				      MAC	check_half_bank_size
    230  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    231  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    232  0000 ????			   .TEMP      =	* - BANK_START
    233  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    234  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    235  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    236  0000 ????				      ERR
    237  0000 ????				      endif
    238  0000 ????				      ENDM		; name
    239  0000 ????
    240  0000 ????
    241  0000 ????				      MAC	overlay
    242  0000 ????				      SEG.U	OVERLAY_{1}
    243  0000 ????				      org	Overlay
    244  0000 ????				      ENDM		; {name}
    245  0000 ????
    246  0000 ????						;--------------------------------------------------------------------------
    247  0000 ????
    248  0000 ????				      MAC	validate_overlay
    249  0000 ????				      LIST	OFF
    250  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    251  0000 ????				      ERR
    252  0000 ????				      endif
    253  0000 ????				      LIST	ON
    254  0000 ????				      ENDM
    255  0000 ????
    256  0000 ????						;--------------------------------------------------------------------------
    257  0000 ????						; Macro inserts a page break if the object would overlap a page
    258  0000 ????
    259  0000 ????				      MAC	optional_pagebreak
    260  0000 ????				      LIST	OFF
    261  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    262  0000 ????			   EARLY_LOCATION SET	*
    263  0000 ????				      ALIGN	256
    264  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    265  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    266  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    267  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    268  0000 ????				      ENDIF
    269  0000 ????				      LIST	ON
    270  0000 ????				      ENDM		; { string, size }
    271  0000 ????
    272  0000 ????
    273  0000 ????				      MAC	check_page_crossing
    274  0000 ????				      LIST	OFF
    275  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    276  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    277  0000 ????				      endif
    278  0000 ????				      LIST	ON
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????				      MAC	checkpage
    282  0000 ????				      LIST	OFF
    283  0000 ????				      IF	>. != >{1}
    284  0000 ????				      ECHO	""
    285  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    286  0000 ????				      ECHO	""
    287  0000 ????				      ERR
    288  0000 ????				      ENDIF
    289  0000 ????				      LIST	ON
    290  0000 ????				      ENDM
    291  0000 ????
    292  0000 ????				      MAC	checkpagex
    293  0000 ????				      LIST	OFF
    294  0000 ????				      IF	>. != >{1}
    295  0000 ????				      ECHO	""
    296  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    297  0000 ????				      ECHO	{2}
    298  0000 ????				      ECHO	""
    299  0000 ????				      ERR
    300  0000 ????				      ENDIF
    301  0000 ????				      LIST	ON
    302  0000 ????				      ENDM
    303  0000 ????
    304  0000 ????
    305  0000 ????				      MAC	checkpage_bne
    306  0000 ????				      LIST	OFF
    307  0000 ????				      IF	0	;>(. + 2) != >{1}
    308  0000 ????				      ECHO	""
    309  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    310  0000 ????				      ECHO	""
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????				      LIST	ON
    314  0000 ????				      bne	{1}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	checkpage_bpl
    318  0000 ????				      LIST	OFF
    319  0000 ????				      IF	(>(.+2 )) != >{1}
    320  0000 ????				      ECHO	""
    321  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    322  0000 ????				      ECHO	""
    323  0000 ????				      ERR
    324  0000 ????				      ENDIF
    325  0000 ????				      LIST	ON
    326  0000 ????				      bpl	{1}
    327  0000 ????				      ENDM
    328  0000 ????
    329  0000 ????				      MAC	align_free
    330  0000 ????			   FREE       SET	FREE - .
    331  0000 ????				      align	{1}
    332  0000 ????			   FREE       SET	FREE + .
    333  0000 ????				      echo	"@", ., ":", FREE
    334  0000 ????				      ENDM
    335  0000 ????
    336  0000 ????				      MAC	stress_time
    337  0000 ????				      IF	TEST_{1} = 1
    338  0000 ????
    339  0000 ????
    340  0000 ????						;LIST OFF
    341  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    342  0000 ????						;LIST ON
    343  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    344  0000 ????				      bne	. - 7	; branches to lda INTIM
    345  0000 ????				      ENDIF
    346  0000 ????				      ENDM
    347  0000 ????
    348  0000 ????			   IDENTITY   SET	0
    349  0000 ????				      MAC	ident
    350  0000 ????				      if	DEBUG=YES
    351  0000 ????				      lda	#IDENTITY
    352  0000 ????				      sta	debug_ident
    353  0000 ????				      lda	{1}
    354  0000 ????				      sta	debug_object
    355  0000 ????				      endif
    356  0000 ????			   IDENTITY   SET	IDENTITY + 1
    357  0000 ????				      ENDM		; {object}
    358  0000 ????
    359  0000 ????						;--------------------------------------------------------------------------
    360  0000 ????
    361  0000 ????				      MAC	vector
    362  0000 ????				      .word	{1}
    363  0000 ????				      ENDM		; just a word pointer to code
    364  0000 ????
    365  0000 ????
    366  0000 ????				      MAC	define_subroutine
    367  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    368  0000 ????				      SUBROUTINE		; keep everything local
    369  0000 ????			   {1}			; entry point
    370  0000 ????				      ENDM		; name of subroutine
    371  0000 ????
    372  0000 ????
    373  0000 ????
    374  0000 ????						;--------------------------------------------------------------------------
    375  0000 ????
    376  0000 ????				      MAC	newrambank
    377  0000 ????				      SEG.U	{1}
    378  0000 ????				      ORG	ORIGIN
    379  0000 ????				      RORG	RAM_3E
    380  0000 ????			   BANK_START SET	*
    381  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    382  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    383  0000 ????				      ENDM		; bank name
    384  0000 ????
    385  0000 ????				      MAC	validate_ram_size
    386  0000 ????				      if	* - RAM_3E > RAM_SIZE
    387  0000 ????				      ERR
    388  0000 ????				      endif
    389  0000 ????				      ENDM
    390  0000 ????
    391  0000 ????				      MAC	next_random
    392  0000 ????						; update random value:
    393  0000 ????				      lda	rnd	; 3
    394  0000 ????				      lsr		; 2
    395  0000 ????				      IFCONST	rndHi
    396  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    397  0000 ????				      ENDIF
    398  0000 ????				      bcc	.skipEOR	; 2/3
    399  0000 ????				      eor	#RND_EOR_VAL	; 2
    400  0000 ????			   .skipEOR
    401  0000 ????				      sta	rnd	; 3 = 14/19
    402  0000 ????				      ENDM
    403  0000 ????
    404  0000 ????				      MAC	resync
    405  0000 ????						; resync screen, X and Y == 0 afterwards
    406  0000 ????				      lda	#%10	; make sure VBLANK is ON
    407  0000 ????				      sta	VBLANK
    408  0000 ????
    409  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    410  0000 ????			   .loopResync
    411  0000 ????				      VERTICAL_SYNC
    412  0000 ????
    413  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    414  0000 ????				      lda	Platform
    415  0000 ????				      eor	#PAL_50	; PAL-50?
    416  0000 ????				      bne	.ntsc
    417  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    418  0000 ????			   .ntsc
    419  0000 ????			   .loopWait
    420  0000 ????				      sta	WSYNC
    421  0000 ????				      sta	WSYNC
    422  0000 ????				      dey
    423  0000 ????				      bne	.loopWait
    424  0000 ????				      dex
    425  0000 ????				      bne	.loopResync
    426  0000 ????				      ENDM
    427  0000 ????
    428  0000 ????				      MAC	set_platform
    429  0000 ????						; 00 = NTSC
    430  0000 ????						; 01 = NTSC
    431  0000 ????						; 10 = PAL-50
    432  0000 ????						; 11 = PAL-60
    433  0000 ????				      lda	SWCHB
    434  0000 ????				      rol
    435  0000 ????				      rol
    436  0000 ????				      rol
    437  0000 ????				      and	#%11
    438  0000 ????				      if	NTSC_MODE = NO
    439  0000 ????				      eor	#PAL
    440  0000 ????				      endif
    441  0000 ????				      lda	#0	;tmp
    442  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    443  0000 ????				      ENDM
    444  0000 ????
    445  0000 ????						;  IF TJ_MODE
    446  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    447  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    448  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    449  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    450  0000 ????						;    ENDM
    451  0000 ????						;
    452  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    453  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    454  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    455  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    456  0000 ????						;    ENDM
    457  0000 ????						;
    458  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    459  0000 ????						;	  ldx #<{1}			  ; 2
    460  0000 ????						;	  stx addressR			  ; 3
    461  0000 ????						;	  ldx #>{1}			  ; 2
    462  0000 ????						;	  stx addressR+1		  ; 3
    463  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    464  0000 ????						;    ENDM
    465  0000 ????						;
    466  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    467  0000 ????						;	  ldx #<{1}			  ; 2
    468  0000 ????						;	  stx addressW			  ; 3
    469  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    470  0000 ????						;	  stx addressW+1		  ; 3
    471  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    472  0000 ????						;    ENDM
    473  0000 ????						;  ENDIF
    474  0000 ????
    475  0000 ????				      MAC	nop_b
    476  0000 ????				      .byte	$82
    477  0000 ????				      ENDM		; unused
    478  0000 ????
    479  0000 ????				      MAC	nop_w
    480  0000 ????				      .byte	$0c
    481  0000 ????				      ENDM
    482  0000 ????
    483  0000 ????						;------------------------------------------------------------------------------
    484  0000 ????
    485  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00f4 ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00 40	   GAMEMODE_2600 =	64
     39 U0080		       00 80	   GAMEMODE_PAUSED =	128
     40 U0080
     41 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     42 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0082							; above variables are preserved ALL the time!
     44 U0082
     45 U0082		       00	   rnd	      ds	1
     46 U0083		       00	   rndHi      ds	1	; to get better random values
     47 U0084
     48 U0084		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     49 U0085		       00	   ObjStackNum ds	1	; which stack in use
     50 U0086		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     51 U0088		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     52 U0089		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     53 U008a
     54 U008a		       00	   POS_X      ds	1
     55 U008b		       00	   POS_Y      ds	1
     56 U008c		       00	   POS_X_NEW  ds	1
     57 U008d		       00	   POS_Y_NEW  ds	1
     58 U008e		       00	   POS_Type   ds	1
     59 U008f		       00	   POS_VAR    ds	1
     60 U0090
     61 U0090		       00 00	   BufferedJoystick ds	2	; player joystick input
     62 U0092		       00 00	   BufferedButton ds	2	; player button press
     63 U0094
     64 U0094							; Scrolling is limited to only show board within the following area...
     65 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     66 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     67 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     68 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     69 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     70 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     71 U0098		       00	   scrollBits ds	1
     72 U0099
     73 U0099		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     74 U009a		       00	   manAnimationIndex ds	1
     75 U009b		       00	   ManX       ds	1
     76 U009c		       00	   ManY       ds	1
     77 U009d		       00	   ManDrawX   ds	1
     78 U009e		       00	   ManDrawY   ds	1
     79 U009f		       00	   ManMode    ds	1
     80 U00a0		       00	   ManDelayCount ds	1
     81 U00a1		       00 00	   ManAnimation ds	2
     82 U00a3		       00	   ManAnimationFrameLO ds	1
     83 U00a4		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     84 U00a5		       00	   ManPushCounter ds	1
     85 U00a6		       00	   LookingAround ds	1
     86 U00a7		       00	   ManCount   ds	1	; player life counter
     87 U00a8		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     88 U00a9		       00 00	   circle_d   ds	2
     89 U00ab		       00	   circ_x     ds	1
     90 U00ac		       00	   circ_y     ds	1
     91 U00ad		       00	   circ_char  ds	1
     92 U00ae		       00	   circ_scratch ds	1
     93 U00af		       00	   LEVEL_bank ds	1
     94 U00b0							;---------------------------------------------------------------------------
     95 U00b0							; 2 (shared) demo mode variables:
     96 U00b0		       00 a8	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     97 U00b0		       00 a8	   moveLen    =	jtoggle	; bits 0..6
     98 U00b0		       00 99	   moveIdx    =	whichPlayer
     99 U00b0
    100 U00b0		       00	   LastSpriteY ds	1
    101 U00b1
    102 U00b1		       00	   timer      ds	1
    103 U00b2
    104 U00b2		       00	   BGColour   ds	1
    105 U00b3
    106 U00b3							; levelx and level have to be consecutive variables!
    107 U00b3		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    108 U00b4		       00	   level      ds	1	; current player's level (other in scoring bank)
    109 U00b5		       00	   levelDisplay ds	1	; what to display as the level ID
    110 U00b6		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    111 U00b7		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
    112 U00b8
    113 U00b8		       00	   targetsRequired ds	1	; number of un-targeted left to go
    114 U00b9		       00	   moveCounter ds	1	; BCD seconds for level
    115 U00ba		       00	   moveCounterHi ds	1
    116 U00bb		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
    117 U00be		       00 00	   Board_AddressR ds	2
    118 U00c0		       00 00	   Board_AddressW ds	2
    119 U00c2		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    120 U00c3		       00	   RAM_Bank   ds	1
    121 U00c4
    122 U00c4		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    123 U00c5		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    124 U00c6
    125 U00c6							; extraLifeTimer:
    126 U00c6							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    127 U00c6
    128 U00c6		       00	   scoringTimer ds	1	; times the various score displays
    129 U00c7		       00	   scoringFlags ds	1	; scoring flags are stored here
    130 U00c8
    131 U00c8							; scoringFlags:
    132 U00c8							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    133 U00c8							; D6		 unused
    134 U00c8							; D5		 unused
    135 U00c8							; D4		 unused
    136 U00c8							; D3		 unused
    137 U00c8							; D2		 unused
    138 U00c8							; D1	 D1-D0	 Which display kernel to use for scoring
    139 U00c8							; D0		 0 = 2x4     used for TARGETs/time
    140 U00c8							;		 1 = 1x6     used for score
    141 U00c8							;		 2 = 3x2     used for level/lives/player
    142 U00c8
    143 U00c8		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    144 U00c8		       00 80	   BIT_NEXTLEVEL =	128
    145 U00c8		       00 40	   BIT_NEXTLIFE =	64
    146 U00c9
    147 U00c9							;---------------------------------------------------------------------------
    148 U00c9
    149 U00c9		       00	   sortRequired ds	1
    150 U00ca		       00	   sortPtr    ds	1
    151 U00cb
    152 U00cb							;------------------------------------------------------------------------------
    153 U00cb
    154 U00cb		       00	   ObjIterator ds	1	; count UP iterator over objects
    155 U00cc		       00	   DSL	      ds	1	; stack line counter
    156 U00cd
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00cd					      include	"sound/intro1_variables.asm"
      1 U00cd							; TIATracker music player
      2 U00cd							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00cd							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00cd							; Email: andre.wichmann@gmx.de
      5 U00cd							;
      6 U00cd							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00cd							; you may not use this file except in compliance with the License.
      8 U00cd							; You may obtain a copy of the License at
      9 U00cd							;
     10 U00cd							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00cd							;
     12 U00cd							; Unless required by applicable law or agreed to in writing, software
     13 U00cd							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00cd							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00cd							; See the License for the specific language governing permissions and
     16 U00cd							; limitations under the License.
     17 U00cd
     18 U00cd							; Song author: 
     19 U00cd							; Song name: 
     20 U00cd
     21 U00cd							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00cd
     23 U00cd							; =====================================================================
     24 U00cd							; Flags
     25 U00cd							; =====================================================================
     26 U00cd
     27 U00cd							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00cd		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00cd							; duration (number of TV frames) of a note
     30 U00cd		       00 05	   TT_SPEED   =	5
     31 U00cd							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00cd		       00 04	   TT_ODD_SPEED =	4
     33 U00cd
     34 U00cd							; 1: Overlay percussion, +40 bytes
     35 U00cd		       00 01	   TT_USE_OVERLAY =	1
     36 U00cd							; 1: Melodic instrument slide, +9 bytes
     37 U00cd		       00 00	   TT_USE_SLIDE =	0
     38 U00cd							; 1: Goto pattern, +8 bytes
     39 U00cd		       00 01	   TT_USE_GOTO =	1
     40 U00cd							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00cd		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00cd							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00cd							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00cd							; this flag to 0 to save 2 bytes.
     45 U00cd							; 0: +2 bytes
     46 U00cd		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00cd
     48 U00cd
     49 U00cd							; =====================================================================
     50 U00cd							; Permanent variables. These are states needed by the player.
     51 U00cd							; =====================================================================
     52 U00cd		       00	   tt_timer   ds	1	; current music timer value
     53 U00ce		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00cf		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d0		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d1		       00	   tt_cur_note_index_c1 ds	1
     57 U00d2		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d3		       00	   tt_envelope_index_c1 ds	1
     59 U00d4		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d5		       00	   tt_cur_ins_c1 ds	1
     61 U00d6
     62 U00d6
     63 U00d6							; =====================================================================
     64 U00d6							; Temporary variables. These will be overwritten during a call to the
     65 U00d6							; player routine, but can be used between calls for other things.
     66 U00d6							; =====================================================================
     67 U00d6		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    158 U00d8
    159 U00d8
    160 U00d8
    161 U00d8				   OVERLAY_SIZE SET	16
    162 U00d8
    163 U00d8
    164 U00d8
    165 U00d8							; This overlay variable is used for the overlay variables.  That's OK.
    166 U00d8							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    167 U00d8							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    168 U00d8							; (especially the latter ones) are only used in rare occasions.
    169 U00d8
    170 U00d8							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    171 U00d8							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    172 U00d8
    173 U00d8		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00e8					      VALIDATE_OVERLAY
      5 U00e8					      LIST	ON
    175 U00e8
    176 U00e8
    177 U00e8		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    178 U00f4
 FREE BYTES IN ZERO PAGE =  $b
    179 U00f4					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    180 U00f4				  -	      IF	* > $FF
    181 U00f4				  -	      ERR
    182 U00f4					      ENDIF
------- FILE ./sokoboo.asm
    487 U00f4
    488 U00f4
    489 U00f4							;------------------------------------------------------------------------------
    490 U00f4							; OVERLAYS!
    491 U00f4							; These variables are overlays, and should be managed with care
    492 U00f4							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    493 U00f4
    494 U00f4							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    495 U00f4							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    496 U00f4
    497 U00f4							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    498 U00f4
    499 U00f4
    500 U00f4
    501 U00f4							;------------------------------------------------------------------------------
      0 U00f4					      OVERLAY	BuildDrawFlags
      1 U00e3 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00d8					      org	Overlay
    503 U00d8
    504 U00d8		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    505 U00da		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    506 U00dc		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    507 U00de		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    508 U00e0							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    509 U00e0		       00	   BDF_BoardBank ds	1	; holds bank of current line
    510 U00e1							;  ENDIF
    511 U00e1		       00	   DHS_Line   ds	1
    512 U00e2		       00	   DHS_Stack  ds	1	; for restoring SP
    513 U00e3							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    515 U00e3
    516 U00e3							;------------------------------------------------------------------------------
    517 U00e3
      0 U00e3					      OVERLAY	Process
      1 U00db ????				      SEG.U	OVERLAY_Process
      2 U00d8					      org	Overlay
    519 U00d8
    520 U00d8		       00	   BOXLeft    ds	1
    521 U00d9		       00	   BOXRight   ds	1
    522 U00da		       00	   restorationCharacter ds	1
    523 U00db
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    525 U00db
    526 U00db							;------------------------------------------------------------------------------
    527 U00db
      0 U00db					      OVERLAY	Animate
      1 U00d9 ????				      SEG.U	OVERLAY_Animate
      2 U00d8					      org	Overlay
    529 U00d8		       00	   halftimer  ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    531 U00d9
    532 U00d9							;------------------------------------------------------------------------------
    533 U00d9
      0 U00d9					      OVERLAY	TimeSlice
      1 U00da ????				      SEG.U	OVERLAY_TimeSlice
      2 U00d8					      org	Overlay
    535 U00d8
    536 U00d8		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    537 U00da							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    539 U00da
    540 U00da							;------------------------------------------------------------------------------
    541 U00da
      0 U00da					      OVERLAY	CopyROMShadowToRAM
      1 U00db ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00d8					      org	Overlay
    543 U00d8
    544 U00d8		       00	   O_CopyCount ds	1
    545 U00d9		       00	   O_ROM_Source_Bank ds	1
    546 U00da		       00	   O_Index    ds	1
    547 U00db							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    549 U00db
    550 U00db							;------------------------------------------------------------------------------
    551 U00db
      0 U00db					      OVERLAY	Scoring
      1 U00da ????				      SEG.U	OVERLAY_Scoring
      2 U00d8					      org	Overlay
    553 U00d8		       00	   tmpStack   ds	1
    554 U00d8		       00 d8	   newDisplay =	tmpStack
    555 U00d9							; also for UpdateTimer
    556 U00d9		       00 d8	   tmpSound   =	tmpStack
    557 U00d9		       00	   timerLoops ds	1
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    559 U00da
    560 U00da
    561 U00da							;------------------------------------------------------------------------------
    562 U00da
      0 U00da					      OVERLAY	SaveKey
      1 U00e1 ????				      SEG.U	OVERLAY_SaveKey
      2 U00d8					      org	Overlay
    564 U00d8
    565 U00d8		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    566 U00db		       00 00 00    highScoreSK ds	3
    567 U00de		       00	   startingLevel ds	1	; levelx * 5
    568 U00df		       00	   startLevel ds	1
    569 U00e0		       00	   offsetSK   ds	1	; for calculating the SK slot address
    570 U00e1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    572 U00e1
    573 U00e1							;------------------------------------------------------------------------------
    574 U00e1
      0 U00e1					      OVERLAY	DrawMan
      1 U00da ????				      SEG.U	OVERLAY_DrawMan
      2 U00d8					      org	Overlay
    576 U00d8
    577 U00d8		       00 00	   MAN_Move   ds	2
    578 U00da
    579 U00da							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    581 U00da
    582 U00da							;------------------------------------------------------------------------------
    583 U00da
      0 U00da					      OVERLAY	ProcessObjStack
      1 U00da ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00d8					      org	Overlay
    585 U00d8
    586 U00d8		       00 00	   POS_Vector ds	2
    587 U00da
    588 U00da							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    590 U00da
    591 U00da							;------------------------------------------------------------------------------
    592 U00da
      0 U00da					      OVERLAY	ScoreLineOverlay
      1 U00e7 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00d8					      org	Overlay
    594 U00d8
    595 U00d8		       00 00	   S0	      ds	2	; used for addressing digits of score
    596 U00da		       00 00	   S1	      ds	2
    597 U00dc		       00 00	   S2	      ds	2
    598 U00de		       00 00	   S3	      ds	2
    599 U00e0		       00 00	   S4	      ds	2
    600 U00e2		       00 00	   S5	      ds	2
    601 U00e4
    602 U00e4		       00	   stkp       ds	1
    603 U00e5		       00	   sreg       ds	1
    604 U00e6		       00	   loop       ds	1
    605 U00e7
    606 U00e7							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e7					      VALIDATE_OVERLAY
      5 U00e7					      LIST	ON
    608 U00e7
    609 U00e7							;------------------------------------------------------------------------------
    610 U00e7
    611 U00e7
      0 U00e7					      OVERLAY	UnpackLevelOverlay
      1 U00dd ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00d8					      org	Overlay
    613 U00d8
    614 U00d8		       00	   base_x     ds	1
    615 U00d9		       00	   base_y     ds	1
    616 U00da		       00	   upk_length ds	1
    617 U00db		       00	   upk_column ds	1
    618 U00dc		       00	   upk_temp   ds	1
    619 U00dd
    620 U00dd							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    622 U00dd
    623 U00dd							;------------------------------------------------------------------------------
    624 U00dd
      0 U00dd					      OVERLAY	ManProcessing
      1 U00da ????				      SEG.U	OVERLAY_ManProcessing
      2 U00d8					      org	Overlay
    626 U00d8		       00 00	   actionVector ds	2
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    628 U00da
      0 U00da					      OVERLAY	SetPlatformColours
      1 U00d9 ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00d8					      org	Overlay
    630 U00d8		       00	   colorIdx   ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    632 U00d9
      0 U00d9					      OVERLAY	SwapPlayers
      1 U00d9 ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00d8					      org	Overlay
    634 U00d8		       00	   tmpX       ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    636 U00d9
      0 U00d9					      OVERLAY	DrawIntoStack
      1 U00d9 ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00d8					      org	Overlay
    638 U00d8		       00	   save_SP    ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    640 U00d9
    641 U00d9							;------------------------------------------------------------------------------
    642 U00d9							;##############################################################################
    643 U00d9							;------------------------------------------------------------------------------
    644 U00d9
    645 U00d9							; NOW THE VERY INTERESTING '3E' RAM BANKS
    646 U00d9							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    647 U00d9
    648 U00d9				   ORIGIN     SET	0
      0 U00d9					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    650 U0000
    651 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    652 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    653 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    654 U0000
    655 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    656 U0000
    657 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    658 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    659 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    660 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    661 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    662 U0000
    663 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    664 U0000							; is that we can use that code to switch between banks, and the system will happily
    665 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    666 U0000
    667 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    668 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    669 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    670 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    671 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    672 U0000
    673 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    674 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    675 U0000							; part of the draw routine *every* scanline (though the system currently uses
    676 U0000							; one colour shared between both players).
    677 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    679 U0000
    680 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    681 U0000							; accessed via the above labels but with the appropriate bank switched in.
    682 U0000
    683 U0000							;------------------------------------------------------------------------------
    684 U0000
    685 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    685 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    685 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    685 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    685 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    685 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    685 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    688 U1c00					      REPEND
    689 U1c00
    690 U1c00							;------------------------------------------------------------------------------
    691 U1c00							;##############################################################################
    692 U1c00							;------------------------------------------------------------------------------
    693 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    695 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    696 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    698 U2000
    699 U2000							;------------------------------------------------------------------------------
    700 U2000							;##############################################################################
    701 U2000							;------------------------------------------------------------------------------
    702 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    704 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    705 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    707 U2400
    708 U2400							;------------------------------------------------------------------------------
    709 U2400							;##############################################################################
    710 U2400							;------------------------------------------------------------------------------
    711 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    713 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    714 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    716 U2800
    717 U2800							;------------------------------------------------------------------------------
    718 U2800							;##############################################################################
    719 U2800							;------------------------------------------------------------------------------
    720 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    722 U2c00
    723 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    724 U2c00							; position of something that needs to be processed.  These things include anything
    725 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    726 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    727 U2c00							; one for the next processing iteration.
    728 U2c00
    729 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    730 U2c00
    731 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    732 U2c00
    733 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    734 U2c00
    735 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    736 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    737 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    738 U2d80
    739 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    740 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    741 U2e00
    742 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    743 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    744 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    745 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    747 U2e80
    748 U2e80							;------------------------------------------------------------------------------
    749 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    751 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    753 U3000
    754 U3000							;------------------------------------------------------------------------------
    755 U3000							;##############################################################################
    756 U3000							;------------------------------------------------------------------------------
    757 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    759 U3400
    760 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    761 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    762 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    763 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    764 U3400							; when accessing.
    765 U3400
    766 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    767 U3400							; automatically based on the sizes set in these constants. The board may overlay
    768 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    769 U3400							; we're doing OK.
    770 U3400
    771 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    772 U3400
    773 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    774 U3400
    775 U3400		       00 28	   SIZE_BOARD_X =	40
    776 U3400		       00 16	   SIZE_BOARD_Y =	22
    777 U3400
    778 U3400							; have to precalculate it here, else DASM freaks out:
    779 U3400				   .BOARD_SIZE SET	0
    780 U3400				   .BOARD_LOCATION SET	0
    781 U3400					      REPEAT	SIZE_BOARD_Y
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    789 U3400					      REPEND
    790 U3400
    791 U3400		       03 a0	   SIZE_BOARD =	.BOARD_SIZE
    792 U3400
    793 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    794 U3400				  -MULTI_BANK_BOARD =	YES
    795 U3400					      ELSE
    796 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    797 U3400					      ENDIF
    798 U3400
    799 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    800 U37a0							; 1024 byte chunks, switching RAM
    801 U37a0							; banks as we go.  In other words,
    802 U37a0							; this overlaps multiple banks!
    803 U37a0
    804 U37a0
    805 U37a0							; free space here (but hard to use)
    806 U37a0							; So we need to calculate where the next free bank is!
    807 U37a0							; TODO: This looks dodgy.  Check..
    808 U37a0
    809 U37a0				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    810 U37a0				   ORIGIN     SET	ORIGIN * RAM_SIZE
    811 U37a0
    812 U37a0
    813 U37a0
    814 U37a0							;------------------------------------------------------------------------------
    815 U37a0							;##############################################################################
    816 U37a0							;------------------------------------------------------------------------------
    817 U37a0
    818 U37a0							;------------------------------------------------------------------------------
    819 U37a0
    820 U37a0							;    IFNCONST MAX_LEVEL_SIZE
    821 U37a0				   MAX_LEVEL_SIZE SET	0
    822 U37a0							;    ENDIF
    823 U37a0
    824 U37a0					      MAC	start_level
    825 U37a0				   LEVEL_START SET	*
    826 U37a0				   BANK_LEVEL_{1} =	_CURRENT_BANK
    827 U37a0				   LEVEL_{1}  SUBROUTINE
    828 U37a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    829 U37a0							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    830 U37a0					      ENDM		; {name}
    831 U37a0
    832 U37a0
    833 U37a0					      MAC	end_level
    834 U37a0					      .byte	0
    835 U37a0				   LEVEL_SIZE_{1} =	* - LEVEL_START
    836 U37a0					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    837 U37a0				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    838 U37a0					      ENDIF
    839 U37a0					      ENDM		; {name}
    840 U37a0
    841 U37a0
    842 U37a0					      MAC	defl
    843 U37a0					      START_LEVEL	{1}
    844 U37a0					      .byte	{2},0
    845 U37a0					      END_LEVEL	{1}
    846 U37a0					      ENDM
    847 U37a0
    848 U37a0							;--------------------------------------------------------------------------------
    849 U37a0
    850 U37a0				   ORIGIN     SET	$00000
    851 U37a0
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0 U37a0					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U37a0							;    Sokoboo - a Sokoban implementation
      2 U37a0							;    using a generic tile-based display engine for the Atari 2600
      3 U37a0							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U37a0							;
      5 U37a0							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U37a0							;
      7 U37a0							;    Code related to the generic tile-based display engine was developed by
      8 U37a0							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U37a0							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U37a0							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U37a0							;
     12 U37a0							;    Code related to music and sound effects uses the TIATracker music player
     13 U37a0							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U37a0							;    directory for Apache licensing details.
     15 U37a0							;
     16 U37a0							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U37a0							;    See the copyright notices in the License directory for a list of level
     18 U37a0							;    contributors.
     19 U37a0							;
     20 U37a0							;    Except where otherwise indicated, this software is released under the
     21 U37a0							;    following licensing arrangement...
     22 U37a0							;
     23 U37a0							;    This program is free software: you can redistribute it and/or modify
     24 U37a0							;    it under the terms of the GNU General Public License as published by
     25 U37a0							;    the Free Software Foundation, either version 3 of the License, or
     26 U37a0							;    (at your option) any later version.
     27 U37a0							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U37a0
     29 U37a0							;    This program is distributed in the hope that it will be useful,
     30 U37a0							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U37a0							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U37a0							;    GNU General Public License for more details.
     33 U37a0
     34 U37a0							;------------------------------------------------------------------------------
     35 U37a0							;##############################################################################
     36 U37a0							;------------------------------------------------------------------------------
      0 U37a0					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  0348 ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
     48  0000		       00 01	   _PROFILE_DRAW =	YES
     49  0000
     50  0000					      MAC	profile_draw
     51  0000					      IF	_PROFILE_DRAW
     52  0000					      inc	Profile{1}
     53  0000					      bne	$skip
     54  0000					      inc	Profile{1}+1
     55  0000				   $skip
     56  0000					      ENDIF
     57  0000					      ENDM		; {label}
     58  0000
     59  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     61  0000
     62  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     63  0000							; A refactor of the kernel to improve the timing.
     64  0000							; Experimental refactor to remove the blank line...
     65  0000
     66  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     67  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     68  0000
     69  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     70  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     72  0002
     73  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     74  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     75  0006
     76  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     78  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     79  000a
     80  000a				   ScanRED		;	     @60
     81  000a		       b9 05 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     82  000d		       85 4d		      sta	PF0	; 3	     @67
     83  000f		       b9 87 f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     84  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     85  0014				   SELFMOD_PLAYERCOL_RED
     86  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     87  0017		       85 46		      sta	COLUP0	; 3	     @05
     88  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     89  001b
     90  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     91  001b
     92  001b				   SELFMOD_RED
     93  001b		       a9 00		      lda	#0	; 2
     94  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     95  001f
     96  001f				   SELFMOD_PLAYER0_RED
     97  001f		       b9 05 f3 	      lda	ShapePlayerRED,y	; 4
     98  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
     99  0024
    100  0024		       b9 9c f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
    101  0027		       85 4f		      sta	PF2	; 3 =	7    @27
    102  0029
    103  0029		       b9 05 f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
    104  002c		       85 4d		      sta	PF0	; 3	     @34
    105  002e		       b9 b1 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
    106  0031		       85 4e		      sta	PF1	; 3	     @41
    107  0033		       b9 c6 f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    108  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    109  0038
    110  0038				   SELFMOD_PLAYER1_RED
    111  0038		       b9 05 f3 	      lda	ShapePlayerRED,y	; 4
    112  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
    113  003e
    114  003e		       88		      dey		; 2
    115  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
    116  0041
    117  0041		       e8	   SELFMOD_X  inx		; 2
    118  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    119  0044							;EXIT_RETURN_HERE
    120  0044				   NextALineStart
    121  0044		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    122  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    123  0046
    124  0046							;------------------------------------------------------------------------------
    125  0046
    126  0046		       b9 05 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    127  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    128  004b				   SELFMOD_PLAYERCOL_BLUE
    129  004b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
    130  004e		       85 47		      sta	COLUP1	; 3	     @05
    131  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    132  0052
    133  0052				   SELFMOD_BLUE
    134  0052		       a9 00		      lda	#0	; 2
    135  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    136  0056
    137  0056				   SELFMOD_PLAYER0_BLUE
    138  0056		       b9 05 f3 	      lda	ShapePlayerBLUE,y	; 4
    139  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    140  005b
    141  005b		       b9 95 f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    142  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    143  0060		       b9 aa f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    144  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    145  0065
    146  0065		       b9 05 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    147  0068		       85 4d		      sta	PF0	; 3	     @41
    148  006a		       b9 bf f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    149  006d		       85 4e		      sta	PF1	; 3	     @48
    150  006f		       b9 d4 f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    151  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    152  0074
    153  0074				   SELFMOD_PLAYER1_BLUE
    154  0074		       b9 05 f3 	      lda	ShapePlayerBLUE,y	; 4
    155  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    156  0079
    157  0079							;------------------------------------------------------------------------------
    158  0079
    159  0079				   ScanGREEN		;	     @62
    160  0079		       b9 05 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    161  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    162  007e				   SELFMOD_PLAYERCOL_GREEN
    163  007e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    164  0081		       85 47		      sta	COLUP1	; 3	     @00
    165  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    166  0085
    167  0085				   SELFMOD_GREEN
    168  0085		       a9 00		      lda	#0	; 2
    169  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    170  0089
    171  0089				   SELFMOD_PLAYER0_GREEN
    172  0089		       b9 05 f3 	      lda	ShapePlayerGREEN,y	; 4
    173  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    174  008e
    175  008e		       b9 8e f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    176  0091		       85 4e		      sta	PF1	; 3	     @22
    177  0093		       b9 a3 f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    178  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    179  0098
    180  0098		       b9 05 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    181  009b		       85 4d		      sta	PF0	; 3	     @36
    182  009d		       b9 b8 f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    183  00a0		       85 4e		      sta	PF1	; 3	     @43
    184  00a2		       b9 cd f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    185  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    186  00a7
    187  00a7				   SELFMOD_PLAYER1_GREEN
    188  00a7		       b9 05 f3 	      lda	ShapePlayerGREEN,y	; 4
    189  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    190  00ac
    191  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    192  00af
    193  00af							;------------------------------------------------------------------------------
    194  00af
    195  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    196  00af
    197  00af		       f3 05	   ShapePlayer =	PLAYER_BLANK
    198  00af		       f3 05	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    199  00af		       f3 05	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    200  00af		       f3 05	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    201  00af
    202  00af		       f3 05	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    203  00af		       f3 05	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    204  00af
------- FILE playerColour.asm LEVEL 3 PASS 3
      0  00af					      include	"playerColour.asm"	; 1 * LINES_PER_CHAR bytes
      1  00af							;;    Sokoboo - a Sokoban implementation
      2  00af							;    using a generic tile-based display engine for the Atari 2600
      3  00af							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  00af							;
      5  00af							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  00af							;
      7  00af							;    Code related to the generic tile-based display engine was developed by
      8  00af							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  00af							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  00af							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  00af							;
     12  00af							;    Code related to music and sound effects uses the TIATracker music player
     13  00af							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  00af							;    directory for Apache licensing details.
     15  00af							;
     16  00af							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  00af							;    See the copyright notices in the License directory for a list of level
     18  00af							;    contributors.
     19  00af							;
     20  00af							;    Except where otherwise indicated, this software is released under the
     21  00af							;    following licensing arrangement...
     22  00af							;
     23  00af							;    This program is free software: you can redistribute it and/or modify
     24  00af							;    it under the terms of the GNU General Public License as published by
     25  00af							;    the Free Software Foundation, either version 3 of the License, or
     26  00af							;    (at your option) any later version.
     27  00af							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  00af
     29  00af							;    This program is distributed in the hope that it will be useful,
     30  00af							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  00af							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  00af							;    GNU General Public License for more details.
     33  00af
      0  00af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  00af					      LIST	ON
     35  00af
     36  00af		       00 10	   YELLOW_NTSC =	$10	; hair
     37  00af		       00 30	   ORANGE_NTSC =	$30	; skin
     38  00af		       00 40	   RED_NTSC   =	$40	; shirt
     39  00af		       00 a4	   BLUE_NTSC  =	$A4
     40  00af
     41  00af		       00 20	   YELLOW_PAL =	$20
     42  00af		       00 40	   ORANGE_PAL =	$40
     43  00af		       00 60	   RED_PAL    =	$60
     44  00af
     45  00af				   SpriteColour
     46  00af							; NTSC
     47  00af							;SpriteColourRED
     48  00af							;    .byte RED_NTSC|$6       ; 0 feet
     49  00af							;    .byte WHITE	      ; 3
     50  00af							;    .byte RED_NTSC|$4       ; 6
     51  00af							;    .byte RED_NTSC|$4       ; 9
     52  00af							;    .byte ORANGE_NTSC|$6    ;12
     53  00af							;    .byte ORANGE_NTSC|$8    ;15
     54  00af							;    .byte WHITE	      ;18
     55  00af							;SpriteColourGREEN
     56  00af							;    .byte RED_NTSC|$4       ; 1
     57  00af							;    .byte WHITE	      ; 4
     58  00af							;    .byte WHITE	      ; 7
     59  00af							;    .byte WHITE	      ;10
     60  00af							;    .byte ORANGE_NTSC|$8    ;13
     61  00af							;    .byte ORANGE_NTSC|$6    ;16
     62  00af							;    .byte WHITE	      ;19
     63  00af							;SpriteColourBLUE
     64  00af							;    .byte WHITE	      ; 2
     65  00af							;    .byte RED_NTSC|$4       ; 5
     66  00af							;    .byte RED_NTSC|$4       ; 8
     67  00af							;    .byte ORANGE_NTSC|$4    ;11 neck
     68  00af							;    .byte ORANGE_NTSC|$a    ;14
     69  00af							;    .byte YELLOW_NTSC|$c    ;17 hair
     70  00af							;    .byte WHITE	      ;20
     71  00af
     72  00af				   SpriteColourRED
     73  00af		       0e		      .byte.b	WHITE
     74  00b0		       0e		      .byte.b	WHITE
     75  00b1		       0e		      .byte.b	WHITE
     76  00b2		       0e		      .byte.b	WHITE
     77  00b3		       0e		      .byte.b	WHITE
     78  00b4		       0e		      .byte.b	WHITE
     79  00b5		       0e		      .byte.b	WHITE
     80  00b6
     81  00b6							;  .byte #$1C;0
     82  00b6							;  .byte #$78;3
     83  00b6							;  .byte #$52;6
     84  00b6							;  .byte #$52;9
     85  00b6							;  .byte #$0C;12
     86  00b6							;  .byte #$4A;15
     87  00b6							;  .byte #$1A;18
     88  00b6				   SpriteColourGREEN
     89  00b6		       0e		      .byte.b	WHITE
     90  00b7		       0e		      .byte.b	WHITE
     91  00b8		       0e		      .byte.b	WHITE
     92  00b9		       0e		      .byte.b	WHITE
     93  00ba		       0e		      .byte.b	WHITE
     94  00bb		       0e		      .byte.b	WHITE
     95  00bc		       0e		      .byte.b	WHITE
     96  00bd				   SpriteColourBLUE
     97  00bd		       0e		      .byte.b	WHITE
     98  00be		       0e		      .byte.b	WHITE
     99  00bf		       0e		      .byte.b	WHITE
    100  00c0		       0e		      .byte.b	WHITE
    101  00c1		       0e		      .byte.b	WHITE
    102  00c2		       0e		      .byte.b	WHITE
    103  00c3		       0e		      .byte.b	WHITE
    104  00c4
    105  00c4					      REPEAT	21
    106  00c4		       26		      .byte.b	$20|$6	; 2
    105  00c4					      REPEND
    106  00c5		       26		      .byte.b	$20|$6	; 2
    105  00c5					      REPEND
    106  00c6		       26		      .byte.b	$20|$6	; 2
    105  00c6					      REPEND
    106  00c7		       26		      .byte.b	$20|$6	; 2
    105  00c7					      REPEND
    106  00c8		       26		      .byte.b	$20|$6	; 2
    105  00c8					      REPEND
    106  00c9		       26		      .byte.b	$20|$6	; 2
    105  00c9					      REPEND
    106  00ca		       26		      .byte.b	$20|$6	; 2
    105  00ca					      REPEND
    106  00cb		       26		      .byte.b	$20|$6	; 2
    105  00cb					      REPEND
    106  00cc		       26		      .byte.b	$20|$6	; 2
    105  00cc					      REPEND
    106  00cd		       26		      .byte.b	$20|$6	; 2
    105  00cd					      REPEND
    106  00ce		       26		      .byte.b	$20|$6	; 2
    105  00ce					      REPEND
    106  00cf		       26		      .byte.b	$20|$6	; 2
    105  00cf					      REPEND
    106  00d0		       26		      .byte.b	$20|$6	; 2
    105  00d0					      REPEND
    106  00d1		       26		      .byte.b	$20|$6	; 2
    105  00d1					      REPEND
    106  00d2		       26		      .byte.b	$20|$6	; 2
    105  00d2					      REPEND
    106  00d3		       26		      .byte.b	$20|$6	; 2
    105  00d3					      REPEND
    106  00d4		       26		      .byte.b	$20|$6	; 2
    105  00d4					      REPEND
    106  00d5		       26		      .byte.b	$20|$6	; 2
    105  00d5					      REPEND
    106  00d6		       26		      .byte.b	$20|$6	; 2
    105  00d6					      REPEND
    106  00d7		       26		      .byte.b	$20|$6	; 2
    105  00d7					      REPEND
    106  00d8		       26		      .byte.b	$20|$6	; 2
    107  00d9					      REPEND
    108  00d9
    109  00d9							; PAL
    110  00d9							;    .byte RED_PAL|$6	      ; 0 feet
    111  00d9							;    .byte WHITE	      ; 3
    112  00d9							;    .byte RED_PAL|$4	      ; 6
    113  00d9							;    .byte RED_PAL|$4	      ; 9
    114  00d9							;    .byte ORANGE_PAL|$4     ;12
    115  00d9							;    .byte ORANGE_PAL|$6     ;15
    116  00d9							;    .byte WHITE	      ;18
    117  00d9							;
    118  00d9							;    .byte RED_PAL|$4	      ; 1
    119  00d9							;    .byte WHITE	      ; 4
    120  00d9							;    .byte WHITE	      ; 7
    121  00d9							;    .byte WHITE	      ;10
    122  00d9							;    .byte ORANGE_PAL|$6     ;13
    123  00d9							;    .byte ORANGE_PAL|$4     ;16
    124  00d9							;    .byte WHITE	      ;19
    125  00d9							;
    126  00d9							;    .byte WHITE	      ; 2
    127  00d9							;    .byte RED_PAL|$4	      ; 5
    128  00d9							;    .byte RED_PAL|$4	      ; 8
    129  00d9							;    .byte ORANGE_PAL|$2     ;11 neck
    130  00d9							;    .byte ORANGE_PAL|$8     ;14
    131  00d9							;    .byte YELLOW_PAL|$c     ;17 hair
    132  00d9							;    .byte WHITE	      ;20
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    206  00d9
    207  00d9
    208  00d9							;------------------------------------------------------------------------------
    209  00d9
    210  00d9							;*** Ideas: ***
    211  00d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    212  00d9							;   13.5% on average), also unrolling would be more effective than now
    213  00d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    214  00d9							;   see EXPERIMENTAL)
    215  00d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    216  00d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    217  00d9							;   bidirectional linked list instead)
    218  00d9							; - calculate mirrored gfx data into RAM (saves ROM)
    219  00d9
    220  00d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    221  00d9							;currently:
    222  00d9							; 72%*539 (!unrolled)
    223  00d9							;+ 8%*304 (unrolled)
    224  00d9							;+20%*269 (unrolled)
    225  00d9							;--------
    226  00d9							;=   ~466.2 cycles on average
    227  00d9
    228  00d9							;alternative #1:
    229  00d9							; 72%*522 (unrolled)
    230  00d9							;+ 8%*352 (!unrolled)
    231  00d9							;+20%*307 (!unrolled)
    232  00d9							;--------
    233  00d9							;=   ~465.4 cycles on average
    234  00d9
    235  00d9
    236  00d9		       00 01	   MIRROR     =	1
    237  00d9		       00 80	   DIRECT     =	$80
    238  00d9
    239  00d9							;------------------------------------------------------------------------------
    240  00d9							; Here we don't draw into a buffer, but directly patch the kernel
    241  00d9							; VERY fast!
    242  00d9							;
    243  00d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    244  00d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    245  00d9
    246  00d9				   PF0Draw		; 25 cycles until here
    247  00d9
    248  00d9		       ae 84 02 	      ldx	INTIM	; 4
    249  00dc		       e0 05		      cpx	#SEGTIME_SCD_PF0	; 2
    250  00de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  00e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  00e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  00e0				  -
      3  00e0				  -
      4  00e0				  -
      5  00e0				  -
      6  00e0				  -
      7  00e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00e0				  -	      bne	. - 7
      9  00e0					      ENDIF
    252  00e0
    253  00e0		       29 7f		      and	#<(~DIRECT)	; 2
    254  00e2		       aa		      tax		; 2 =	4
    255  00e3
    256  00e3		       98		      tya		; 2
    257  00e4		       0a		      asl		; 2	     no mirrored chars in PF0
    258  00e5		       a8		      tay		; 2 =	6
    259  00e6							;		  clc				  ; 2
    260  00e6
    261  00e6		       b9 89 fc 	      lda	CharacterDataVecHI,y	; 4
    262  00e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    263  00ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    264  00ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    265  00f2
    266  00f2		       b9 75 fc 	      lda	CharacterDataVecLO,y	; 4
    267  00f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    268  00f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    269  00fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    270  00fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    271  00ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    272  0102
    273  0102		       4c 60 fa 	      jmp	DrawAnother	; 3 =	3
    274  0105
    275  0105							; Timing for PF0Draw
    276  0105							; 7+63 = 70
    277  0105							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    278  0105
    279  0105
    280  0105							;------------------------------------------------------------------------------
    281  0105							; Direct draw draws to PF0, which only has one active member of the character
    282  0105							; pair -- so it can be a direct copy.	Quicker still!
    283  0105
    284  0105				   DirectDraw		; 37 cycles until here
    285  0105
    286  0105							;ldy #16
    287  0105		       ad 84 02 	      lda	INTIM	; 4
    288  0108		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    289  010a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  010c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  010c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  010c				  -
      3  010c				  -
      4  010c				  -
      5  010c				  -
      6  010c				  -
      7  010c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  010c				  -	      bne	. - 7
      9  010c					      ENDIF
    291  010c
    292  010c							; TIME REQUIRED FROM HERE (9/JAN)
    293  010c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    294  010c							; = 323 --> /64 = 5.04 USE 7
    295  010c
    296  010c		       b9 89 fc 	      lda	CharacterDataVecHI,y	; 4
    297  010f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    298  0112		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    299  0115		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    300  0118
    301  0118		       b9 75 fc 	      lda	CharacterDataVecLO,y	; 4
    302  011b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    303  011e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    304  0120		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    305  0123		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    306  0125		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    307  0128
    308  0128		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    309  012b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    310  012e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    311  0130		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    312  0133		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    313  0135		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    314  0138
    315  0138		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    316  013a				   TSFill3
    317  013a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    318  013d		       99 87 f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    319  0140		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    320  0143		       99 87 f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    321  0146		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    322  0149		       99 87 f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    323  014c
    324  014c		       88		      dey		; 2
      0  014d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  014d					      LIST	ON
      9  014d		       10 eb		      bpl	TSFill3
    326  014f
    327  014f		       4c 60 fa 	      jmp	DrawAnother	; 3
    328  0152
    329  0152							; Timing for DirectDraw
    330  0152							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    331  0152							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    332  0152
    333  0152				   ExitDraw
    334  0152		       60		      rts
    335  0153
    336  0153							;------------------------------------------------------------------------------
      0  0153					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  0153		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0153					      SUBROUTINE
      3  0153				   StealPart3
    338  0153
    339  0153		       bd ee f1 	      lda	MOD10,x	; 4
    340  0156		       30 81		      bmi	PF0Draw	; 2/3
    341  0158		       4a		      lsr		; 2
    342  0159		       aa		      tax		; 2
    343  015a		       98		      tya		; 2
    344  015b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    345  015c		       a8		      tay		; 2
    346  015d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    347  015f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    348  015f
    349  015f		       b9 89 fc 	      lda	CharacterDataVecHI,y	; 4
    350  0162		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    351  0164							;	     => 42 starting QuickDraw
    352  0164		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    353  0167
    354  0167		       ad 84 02 	      lda	INTIM	; 4
    355  016a		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    356  016c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  016e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  016e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  016e				  -
      3  016e				  -
      4  016e				  -
      5  016e				  -
      6  016e				  -
      7  016e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  016e				  -	      bne	. - 7
      9  016e					      ENDIF
    358  016e
    359  016e							; TIME REQUIRED FROM HERE (9/JAN)
    360  016e							; 8 + 16 + 8 + 2 + (21 * 23) -1 + (42 OVERHEAD WHEN RETURNING)
    361  016e							; = 558 --> /64 = 8.71 INTIM --> USE 10
    362  016e
    363  016e		       b9 75 fc 	      lda	CharacterDataVecLO,y	; 4
    364  0171		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    365  0174
    366  0174		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    367  0177		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    368  017a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    369  017d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    370  0180
    371  0180		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    372  0183		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    373  0186
    374  0186		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    375  0188
    376  0188							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    377  0188							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    378  0188
    379  0188				   TSFill
    380  0188
    381  0188		       b9 87 f2    SMLOAD     lda	ScreenBitmap,y	; 4
    382  018b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    383  018e		       29 00	   SMMASK     and	#0	; 2
    384  0190		       59 87 f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    385  0193		       99 87 f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    386  0196
    387  0196		       88		      dey		; 2
      0  0197					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  0197					      LIST	ON
      9  0197		       10 ef		      bpl	TSFill
    389  0199
    390  0199		       4c 60 fa 	      jmp	DrawAnother	; 3
    391  019c
    392  019c							; Timing for "SLOW" draw
    393  019c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    394  019c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    395  019c
    396  019c
    397  019c							;------------------------------------------------------------------------------
    398  019c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    399  019c							; existing character data, so can be special-cased from the normal character
    400  019c							; draw, saving roughly 230 cycles.
    401  019c
    402  019c				   QuickDraw		; 42 cycles until here
    403  019c
    404  019c		       ad 84 02 	      lda	INTIM	; 4
    405  019f		       c9 09		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    406  01a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  01a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  01a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  01a3				  -
      3  01a3				  -
      4  01a3				  -
      5  01a3				  -
      6  01a3				  -
      7  01a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  01a3				  -	      bne	. - 7
      9  01a3					      ENDIF
    408  01a3
    409  01a3							; TIME REQUIRED FROM HERE (9/JAN)
    410  01a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    411  01a3							;   = 348 --> /64 = 5.43. USE 7
    412  01a3
    413  01a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    414  01a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    415  01a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    416  01ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    417  01ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    418  01b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    419  01b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    420  01b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    421  01b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    422  01bc
    423  01bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    424  01bf
    425  01bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    426  01c1				   TSFill2
    427  01c1		       98		      tya		; 2
    428  01c2		       3d 87 f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    429  01c5		       9d 87 f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    430  01c8		       98		      tya		; 2
    431  01c9		       3d 87 f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    432  01cc		       9d 87 f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    433  01cf		       98		      tya		; 2
    434  01d0		       3d 87 f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    435  01d3		       9d 87 f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    436  01d6
    437  01d6		       ca		      dex		; 2
      0  01d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  01d7					      LIST	ON
      9  01d7		       10 e8		      bpl	TSFill2
    439  01d9
    440  01d9		       4c 60 fa 	      jmp	DrawAnother	; 3
    441  01dc
    442  01dc							; Timing for QuickDraw
    443  01dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    444  01dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    445  01dc
    446  01dc
    447  01dc							;------------------------------------------------------------------------------
    448  01dc
    449  01dc
    450  01dc				   CharAddressLO		;[abs char location % 10]
    451  01dc
    452  01dc							; Gives the absolute screen buffer address of the first line of the given character
    453  01dc							; Where character number is 0-9
    454  01dc
    455  01dc		       87		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    456  01dd		       87		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    457  01de		       9c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    458  01df		       9c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    459  01e0		       b1		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    460  01e1		       b1		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    461  01e2		       c6		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    462  01e3		       c6		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    463  01e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    464  01e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    465  01e4
    466  01e4				   CharMask		; [abs char location % 10]
    467  01e4
    468  01e4							; Gives the mask for any char of the screen (per row)
    469  01e4							; Note, this is hardwired to the screen format of 6 bytes/line
    470  01e4
    471  01e4		       0f		      .byte.b	$0F	; 1
    472  01e5		       f0		      .byte.b	$F0	; 2
    473  01e6				   CharMaskNeg
    474  01e6		       f0		      .byte.b	$F0	; 3/1
    475  01e7		       0f		      .byte.b	$0F	; 4/2
    476  01e8		       0f		      .byte.b	$0F	; 6/3
    477  01e9		       f0		      .byte.b	$F0	; 7/4
    478  01ea		       f0		      .byte.b	$F0	; 8/6
    479  01eb		       0f		      .byte.b	$0F	; 9/7
    480  01ec		       0f		      .byte.b	$0F	; -/8
    481  01ed		       f0		      .byte.b	$F0	; -/9
    482  01ee				   MOD10
    483  01ee					      REPEAT	SCREEN_LINES
    484  01ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01ee		       80		      .byte.b	DIRECT
    487  01ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01f4					      REPEND
    484  01f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01f8		       80		      .byte.b	DIRECT
    487  01f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01fe					      REPEND
    484  0202							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0202							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0202		       80		      .byte.b	DIRECT
    487  0203		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0207		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0208		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0208					      REPEND
    484  020c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  020c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  020c		       80		      .byte.b	DIRECT
    487  020d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0211		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0212		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0212					      REPEND
    484  0216							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0216							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0216		       80		      .byte.b	DIRECT
    487  0217		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  021b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  021c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  021c					      REPEND
    484  0220							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0220							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0220		       80		      .byte.b	DIRECT
    487  0221		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0225		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0226		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0226					      REPEND
    484  022a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  022a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  022a		       80		      .byte.b	DIRECT
    487  022b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  022f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0230		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0230					      REPEND
    484  0234							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0234							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0234		       80		      .byte.b	DIRECT
    487  0235		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0239		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  023a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  023e					      REPEND
    491  023e
    492  023e							;------------------------------------------------------------------------------
    493  023e
------- FILE characterset/target.asm LEVEL 3 PASS 3
      0  023e					      include	"characterset/target.asm"	; 2 * LINES_PER_CHAR + 2 bytes
      1  023e							;    Sokoboo - a Sokoban implementation
      2  023e							;    using a generic tile-based display engine for the Atari 2600
      3  023e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  023e							;
      5  023e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  023e							;
      7  023e							;    Code related to the generic tile-based display engine was developed by
      8  023e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  023e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  023e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  023e							;
     12  023e							;    Code related to music and sound effects uses the TIATracker music player
     13  023e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  023e							;    directory for Apache licensing details.
     15  023e							;
     16  023e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  023e							;    See the copyright notices in the License directory for a list of level
     18  023e							;    contributors.
     19  023e							;
     20  023e							;    Except where otherwise indicated, this software is released under the
     21  023e							;    following licensing arrangement...
     22  023e							;
     23  023e							;    This program is free software: you can redistribute it and/or modify
     24  023e							;    it under the terms of the GNU General Public License as published by
     25  023e							;    the Free Software Foundation, either version 3 of the License, or
     26  023e							;    (at your option) any later version.
     27  023e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  023e
     29  023e							;    This program is distributed in the hope that it will be useful,
     30  023e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  023e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  023e							;    GNU General Public License for more details.
     33  023e
     34  023e		       00 02	   TARGET_DEF =	2
     35  023e
     36  023e					      if	TARGET_DEF = 2
     37  023e
      0  023e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  023e					      LIST	ON
     39  023e				   CHARACTERSHAPE_TARGET2_MIRRORED
     40  023e		       00		      .byte.b	%00000000
     41  023f				   CHARACTERSHAPE_TARGET_MIRRORED
     42  023f		       00		      .byte.b	%00000000
     43  0240		       66		      .byte.b	%01100110
     44  0241		       66		      .byte.b	%01100110
     45  0242		       66		      .byte.b	%01100110
     46  0243		       66		      .byte.b	%01100110
     47  0244		       00		      .byte.b	%00000000
     48  0245		       00		      .byte.b	%00000000	;R
     49  0246		       00		      .byte.b	%00000000
     50  0247		       66		      .byte.b	%01100110
     51  0248		       66		      .byte.b	%01100110
     52  0249		       66		      .byte.b	%01100110
     53  024a		       66		      .byte.b	%01100110
     54  024b		       00		      .byte.b	%00000000
     55  024c		       00		      .byte.b	%00000000	;B
     56  024d		       00		      .byte.b	%00000000
     57  024e		       66		      .byte.b	%01100110
     58  024f		       66		      .byte.b	%01100110
     59  0250		       66		      .byte.b	%01100110
     60  0251		       66		      .byte.b	%01100110
     61  0252		       00		      .byte.b	%00000000
     62  0253							;    .byte %00000000 ;G
     63  0253
     64  0253							;--------------------------------------------------------------------------
     65  0253							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     66  0253				   CHARACTERSHAPE_TARGET2
     67  0253		       00		      .byte.b	%00000000
     68  0254				   CHARACTERSHAPE_TARGET
     69  0254		       00		      .byte.b	%00000000
     70  0255		       66		      .byte.b	%01100110
     71  0256		       66		      .byte.b	%01100110
     72  0257		       66		      .byte.b	%01100110
     73  0258		       66		      .byte.b	%01100110
     74  0259		       00		      .byte.b	%00000000
     75  025a		       00		      .byte.b	%00000000	;R
     76  025b		       00		      .byte.b	%00000000
     77  025c		       66		      .byte.b	%01100110
     78  025d		       66		      .byte.b	%01100110
     79  025e		       66		      .byte.b	%01100110
     80  025f		       66		      .byte.b	%01100110
     81  0260		       00		      .byte.b	%00000000
     82  0261		       00		      .byte.b	%00000000	;B
     83  0262		       00		      .byte.b	%00000000
     84  0263		       66		      .byte.b	%01100110
     85  0264		       66		      .byte.b	%01100110
     86  0265		       66		      .byte.b	%01100110
     87  0266		       66		      .byte.b	%01100110
     88  0267		       00		      .byte.b	%00000000
     89  0268		       00		      .byte.b	%00000000	;G
     90  0269
      0  0269					      CHECKPAGE	CHARACTERSHAPE_TARGET2	; since we share one byte!
      8  0269					      LIST	ON
     92  0269
     93  0269					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    495  0269		       00 00 00 00*	      ds	30	; todo - fixes a graphical glitch so we have a page boundary issue somewhwere
    496  0287
    497  0287
      0  0287					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  0287					      LIST	ON
    499  0287
    500  0287		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,$0	; character bitmap row (10 chars wide)
    501  0287		       f2 87	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    502  0287		       f2 8e	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    503  0287		       f2 95	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    504  02db
      0  02db					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  02db					      LIST	ON
    506  02db
    507  02db							;--------------------------------------------------------------------------
    508  02db							;    CHARACTER_SET
    509  02db
    510  02db							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    511  02db
    512  02db
      0  02db					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  02db		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  02db					      SUBROUTINE
      3  02db				   SelfModDrawPlayers
    514  02db
    515  02db							; Now the player(s) have animated, update the appropriate shape pointers
    516  02db							; in the draw code.
    517  02db
    518  02db							; Sets the shapes to a blank player -- effectively erasing
    519  02db		       a5 b0		      lda	LastSpriteY
    520  02dd		       a2 05		      ldx	#<PLAYER_BLANK
    521  02df		       20 ee f2 	      jsr	SetSelfModPlayer
    522  02e2
    523  02e2							; Now we've erased, we write the new shape
    524  02e2
    525  02e2							;		  sec
    526  02e2							;		  lda ManDrawX
    527  02e2							;		  sbc BoardScrollX
    528  02e2							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    529  02e2							;		  bcs NoMod				  ; skip if off visible screen
    530  02e2
    531  02e2		       a5 9d		      lda	ManDrawX
    532  02e4		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    533  02e6		       b0 1c		      bcs	NoMod	; skip if off visible screen
    534  02e8
    535  02e8							;lda LookingAround
    536  02e8							;bne NoMod
    537  02e8
    538  02e8		       a5 9e		      lda	ManDrawY
    539  02ea		       85 b0		      sta	LastSpriteY
    540  02ec
    541  02ec		       a6 a3		      ldx	ManAnimationFrameLO
    542  02ee
    543  02ee				   SetSelfModPlayer
    544  02ee		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    545  02f0		       b0 12		      bcs	NoMod
    546  02f2		       69 00		      adc	#BANK_SCREENMARKII1
    547  02f4		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    548  02f6
    549  02f6		       8a		      txa
    550  02f7		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    551  02fa		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    552  02fc		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    553  02ff		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    554  0301		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    555  0304
    556  0304				   NoMod
    557  0304		       60		      rts
    558  0305
      0  0305					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  0305
      2  0305
      3  0305		       03 05	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $305 , FREE= $fb
      4  0305					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0305				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0305				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0305				  -	      ERR
      8  0305					      endif
    560  0305
------- FILE player.asm LEVEL 3 PASS 3
      0  0305					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  0305							;    Sokoboo - a Sokoban implementation
      2  0305							;    using a generic tile-based display engine for the Atari 2600
      3  0305							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0305							;
      5  0305							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0305							;
      7  0305							;    Code related to the generic tile-based display engine was developed by
      8  0305							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0305							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0305							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0305							;
     12  0305							;    Code related to music and sound effects uses the TIATracker music player
     13  0305							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0305							;    directory for Apache licensing details.
     15  0305							;
     16  0305							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0305							;    See the copyright notices in the License directory for a list of level
     18  0305							;    contributors.
     19  0305							;
     20  0305							;    Except where otherwise indicated, this software is released under the
     21  0305							;    following licensing arrangement...
     22  0305							;
     23  0305							;    This program is free software: you can redistribute it and/or modify
     24  0305							;    it under the terms of the GNU General Public License as published by
     25  0305							;    the Free Software Foundation, either version 3 of the License, or
     26  0305							;    (at your option) any later version.
     27  0305							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0305
     29  0305							;    This program is distributed in the hope that it will be useful,
     30  0305							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0305							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0305							;    GNU General Public License for more details.
     33  0305
     34  0305							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
     35  0305
     36  0305
     37  0305		       f3 05	   PLAYER_BLANK =	.
     38  0305					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
     39  0305		       00		      .byte.b	0
     38  0305					      REPEND
     39  0306		       00		      .byte.b	0
     38  0306					      REPEND
     39  0307		       00		      .byte.b	0
     38  0307					      REPEND
     39  0308		       00		      .byte.b	0
     38  0308					      REPEND
     39  0309		       00		      .byte.b	0
     38  0309					      REPEND
     39  030a		       00		      .byte.b	0
     38  030a					      REPEND
     39  030b		       00		      .byte.b	0
     38  030b					      REPEND
     39  030c		       00		      .byte.b	0
     38  030c					      REPEND
     39  030d		       00		      .byte.b	0
     38  030d					      REPEND
     39  030e		       00		      .byte.b	0
     38  030e					      REPEND
     39  030f		       00		      .byte.b	0
     38  030f					      REPEND
     39  0310		       00		      .byte.b	0
     38  0310					      REPEND
     39  0311		       00		      .byte.b	0
     38  0311					      REPEND
     39  0312		       00		      .byte.b	0
     38  0312					      REPEND
     39  0313		       00		      .byte.b	0
     38  0313					      REPEND
     39  0314		       00		      .byte.b	0
     38  0314					      REPEND
     39  0315		       00		      .byte.b	0
     38  0315					      REPEND
     39  0316		       00		      .byte.b	0
     38  0316					      REPEND
     39  0317		       00		      .byte.b	0
     38  0317					      REPEND
     39  0318		       00		      .byte.b	0
     38  0318					      REPEND
     39  0319		       00		      .byte.b	0
     40  031a					      REPEND
     41  031a
     42  031a				   PLAYER_RIGHT0
     43  031a
     44  031a					      if	1
     45  031a		       18		      .byte.b	%00011000	;20
     46  031b		       18		      .byte.b	%00011000	;20
     47  031c		       7e		      .byte.b	%01111110	;20
     48  031d		       7e		      .byte.b	%01111110	;20
     49  031e		       7e		      .byte.b	%01111110	;20
     50  031f		       18		      .byte.b	%00011000	;20
     51  0320		       18		      .byte.b	%00011000	;20
     52  0321
     53  0321		       18		      .byte.b	%00011000	;20
     54  0322		       18		      .byte.b	%00011000	;20
     55  0323		       7e		      .byte.b	%01111110	;20
     56  0324		       7e		      .byte.b	%01111110	;20
     57  0325		       7e		      .byte.b	%01111110	;20
     58  0326		       18		      .byte.b	%00011000	;20
     59  0327		       18		      .byte.b	%00011000	;20
     60  0328
     61  0328		       18		      .byte.b	%00011000	;20
     62  0329		       18		      .byte.b	%00011000	;20
     63  032a		       7e		      .byte.b	%01111110	;20
     64  032b		       7e		      .byte.b	%01111110	;20
     65  032c		       7e		      .byte.b	%01111110	;20
     66  032d		       18		      .byte.b	%00011000	;20
     67  032e		       18		      .byte.b	%00011000	;20
     68  032f
     69  032f				  -	      else
     70  032f				  -			;push
     71  032f				  -	      .byte	#%01110000	;$1C 0
     72  032f				  -	      .byte	#%01110000	;$78 3
     73  032f				  -	      .byte	#%00010000	;$52 6
     74  032f				  -	      .byte	#%00111100	;$52 9
     75  032f				  -	      .byte	#%00011001	;$0C 12
     76  032f				  -	      .byte	#%00001100	;$4A 15
     77  032f				  -	      .byte	#%00001111	;$1A18
     78  032f				  -
     79  032f				  -	      .byte	#%10100000	;$1C 1
     80  032f				  -	      .byte	#%00111000	;$78 4
     81  032f				  -	      .byte	#%00111000	;$52 7
     82  032f				  -	      .byte	#%00111100	;$56 10
     83  032f				  -	      .byte	#%00001000	;$4A 13
     84  032f				  -	      .byte	#%00001100	;$4A 16
     85  032f				  -	      .byte	#%00001100	;$1C 19
     86  032f				  -
     87  032f				  -	      .byte	#%11010000	;$78 2
     88  032f				  -	      .byte	#%00101000	;$78 5
     89  032f				  -	      .byte	#%00111000	;$52 8
     90  032f				  -	      .byte	#%00011111	;$56 11
     91  032f				  -	      .byte	#%00001000	;$4A 14
     92  032f				  -	      .byte	#%00011010	;$4A 17
     93  032f				  -	      .byte	#%00001100	;$1C 20
     94  032f				  -
     95  032f					      endif
     96  032f
     97  032f				  -	      IF	0
     98  032f				  -			;---Graphics Data from PlayerPal 2600---
     99  032f				  -
    100  032f				  -Frame0
    101  032f				  -	      .byte	#%01110011	;$1C
    102  032f				  -	      .byte	#%00100110	;$1C
    103  032f				  -	      .byte	#%00110100	;$78
    104  032f				  -	      .byte	#%00010100	;$78
    105  032f				  -	      .byte	#%00011100	;$78
    106  032f				  -	      .byte	#%00001000	;$78
    107  032f				  -	      .byte	#%00010000	;$52
    108  032f				  -	      .byte	#%00111000	;$52
    109  032f				  -	      .byte	#%00111000	;$52
    110  032f				  -	      .byte	#%10111000	;$52
    111  032f				  -	      .byte	#%01111000	;$56
    112  032f				  -	      .byte	#%00110000	;$56
    113  032f				  -	      .byte	#%00111100	;$0C
    114  032f				  -	      .byte	#%00110010	;$4A
    115  032f				  -	      .byte	#%00010000	;$4A
    116  032f				  -	      .byte	#%00011000	;$4A
    117  032f				  -	      .byte	#%00011000	;$4A
    118  032f				  -	      .byte	#%00110100	;$4A
    119  032f				  -	      .byte	#%00011110	;$1A
    120  032f				  -	      .byte	#%00011000	;$1C
    121  032f				  -	      .byte	#%00011000	;$1C
    122  032f				  -Frame1
    123  032f				  -	      .byte	#%00110110	;$1C
    124  032f				  -	      .byte	#%00100100	;$1C
    125  032f				  -	      .byte	#%00010100	;$78
    126  032f				  -	      .byte	#%00010100	;$78
    127  032f				  -	      .byte	#%00011100	;$78
    128  032f				  -	      .byte	#%00001000	;$78
    129  032f				  -	      .byte	#%00010000	;$52
    130  032f				  -	      .byte	#%00111000	;$52
    131  032f				  -	      .byte	#%00011000	;$52
    132  032f				  -	      .byte	#%01111000	;$52
    133  032f				  -	      .byte	#%00111000	;$56
    134  032f				  -	      .byte	#%00110110	;$56
    135  032f				  -	      .byte	#%00111100	;$0C
    136  032f				  -	      .byte	#%00010000	;$4A
    137  032f				  -	      .byte	#%00010000	;$4A
    138  032f				  -	      .byte	#%00011000	;$4A
    139  032f				  -	      .byte	#%00011000	;$4A
    140  032f				  -	      .byte	#%00110100	;$4A
    141  032f				  -	      .byte	#%00011110	;$1A
    142  032f				  -	      .byte	#%00011000	;$1C
    143  032f				  -	      .byte	#%00011000	;$1C
    144  032f				  -Frame2
    145  032f				  -	      .byte	#%00011000	;$1C
    146  032f				  -	      .byte	#%00110000	;$1C
    147  032f				  -	      .byte	#%01010000	;$78
    148  032f				  -	      .byte	#%00111000	;$78
    149  032f				  -	      .byte	#%00011000	;$78
    150  032f				  -	      .byte	#%00001000	;$78
    151  032f				  -	      .byte	#%00010000	;$52
    152  032f				  -	      .byte	#%00111000	;$52
    153  032f				  -	      .byte	#%00111000	;$52
    154  032f				  -	      .byte	#%00111100	;$52
    155  032f				  -	      .byte	#%00110100	;$56
    156  032f				  -	      .byte	#%00111100	;$56
    157  032f				  -	      .byte	#%00111000	;$0C
    158  032f				  -	      .byte	#%00010000	;$4A
    159  032f				  -	      .byte	#%00010000	;$4A
    160  032f				  -	      .byte	#%00011000	;$4A
    161  032f				  -	      .byte	#%00011000	;$4A
    162  032f				  -	      .byte	#%00110100	;$4A
    163  032f				  -	      .byte	#%00011110	;$1A
    164  032f				  -	      .byte	#%00011000	;$1C
    165  032f				  -	      .byte	#%00011000	;$1C
    166  032f				  -Frame3
    167  032f				  -	      .byte	#%01110000	;$1C
    168  032f				  -	      .byte	#%10100000	;$1C
    169  032f				  -	      .byte	#%11010000	;$78
    170  032f				  -	      .byte	#%01110000	;$78
    171  032f				  -	      .byte	#%00111000	;$78
    172  032f				  -	      .byte	#%00101000	;$78
    173  032f				  -	      .byte	#%00010000	;$52
    174  032f				  -	      .byte	#%00111000	;$52
    175  032f				  -	      .byte	#%00111000	;$52
    176  032f				  -	      .byte	#%00111100	;$52
    177  032f				  -	      .byte	#%00111100	;$56
    178  032f				  -	      .byte	#%00011111	;$56
    179  032f				  -	      .byte	#%00011001	;$0C
    180  032f				  -	      .byte	#%00001000	;$4A
    181  032f				  -	      .byte	#%00001000	;$4A
    182  032f				  -	      .byte	#%00001100	;$4A
    183  032f				  -	      .byte	#%00001100	;$4A
    184  032f				  -	      .byte	#%00011010	;$4A
    185  032f				  -	      .byte	#%00001111	;$1A
    186  032f				  -	      .byte	#%00001100	;$1C
    187  032f				  -	      .byte	#%00001100	;$1C
    188  032f				  -Frame4
    189  032f				  -	      .byte	#%00110110	;$1C
    190  032f				  -	      .byte	#%00010100	;$1C
    191  032f				  -	      .byte	#%00010100	;$78
    192  032f				  -	      .byte	#%00010100	;$78
    193  032f				  -	      .byte	#%00011100	;$78
    194  032f				  -	      .byte	#%00001100	;$78
    195  032f				  -	      .byte	#%00010000	;$52
    196  032f				  -	      .byte	#%00011000	;$52
    197  032f				  -	      .byte	#%00011100	;$52
    198  032f				  -	      .byte	#%00111100	;$52
    199  032f				  -	      .byte	#%00111100	;$56
    200  032f				  -	      .byte	#%00111100	;$56
    201  032f				  -	      .byte	#%00111110	;$0C
    202  032f				  -	      .byte	#%01011010	;$4A
    203  032f				  -	      .byte	#%10010001	;$4A
    204  032f				  -	      .byte	#%10011001	;$4A
    205  032f				  -	      .byte	#%00011000	;$4A
    206  032f				  -	      .byte	#%00011000	;$4A
    207  032f				  -	      .byte	#%00011100	;$1A
    208  032f				  -	      .byte	#%00011000	;$1C
    209  032f				  -	      .byte	#%00010000	;$1C
    210  032f				  -Frame5
    211  032f				  -	      .byte	#%00110110	;$1C
    212  032f				  -	      .byte	#%00010100	;$1C
    213  032f				  -	      .byte	#%00010100	;$78
    214  032f				  -	      .byte	#%00010100	;$78
    215  032f				  -	      .byte	#%00011100	;$78
    216  032f				  -	      .byte	#%01001101	;$78
    217  032f				  -	      .byte	#%01010001	;$52
    218  032f				  -	      .byte	#%01011011	;$52
    219  032f				  -	      .byte	#%01011110	;$52
    220  032f				  -	      .byte	#%00111100	;$52
    221  032f				  -	      .byte	#%00111100	;$56
    222  032f				  -	      .byte	#%00011100	;$56
    223  032f				  -	      .byte	#%00011000	;$0C
    224  032f				  -	      .byte	#%00011000	;$4A
    225  032f				  -	      .byte	#%00011000	;$4A
    226  032f				  -	      .byte	#%00111000	;$4A
    227  032f				  -	      .byte	#%00001000	;$4A
    228  032f				  -	      .byte	#%00000000	;$4A
    229  032f				  -	      .byte	#%00000000	;$1A
    230  032f				  -	      .byte	#%00000000	;$1C
    231  032f				  -	      .byte	#%00000000	;$1C
    232  032f				  -			;---End Graphics Data---
    233  032f				  -
    234  032f				  -
    235  032f				  -			;---Color Data from PlayerPal 2600---
    236  032f				  -
    237  032f				  -ColorFrame0
    238  032f				  -	      .byte	#$1C	;
    239  032f				  -	      .byte	#$1C	;
    240  032f				  -	      .byte	#$78	;
    241  032f				  -	      .byte	#$78	;
    242  032f				  -	      .byte	#$78	;
    243  032f				  -	      .byte	#$78	;
    244  032f				  -	      .byte	#$52	;
    245  032f				  -	      .byte	#$52	;
    246  032f				  -	      .byte	#$52	;
    247  032f				  -	      .byte	#$52	;
    248  032f				  -	      .byte	#$56	;
    249  032f				  -	      .byte	#$56	;
    250  032f				  -	      .byte	#$0C	;
    251  032f				  -	      .byte	#$4A	;
    252  032f				  -	      .byte	#$4A	;
    253  032f				  -	      .byte	#$4A	;
    254  032f				  -	      .byte	#$4A	;
    255  032f				  -	      .byte	#$4A	;
    256  032f				  -	      .byte	#$1A	;
    257  032f				  -	      .byte	#$1C	;
    258  032f				  -	      .byte	#$1C	;
    259  032f				  -ColorFrame1
    260  032f				  -	      .byte	#$1C	;
    261  032f				  -	      .byte	#$1C	;
    262  032f				  -	      .byte	#$78	;
    263  032f				  -	      .byte	#$78	;
    264  032f				  -	      .byte	#$78	;
    265  032f				  -	      .byte	#$78	;
    266  032f				  -	      .byte	#$52	;
    267  032f				  -	      .byte	#$52	;
    268  032f				  -	      .byte	#$52	;
    269  032f				  -	      .byte	#$52	;
    270  032f				  -	      .byte	#$56	;
    271  032f				  -	      .byte	#$56	;
    272  032f				  -	      .byte	#$0C	;
    273  032f				  -	      .byte	#$4A	;
    274  032f				  -	      .byte	#$4A	;
    275  032f				  -	      .byte	#$4A	;
    276  032f				  -	      .byte	#$4A	;
    277  032f				  -	      .byte	#$4A	;
    278  032f				  -	      .byte	#$1A	;
    279  032f				  -	      .byte	#$1C	;
    280  032f				  -	      .byte	#$1C	;
    281  032f				  -ColorFrame2
    282  032f				  -	      .byte	#$1C	;
    283  032f				  -	      .byte	#$1C	;
    284  032f				  -	      .byte	#$78	;
    285  032f				  -	      .byte	#$78	;
    286  032f				  -	      .byte	#$78	;
    287  032f				  -	      .byte	#$78	;
    288  032f				  -	      .byte	#$52	;
    289  032f				  -	      .byte	#$52	;
    290  032f				  -	      .byte	#$52	;
    291  032f				  -	      .byte	#$52	;
    292  032f				  -	      .byte	#$56	;
    293  032f				  -	      .byte	#$56	;
    294  032f				  -	      .byte	#$0C	;
    295  032f				  -	      .byte	#$4A	;
    296  032f				  -	      .byte	#$4A	;
    297  032f				  -	      .byte	#$4A	;
    298  032f				  -	      .byte	#$4A	;
    299  032f				  -	      .byte	#$4A	;
    300  032f				  -	      .byte	#$1A	;
    301  032f				  -	      .byte	#$1C	;
    302  032f				  -	      .byte	#$1C	;
    303  032f				  -ColorFrame3
    304  032f				  -	      .byte	#$1C	;
    305  032f				  -	      .byte	#$1C	;
    306  032f				  -	      .byte	#$78	;
    307  032f				  -	      .byte	#$78	;
    308  032f				  -	      .byte	#$78	;
    309  032f				  -	      .byte	#$78	;
    310  032f				  -	      .byte	#$52	;
    311  032f				  -	      .byte	#$52	;
    312  032f				  -	      .byte	#$52	;
    313  032f				  -	      .byte	#$52	;
    314  032f				  -	      .byte	#$56	;
    315  032f				  -	      .byte	#$56	;
    316  032f				  -	      .byte	#$0C	;
    317  032f				  -	      .byte	#$4A	;
    318  032f				  -	      .byte	#$4A	;
    319  032f				  -	      .byte	#$4A	;
    320  032f				  -	      .byte	#$4A	;
    321  032f				  -	      .byte	#$4A	;
    322  032f				  -	      .byte	#$1A	;
    323  032f				  -	      .byte	#$1C	;
    324  032f				  -	      .byte	#$1C	;
    325  032f				  -ColorFrame4
    326  032f				  -	      .byte	#$1C	;
    327  032f				  -	      .byte	#$1C	;
    328  032f				  -	      .byte	#$78	;
    329  032f				  -	      .byte	#$78	;
    330  032f				  -	      .byte	#$78	;
    331  032f				  -	      .byte	#$78	;
    332  032f				  -	      .byte	#$52	;
    333  032f				  -	      .byte	#$52	;
    334  032f				  -	      .byte	#$52	;
    335  032f				  -	      .byte	#$52	;
    336  032f				  -	      .byte	#$56	;
    337  032f				  -	      .byte	#$56	;
    338  032f				  -	      .byte	#$0C	;
    339  032f				  -	      .byte	#$4A	;
    340  032f				  -	      .byte	#$4A	;
    341  032f				  -	      .byte	#$4A	;
    342  032f				  -	      .byte	#$4A	;
    343  032f				  -	      .byte	#$4A	;
    344  032f				  -	      .byte	#$1A	;
    345  032f				  -	      .byte	#$1C	;
    346  032f				  -	      .byte	#$1C	;
    347  032f				  -ColorFrame5
    348  032f				  -	      .byte	#$1C	;
    349  032f				  -	      .byte	#$1C	;
    350  032f				  -	      .byte	#$78	;
    351  032f				  -	      .byte	#$78	;
    352  032f				  -	      .byte	#$78	;
    353  032f				  -	      .byte	#$78	;
    354  032f				  -	      .byte	#$52	;
    355  032f				  -	      .byte	#$52	;
    356  032f				  -	      .byte	#$52	;
    357  032f				  -	      .byte	#$52	;
    358  032f				  -	      .byte	#$56	;
    359  032f				  -	      .byte	#$56	;
    360  032f				  -	      .byte	#$0C	;
    361  032f				  -	      .byte	#$4A	;
    362  032f				  -	      .byte	#$4A	;
    363  032f				  -	      .byte	#$4A	;
    364  032f				  -	      .byte	#$4A	;
    365  032f				  -	      .byte	#$4A	;
    366  032f				  -	      .byte	#$1A	;
    367  032f				  -	      .byte	#$1C	;
    368  032f				  -	      .byte	#$1C	;
    369  032f				  -			;---End Color Data---
    370  032f					      ENDIF
    371  032f
    372  032f
    373  032f							;.byte %00011000  ;  XXX   ; 0
    374  032f							;.byte %00111100  ;XXXXXX  ; 1
    375  032f							;.byte %01110100  ;XXXX X  ; 2 etc.
    376  032f							;.byte %01111100  ;XXXXXX  ; 3
    377  032f							;.byte %00111000  ;XXXXX   ;4
    378  032f							;.byte %01111100  ; XXXXX  ;5
    379  032f							;.byte %00111000  ;  XXX   ;6
    380  032f							;.byte %11111000  ;XXXXX   ;7
    381  032f							;.byte %11111100  ;XXXXXX  ;8
    382  032f							;.byte %11111100  ;XXXXXX  ;9 etc.
    383  032f							;.byte %10000100  ;X	 X  ;10
    384  032f							;.byte %11111100  ;XXXXXX  ;11
    385  032f							;.byte %00001100  ;	XX  ;12
    386  032f							;.byte %01111100  ; XXXXX  ;13
    387  032f							;.byte %01111100  ; XXXXX  ;14
    388  032f							;.byte %01111000  ; XXXX   ;15
    389  032f							;.byte %01111000  ; XXXX   ;16 etc.
    390  032f							;.byte %11111000  ;XXXXX   ;17
    391  032f							;.byte %11101100  ;XXX XX  ;18
    392  032f							;.byte %10111100  ;X XXXX  ;19
    393  032f							;.byte %11001100  ;XX	XX   20
    394  032f
    395  032f							;---Graphics Data from PlayerPal 2600---
    396  032f
    397  032f				   PLAYER_RIGHT1
    398  032f				   PLAYER_STAND
    399  032f				   PLAYER_BLINK
    400  032f				   PLAYER_TAP0
    401  032f				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/filler.asm LEVEL 3 PASS 3
      0  032f					      include	"characterset/filler.asm"	; 2 * LINES_PER_CHAR bytes
      1  032f							;    Sokoboo - a Sokoban implementation
      2  032f							;    using a generic tile-based display engine for the Atari 2600
      3  032f							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  032f							;
      5  032f							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  032f							;
      7  032f							;    Code related to the generic tile-based display engine was developed by
      8  032f							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  032f							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  032f							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  032f							;
     12  032f							;    Code related to music and sound effects uses the TIATracker music player
     13  032f							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  032f							;    directory for Apache licensing details.
     15  032f							;
     16  032f							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  032f							;    See the copyright notices in the License directory for a list of level
     18  032f							;    contributors.
     19  032f							;
     20  032f							;    Except where otherwise indicated, this software is released under the
     21  032f							;    following licensing arrangement...
     22  032f							;
     23  032f							;    This program is free software: you can redistribute it and/or modify
     24  032f							;    it under the terms of the GNU General Public License as published by
     25  032f							;    the Free Software Foundation, either version 3 of the License, or
     26  032f							;    (at your option) any later version.
     27  032f							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  032f
     29  032f							;    This program is distributed in the hope that it will be useful,
     30  032f							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  032f							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  032f							;    GNU General Public License for more details.
     33  032f
      0  032f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  032f					      LIST	ON
     35  032f				   CHARACTERSHAPE_SOIL
     36  032f				   CHARACTERSHAPE_SOIL_MIRRORED
     37  032f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
     38  0336		       ff		      .byte.b	%11111111
     39  0337		       ff		      .byte.b	%11111111
     40  0338		       ff		      .byte.b	%11111111
     41  0339		       ff		      .byte.b	%11111111
     42  033a		       ff		      .byte.b	%11111111
     43  033b		       ff		      .byte.b	%11111111
     44  033c		       ff		      .byte.b	%11111111
     45  033d		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    563  0344							;------------------------------------------------------------------------------
    564  0344
    565  0344							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    566  0344
    567  0344							;------------------------------------------------------------------------------
    568  0344
    569  0344
    570  0344
    571  0344							;	 CHECK_HALF_BANK_SIZE "ROM_SHADOW_OF_RAMBANK_CODE"
    572  0344
    573  0344
    574  0344							; Here there's another 1K of usable ROM....
    575  0344							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    576  0344
    577  0344							;-----------------------------------------------------------
    578  0344							; Stella 3E autodetect signature, can live anywhere
    579  0344		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
    580  0348							;-----------------------------------------------------------
    581  0348
      0  0348					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  0348		       03 48	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $348 , FREE= $4b8
      2  0348					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0348				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0348				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0348				  -	      ERR
      6  0348					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  0348					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  0348							;    Sokoboo - a Sokoban implementation
      2  0348							;    using a generic tile-based display engine for the Atari 2600
      3  0348							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0348							;
      5  0348							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0348							;
      7  0348							;    Code related to the generic tile-based display engine was developed by
      8  0348							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0348							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0348							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0348							;
     12  0348							;    Code related to music and sound effects uses the TIATracker music player
     13  0348							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0348							;    directory for Apache licensing details.
     15  0348							;
     16  0348							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0348							;    See the copyright notices in the License directory for a list of level
     18  0348							;    contributors.
     19  0348							;
     20  0348							;    Except where otherwise indicated, this software is released under the
     21  0348							;    following licensing arrangement...
     22  0348							;
     23  0348							;    This program is free software: you can redistribute it and/or modify
     24  0348							;    it under the terms of the GNU General Public License as published by
     25  0348							;    the Free Software Foundation, either version 3 of the License, or
     26  0348							;    (at your option) any later version.
     27  0348							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0348
     29  0348							;    This program is distributed in the hope that it will be useful,
     30  0348							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0348							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0348							;    GNU General Public License for more details.
     33  0348
     34  0348							;------------------------------------------------------------------------------
     35  0348							;##############################################################################
     36  0348							;------------------------------------------------------------------------------
     37  0348
      0  0348					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     58  08f0
     59  08f0
     60  08f0
     61  08f0							;------------------------------------------------------------------------------
     62  08f0							; RAM-BASED SUBROUTINES...
     63  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     64  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     65  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     66  08f0							; the RAM-based routine.
     67  08f0
     68  08f0
     69  08f0
     70  08f0							;------------------------------------------------------------------------------
     71  08f0
     72  08f0
     73  08f0		       60	   waitForDraw rts		; 6
     74  08f1
     75  08f1							;------------------------------------------------------------------------------
     76  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     78  08f1
     79  08f1							; Parse the DrawFlags buffer and create a draw stack
     80  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     81  08f1
     82  08f1
     83  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     84  08f1							; symptoms would be missing parts of screen when scrolling.
     85  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     86  08f1							; disabled for sokoban 27/7/2019
     87  08f1
     88  08f1		       a5 84		      lda	DrawStackPointer
     89  08f3							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     90  08f3
     91  08f3		       ad 84 02 	      lda	INTIM	;4
     92  08f6		       c9 05		      cmp	#SEGTIME_BDS	;2
     93  08f8		       90 f6		      bcc	waitForDraw	;2/3
      0  08fa					      STRESS_TIME	SEGTIME_BDS
      1  08fa				  -	      IF	TEST_SEGTIME_BDS = 1
      2  08fa				  -
      3  08fa				  -
      4  08fa				  -
      5  08fa				  -
      6  08fa				  -
      7  08fa				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  08fa				  -	      bne	. - 7
      9  08fa					      ENDIF
     95  08fa
     96  08fa
     97  08fa							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     98  08fa							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     99  08fa
    100  08fa							;		  sec		 already set
    101  08fa		       a5 9c		      lda	ManY	;3
    102  08fc		       e5 96		      sbc	BoardScrollY	;3
    103  08fe		       85 9e		      sta	ManDrawY	;3
    104  0900
    105  0900		       38		      sec		;2
    106  0901		       a5 9b		      lda	ManX	;3
    107  0903		       e5 97		      sbc	BoardScrollX	;3
    108  0905		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    109  0907		       90 06		      bcc	onsc	;2/3
    110  0909
    111  0909							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    112  0909							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    113  0909							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    114  0909
    115  0909		       a9 08		      lda	#SCREEN_LINES	;2
    116  090b		       85 9e		      sta	ManDrawY	;3
    117  090d		       d0 02		      bne	skipsc	;3		  unconditional
    118  090f
    119  090f		       85 9d	   onsc       sta	ManDrawX	;3
    120  0911				   skipsc
    121  0911
    122  0911		       e6 b1		      inc	timer	;5
    123  0913		       4c 9d fc 	      jmp	AnimateCharReplacements2	;3+139
    124  0916				   retAnim
    125  0916
    126  0916		       e6 89		      inc	ScreenDrawPhase	;5
    127  0918
    128  0918		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    129  091a		       85 cc		      sta	DSL	;3
    130  091c
    131  091c							; fall through...
    132  091c							;---------------------------------------------------------------------------
    133  091c
      0  091c					      DEFINE_SUBROUTINE	DrawIntoStack
      1  091c		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  091c					      SUBROUTINE
      3  091c				   DrawIntoStack
    135  091c
    136  091c		       ba		      tsx		;2
    137  091d		       86 d8		      stx	save_SP	;3
    138  091f		       a6 84		      ldx	DrawStackPointer	;3
    139  0921		       9a		      txs		;2 = 10
    140  0922
    141  0922		       a4 cc		      ldy	DSL	;3
    142  0924
    143  0924							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    144  0924							; + exit cost which is +10 cycles
    145  0924							; TJ: I count 63
    146  0924							;   + 14 for the wtf2 exit
    147  0924							;   + 22 for the end of loop exit
    148  0924
    149  0924							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    150  0924							; For 80 iterations that is 640 cycles, just for checking INTIM
    151  0924							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    152  0924							; it also will require a lot of CPU time for updating the screen data.
    153  0924
    154  0924							; TODO: optimize!
    155  0924							;
    156  0924							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    157  0924							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    158  0924							; costs some detection time here, but saves ~240 cylces for drawing the two
    159  0924
    160  0924		       ad 84 02    .loopDrawStack lda	INTIM	;4
    161  0927		       c9 05		      cmp	#SEGTIME_DSL	;2
    162  0929		       90 4d		      bcc	.exitDrawStack	;2/3= 8/9
      0  092b					      STRESS_TIME	SEGTIME_DSL
      1  092b				  -	      IF	TEST_SEGTIME_DSL = 1
      2  092b				  -
      3  092b				  -
      4  092b				  -
      5  092b				  -
      6  092b				  -
      7  092b				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  092b				  -	      bne	. - 7
      9  092b					      ENDIF
    164  092b
    165  092b		       b9 50 f0 	      lda	DrawFlag,y	;4
    166  092e		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    167  0931		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    168  0933
    169  0933							; Character is NOT the same. Figure out how it should be drawn.
    170  0933							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    171  0933							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    172  0933							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    173  0933
    174  0933		       be 81 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    175  0936		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    176  0939		       d0 05		      bne	.notPaired0	;2/3=10/11
    177  093b
    178  093b							; Consider two 'paired' characters. Either A:A or A:B
    179  093b							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    180  093b							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    181  093b							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    182  093b							; on the comparison, so the character will not be added to the draw stack. So our first character will
    183  093b							; do the job of drawing BOTH characters to the screen.
    184  093b
    185  093b		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    186  093e		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    187  0940
    188  0940							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    189  0940							; the last write(below) marks the character as to be direct-drawn.
    190  0940
    191  0940		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    192  0943
    193  0943							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    194  0943
    195  0943		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    196  0944		       98		      tya		;2
    197  0945		       ba		      tsx		;2		 << now X holds drawstackpointer
    198  0946		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    199  0949
    200  0949		       88	   .next0     dey		;2
    201  094a		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    202  094c
    203  094c							; unrolled 2nd loop:
    204  094c		       b9 50 f0 	      lda	DrawFlag,y	;4
    205  094f		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    206  0952		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    207  0954
    208  0954		       be 81 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    209  0957		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    210  095a		       d0 05		      bne	.notPaired1	;2/3=10/11
    211  095c
    212  095c		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    213  095f		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    214  0961
    215  0961		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    216  0964
    217  0964		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    218  0965		       98		      tya		;2
    219  0966		       ba		      tsx		;2
    220  0967		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    221  096a
    222  096a		       88	   .next1     dey		;2
    223  096b		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    224  096d							;worst case: 111-4
    225  096d							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    226  096d
    227  096d							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    228  096d
    229  096d				   .finishedDrawStack
    230  096d		       e6 89		      inc	ScreenDrawPhase	;5 =  5
    231  096f		       ba		      tsx		;2
    232  0970		       86 84		      stx	DrawStackPointer	;3
    233  0972		       a6 d8		      ldx	save_SP	;3
    234  0974		       9a		      txs		;2 = 10
    235  0975
    236  0975		       4c 96 f8 	      jmp	SwitchObjects
    237  0978
    238  0978							;rts				  ;6 =	6
    239  0978
    240  0978				   .exitDrawStack
    241  0978		       84 cc		      sty	DSL	;3 =  3
    242  097a		       ba		      tsx		;2
    243  097b		       86 84		      stx	DrawStackPointer	;3
    244  097d		       a6 d8		      ldx	save_SP	;3
    245  097f		       9a		      txs		;2 = 10
    246  0980		       60		      rts		;6 =  6
    247  0981
    248  0981				   PairedCharacter
    249  0981
    250  0981				   SOFF       SET	0
    251  0981					      REPEAT	SCREEN_LINES
    252  0981		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  0981				   SOFF       SET	SOFF + SCREEN_WIDTH
    251  0981					      REPEND
    252  098b		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  098b				   SOFF       SET	SOFF + SCREEN_WIDTH
    251  098b					      REPEND
    252  0995		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  0995				   SOFF       SET	SOFF + SCREEN_WIDTH
    251  0995					      REPEND
    252  099f		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  099f				   SOFF       SET	SOFF + SCREEN_WIDTH
    251  099f					      REPEND
    252  09a9		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  09a9				   SOFF       SET	SOFF + SCREEN_WIDTH
    251  09a9					      REPEND
    252  09b3		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  09b3				   SOFF       SET	SOFF + SCREEN_WIDTH
    251  09b3					      REPEND
    252  09bd		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  09bd				   SOFF       SET	SOFF + SCREEN_WIDTH
    251  09bd					      REPEND
    252  09c7		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    253  09c7				   SOFF       SET	SOFF + SCREEN_WIDTH
    254  09d1					      REPEND
    255  09d1
    256  09d1							;------------------------------------------------------------------------------
    257  09d1							; Gives character replacements used during screen drawing.
    258  09d1							; The character from the board is morphed via this array into an actual character
    259  09d1							; to draw.  This allows global animation and replacment of characters without
    260  09d1							; individual objects needing to do this.  Note, the draw-time replacement happens,
    261  09d1							; not board-time.
    262  09d1
    263  09d1				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    264  09d1
    265  09d1							; Converts a character # to an animated creature type
    266  09d1							; The array is indexed by CHARACTER_...
    267  09d1
    268  09d1		       00		      .byte.b	CHARACTER_BLANK	;  0
    269  09d2		       01		      .byte.b	CHARACTER_SOIL	;  1
    270  09d3		       02		      .byte.b	CHARACTER_BOX	;  2
    271  09d4		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    272  09d5		       04		      .byte.b	CHARACTER_TARGET2	;  4
    273  09d6		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    274  09d7		       06		      .byte.b	CHARACTER_STEEL	;  6
    275  09d8		       07		      .byte.b	CHARACTER_WALL	;  7
    276  09d9		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    277  09da		       00		      .byte.b	CHARACTER_BLANK	;  9
    278  09db
    279  09db				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    280  09db				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    281  09db				  -	      ERR
    282  09db					      ENDIF
      0  09db					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09db					      LIST	ON
    284  09db
    285  09db							;------------------------------------------------------------------------------
    286  09db
    287  09db
      0  09db					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $25
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    290  0a00
    291  0a00				   .BANK      SET	BANK_SCREENMARKII1
    292  0a00					      REPEAT	SCREEN_LINES
    293  0a00					      REPEAT	SCREEN_WIDTH
    294  0a00		       00		      .byte.b	.BANK
    293  0a00					      REPEND
    294  0a01		       00		      .byte.b	.BANK
    293  0a01					      REPEND
    294  0a02		       00		      .byte.b	.BANK
    293  0a02					      REPEND
    294  0a03		       00		      .byte.b	.BANK
    293  0a03					      REPEND
    294  0a04		       00		      .byte.b	.BANK
    293  0a04					      REPEND
    294  0a05		       00		      .byte.b	.BANK
    293  0a05					      REPEND
    294  0a06		       00		      .byte.b	.BANK
    293  0a06					      REPEND
    294  0a07		       00		      .byte.b	.BANK
    293  0a07					      REPEND
    294  0a08		       00		      .byte.b	.BANK
    293  0a08					      REPEND
    294  0a09		       00		      .byte.b	.BANK
    295  0a0a					      REPEND
    296  0a0a				   .BANK      SET	.BANK + 1
    292  0a0a					      REPEND
    293  0a0a					      REPEAT	SCREEN_WIDTH
    294  0a0a		       01		      .byte.b	.BANK
    293  0a0a					      REPEND
    294  0a0b		       01		      .byte.b	.BANK
    293  0a0b					      REPEND
    294  0a0c		       01		      .byte.b	.BANK
    293  0a0c					      REPEND
    294  0a0d		       01		      .byte.b	.BANK
    293  0a0d					      REPEND
    294  0a0e		       01		      .byte.b	.BANK
    293  0a0e					      REPEND
    294  0a0f		       01		      .byte.b	.BANK
    293  0a0f					      REPEND
    294  0a10		       01		      .byte.b	.BANK
    293  0a10					      REPEND
    294  0a11		       01		      .byte.b	.BANK
    293  0a11					      REPEND
    294  0a12		       01		      .byte.b	.BANK
    293  0a12					      REPEND
    294  0a13		       01		      .byte.b	.BANK
    295  0a14					      REPEND
    296  0a14				   .BANK      SET	.BANK + 1
    292  0a14					      REPEND
    293  0a14					      REPEAT	SCREEN_WIDTH
    294  0a14		       02		      .byte.b	.BANK
    293  0a14					      REPEND
    294  0a15		       02		      .byte.b	.BANK
    293  0a15					      REPEND
    294  0a16		       02		      .byte.b	.BANK
    293  0a16					      REPEND
    294  0a17		       02		      .byte.b	.BANK
    293  0a17					      REPEND
    294  0a18		       02		      .byte.b	.BANK
    293  0a18					      REPEND
    294  0a19		       02		      .byte.b	.BANK
    293  0a19					      REPEND
    294  0a1a		       02		      .byte.b	.BANK
    293  0a1a					      REPEND
    294  0a1b		       02		      .byte.b	.BANK
    293  0a1b					      REPEND
    294  0a1c		       02		      .byte.b	.BANK
    293  0a1c					      REPEND
    294  0a1d		       02		      .byte.b	.BANK
    295  0a1e					      REPEND
    296  0a1e				   .BANK      SET	.BANK + 1
    292  0a1e					      REPEND
    293  0a1e					      REPEAT	SCREEN_WIDTH
    294  0a1e		       03		      .byte.b	.BANK
    293  0a1e					      REPEND
    294  0a1f		       03		      .byte.b	.BANK
    293  0a1f					      REPEND
    294  0a20		       03		      .byte.b	.BANK
    293  0a20					      REPEND
    294  0a21		       03		      .byte.b	.BANK
    293  0a21					      REPEND
    294  0a22		       03		      .byte.b	.BANK
    293  0a22					      REPEND
    294  0a23		       03		      .byte.b	.BANK
    293  0a23					      REPEND
    294  0a24		       03		      .byte.b	.BANK
    293  0a24					      REPEND
    294  0a25		       03		      .byte.b	.BANK
    293  0a25					      REPEND
    294  0a26		       03		      .byte.b	.BANK
    293  0a26					      REPEND
    294  0a27		       03		      .byte.b	.BANK
    295  0a28					      REPEND
    296  0a28				   .BANK      SET	.BANK + 1
    292  0a28					      REPEND
    293  0a28					      REPEAT	SCREEN_WIDTH
    294  0a28		       04		      .byte.b	.BANK
    293  0a28					      REPEND
    294  0a29		       04		      .byte.b	.BANK
    293  0a29					      REPEND
    294  0a2a		       04		      .byte.b	.BANK
    293  0a2a					      REPEND
    294  0a2b		       04		      .byte.b	.BANK
    293  0a2b					      REPEND
    294  0a2c		       04		      .byte.b	.BANK
    293  0a2c					      REPEND
    294  0a2d		       04		      .byte.b	.BANK
    293  0a2d					      REPEND
    294  0a2e		       04		      .byte.b	.BANK
    293  0a2e					      REPEND
    294  0a2f		       04		      .byte.b	.BANK
    293  0a2f					      REPEND
    294  0a30		       04		      .byte.b	.BANK
    293  0a30					      REPEND
    294  0a31		       04		      .byte.b	.BANK
    295  0a32					      REPEND
    296  0a32				   .BANK      SET	.BANK + 1
    292  0a32					      REPEND
    293  0a32					      REPEAT	SCREEN_WIDTH
    294  0a32		       05		      .byte.b	.BANK
    293  0a32					      REPEND
    294  0a33		       05		      .byte.b	.BANK
    293  0a33					      REPEND
    294  0a34		       05		      .byte.b	.BANK
    293  0a34					      REPEND
    294  0a35		       05		      .byte.b	.BANK
    293  0a35					      REPEND
    294  0a36		       05		      .byte.b	.BANK
    293  0a36					      REPEND
    294  0a37		       05		      .byte.b	.BANK
    293  0a37					      REPEND
    294  0a38		       05		      .byte.b	.BANK
    293  0a38					      REPEND
    294  0a39		       05		      .byte.b	.BANK
    293  0a39					      REPEND
    294  0a3a		       05		      .byte.b	.BANK
    293  0a3a					      REPEND
    294  0a3b		       05		      .byte.b	.BANK
    295  0a3c					      REPEND
    296  0a3c				   .BANK      SET	.BANK + 1
    292  0a3c					      REPEND
    293  0a3c					      REPEAT	SCREEN_WIDTH
    294  0a3c		       06		      .byte.b	.BANK
    293  0a3c					      REPEND
    294  0a3d		       06		      .byte.b	.BANK
    293  0a3d					      REPEND
    294  0a3e		       06		      .byte.b	.BANK
    293  0a3e					      REPEND
    294  0a3f		       06		      .byte.b	.BANK
    293  0a3f					      REPEND
    294  0a40		       06		      .byte.b	.BANK
    293  0a40					      REPEND
    294  0a41		       06		      .byte.b	.BANK
    293  0a41					      REPEND
    294  0a42		       06		      .byte.b	.BANK
    293  0a42					      REPEND
    294  0a43		       06		      .byte.b	.BANK
    293  0a43					      REPEND
    294  0a44		       06		      .byte.b	.BANK
    293  0a44					      REPEND
    294  0a45		       06		      .byte.b	.BANK
    295  0a46					      REPEND
    296  0a46				   .BANK      SET	.BANK + 1
    292  0a46					      REPEND
    293  0a46					      REPEAT	SCREEN_WIDTH
    294  0a46		       07		      .byte.b	.BANK
    293  0a46					      REPEND
    294  0a47		       07		      .byte.b	.BANK
    293  0a47					      REPEND
    294  0a48		       07		      .byte.b	.BANK
    293  0a48					      REPEND
    294  0a49		       07		      .byte.b	.BANK
    293  0a49					      REPEND
    294  0a4a		       07		      .byte.b	.BANK
    293  0a4a					      REPEND
    294  0a4b		       07		      .byte.b	.BANK
    293  0a4b					      REPEND
    294  0a4c		       07		      .byte.b	.BANK
    293  0a4c					      REPEND
    294  0a4d		       07		      .byte.b	.BANK
    293  0a4d					      REPEND
    294  0a4e		       07		      .byte.b	.BANK
    293  0a4e					      REPEND
    294  0a4f		       07		      .byte.b	.BANK
    295  0a50					      REPEND
    296  0a50				   .BANK      SET	.BANK + 1
    297  0a50					      REPEND
    298  0a50
    299  0a50
    300  0a50
    301  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    303  0a50
    304  0a50
    305  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  13bc ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       50 5e 6c 57*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       1f 26 2d 34	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       83 83 83 83	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       83 83 83 83	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       83 83 83 83	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       83 83 83 83	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084							; level "name" characters (left only!):
    217  1084
    218  1084				   CharN
    219  1084				   CharK
    220  1084				   CharH
    221  1084				   CharA
    222  1084				   CharJ
    223  1084				   CharP
    224  1084				   CharB
    225  1084				   CharO
    226  1084				   CharC
    227  1084				   CharI
    228  1084				   CharD
    229  1084				   CharG
    230  1084				   CharE
    231  1084				   CharL
    232  1084				   CharF
    233  1084				   CharM
    234  1084		       00 00 00 00*	      ds	7,0
    235  108b
    236  108b				   charPlace
    237  108b		       0c		      .byte.b	%00001100
    238  108c		       0c		      .byte.b	%00001100
    239  108d		       0c		      .byte.b	%00001100
    240  108e		       0c		      .byte.b	%00001100
    241  108f		       0c		      .byte.b	%00001100
    242  1090		       00		      .byte.b	%00000000
    243  1091		       0c		      .byte.b	%00001100
    244  1092
    245  1092							;-------------------------------------------------------------------------------------
    246  1092				   PosTbl
    247  1092		       40		      .byte.b	$40
    248  1093		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    249  109b		       b9		      .byte.b	$b9
    250  109c
    251  109c
    252  109c							;------------------------------------------------------------------------------
    253  109c							; RAM-BASED SUBROUTINES...
    254  109c							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    255  109c							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    256  109c							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    257  109c							; the RAM-based routine.
    258  109c
    259  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    260  1100
    261  1100		       f1 00	   SM_BASE    =	.
    262  1100
    263  1100							;#IF 0 ;{
    264  1100							;    DEFINE_SUBROUTINE Score3x3
    265  1100							;
    266  1100							;	  sta	  RESP0
    267  1100							;	   sta	   RESP1
    268  1100							;	   lda	   #$$000
    269  1100							;	    sta     GRP0
    270  1100							;	    lda     #$$009
    271  1100							;	    sta     GRP1
    272  1100							;	    lda     #$$202
    273  1100							;	    sta     ENABL
    274  1100							;	    nop
    275  1100							;	    nop
    276  1100							;	    nop
    277  1100							;	    lda     #$$016
    278  1100							;	    ldy     #$$100
    279  1100							;	    ldx     #$$109
    280  1100							;	    sta     GRP0    ; Critical time is right here
    281  1100							;	    stx     GRP1
    282  1100							;	    sty     GRP0
    283  1100							;	    sta     RESP0
    284  1100							;	    sta     RESP1
    285  1100							;	    ldx     #$$116
    286  1100							;	    lda     #$$209
    287  1100							;	    stx     GRP0
    288  1100							;	    sta     GRP1
    289  1100							;	    lda     #$$200
    290  1100							;	    sta     GRP0
    291  1100							;	    sta     RESP0
    292  1100							;	    sta     RESP1
    293  1100							;	    lda     #$$216
    294  1100							;	    nop
    295  1100							;	    sta     GRP0
    296  1100							;
    297  1100							;	      rts
    298  1100							;#ENDIF ;}
    299  1100
    300  1100
    301  1100							;------------------------------------------------------------------------------
    302  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    304  1100							;					     @07
    305  1100		       ba		      tsx		; 2
    306  1101
    307  1101		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    308  1104
    309  1104		       86 d8		      stx	tmpStack	; 3 =	3
    310  1106
    311  1106				   LoopDraw1x6		;
    312  1106				   SMDIGIT0
    313  1106		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    314  1109		       85 42		      sta	WSYNC	; 3
    315  110b							;---------------------------------------------------------------
    316  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    318  110f		       85 5b		      sta	GRP0	; 3
    319  1111				   SMDIGIT1
    320  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    321  1114		       85 5c		      sta	GRP1	; 3
    322  1116				   SMDIGIT2
    323  1116		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    324  1119		       85 5b		      sta	GRP0	; 3 = 17
    325  111b				   SMDIGIT5
    326  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    327  111e		       9a		      txs		; 2
    328  111f				   SMDIGIT3
    329  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    330  1122				   SMDIGIT4
    331  1122		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    332  1125		       85 6b		      sta	HMCLR	; 3
    333  1127		       86 5c		      stx	GRP1	; 3
    334  1129		       85 5b		      sta	GRP0	; 3 = 23
    335  112b
    336  112b		       ba		      tsx		; 2
    337  112c		       86 5c		      stx	GRP1	; 3
    338  112e		       85 5b		      sta	GRP0	; 3 =	8
    339  1130
    340  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    342  1133
    343  1133		       a6 d8		      ldx	tmpStack	; 3
    344  1135		       9a		      txs		; 2
    345  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    347  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    348  113b
    349  113b
    350  113b							;------------------------------------------------------------------------------
    351  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    353  113b
    354  113b
    355  113b							; Subroutine by Thomas Jentzsch.  Magic!
    356  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    357  113b
    358  113b							;sta COLUBK
    359  113b
    360  113b		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    361  113e
    362  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    364  1142
    365  1142				   LoopDraw2x4		;	     @70
    366  1142				   SM_TARGET3
    367  1142		       b9 26 f3 	      lda	DequalsR-1,y	; 4		     G
    368  1145							;---------------------------------------------------------------
    369  1145		       85 5b		      sta	GRP0	; 3
    370  1147				   SM_TARGET2
    371  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    372  114a		       85 5c		      sta	GRP1	; 3
    373  114c				   SM_TARGET1
    374  114c		       b9 50 f3 	      lda	ZeroR-1,y	; 4		     M
    375  114f		       85 5b		      sta	GRP0	; 3
    376  1151				   SM_TARGET0
    377  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    378  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    379  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    380  1158				   SM_Time3
    381  1158		       b9 34 f3 	      lda	ClockR-1,y	; 4		     O
    382  115b		       86 5c		      stx	GRP1	; 3
    383  115d		       85 5b		      sta	GRP0	; 3
    384  115f				   SM_Time2
    385  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    386  1162		       85 5c		      sta	GRP1	; 3
    387  1164				   SM_Time1
    388  1164		       b9 50 f3 	      lda	ZeroR-1,y	; 4		     E
    389  1167		       85 5b		      sta	GRP0	; 3
    390  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    391  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    392  116d				   SM_Time0
    393  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    394  1170		       85 5c		      sta	GRP1	; 3
    395  1172		       85 5b		      sta	GRP0	; 3
    396  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    398  1177
    399  1177				   ExitDigitKernel		;	     @69
    400  1177		       84 5b		      sty	GRP0	; 3
    401  1179		       84 5c		      sty	GRP1	; 3
    402  117b							;---------------------------------------------------------------
    403  117b		       84 5b		      sty	GRP0	; 3	     @02
    404  117d
    405  117d							; Contribution by Thomas Jentzsch
    406  117d							; Rewrite/Optimised for single sprite AD
    407  117d
    408  117d		       a6 9d		      ldx	ManDrawX	; 3
    409  117f		       bd 92 f0 	      lda	PosTbl,x	; 4
    410  1182		       85 60		      sta	HMP0	; 3
    411  1184		       29 0f		      and	#$0f	; 2
    412  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    413  1188		       aa		      tax		; 2
    414  1189				   .loopWait
    415  1189		       ca		      dex		; 2
    416  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    417  118c				   .zeroPos
    418  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    419  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    420  1190		       a5 b2		      lda	BGColour	; 3
    421  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    422  1194		       85 42		      sta	WSYNC	; 3
    423  1196							;---------------------------------------------------------------
    424  1196		       85 6a		      sta	HMOVE	; 3
    425  1198		       60		      rts		; 6	     @09
    426  1199
    427  1199							;------------------------------------------------------------------------------
    428  1199				   Score3x2Fix SUBROUTINE
      0  1199					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  1199		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  1199					      SUBROUTINE
      3  1199				   DrawDigits3x2
    430  1199							;					     @07
    431  1199		       a9 16		      lda	#%010110	; 2
    432  119b		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    433  119d		       20 f4 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    434  11a0
    435  11a0		       a9 00		      lda	#0
    436  11a2		       85 66		      sta	VDELP1
    437  11a4				   LoopDraw3x2		;
    438  11a4		       85 42		      sta	WSYNC	; 3
    439  11a6							;---------------------------------------------------------------
    440  11a6		       85 6a		      sta	HMOVE	; 3 =	3
    441  11a8		       b9 83 f0 	      lda	CharP-1,y	; 4
    442  11ab		       85 5b		      sta	GRP0	; 3
    443  11ad				   SMPLAYER
    444  11ad		       b9 5e f3 	      lda	OneR-1,y	; 4
    445  11b0		       85 5c		      sta	GRP1	; 3 = 14    @17
    446  11b2		       b9 8a f0 	      lda	charPlace-1,y	; 4
    447  11b5				   SMMEN
    448  11b5		       be 57 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11b8					      SLEEP	5	;   =	5
      1  11b8				   .CYCLES    SET	5
      2  11b8
      3  11b8				  -	      IF	.CYCLES < 2
      4  11b8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11b8				  -	      ERR
      6  11b8					      ENDIF
      7  11b8
      8  11b8					      IF	.CYCLES & 1
      9  11b8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11b8		       04 00		      nop	0
     11  11ba				  -	      ELSE
     12  11ba				  -	      bit	VSYNC
     13  11ba					      ENDIF
     14  11ba				   .CYCLES    SET	.CYCLES - 3
     15  11ba					      ENDIF
     16  11ba
     17  11ba					      REPEAT	.CYCLES / 2
     18  11ba		       ea		      nop
     19  11bb					      REPEND
    450  11bb		       85 5b		      sta	GRP0	; 3
    451  11bd				   SMLEVELX
    452  11bd		       b9 83 f0 	      lda	CharA-1,y	; 4
    453  11c0		       85 6b		      sta	HMCLR	; 3 = 10    @40
    454  11c2		       86 5c		      stx	GRP1	; 3 =	3    @43
    455  11c4		       85 5b		      sta	GRP0	; 3
    456  11c6				   SMLEVEL
    457  11c6		       b9 5e f3 	      lda	OneR-1,y	; 4
    458  11c9		       85 5c		      sta	GRP1	; 3 = 10    @53
    459  11cb
    460  11cb		       88		      dey		; 2
      0  11cc					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11cc					      LIST	ON
      9  11cc		       d0 d6		      bne	LoopDraw3x2
    462  11ce							;					     @57
      0  11ce					      SLEEP	3	; 3
      1  11ce				   .CYCLES    SET	3
      2  11ce
      3  11ce				  -	      IF	.CYCLES < 2
      4  11ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11ce				  -	      ERR
      6  11ce					      ENDIF
      7  11ce
      8  11ce					      IF	.CYCLES & 1
      9  11ce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11ce		       04 00		      nop	0
     11  11d0				  -	      ELSE
     12  11d0				  -	      bit	VSYNC
     13  11d0					      ENDIF
     14  11d0				   .CYCLES    SET	.CYCLES - 3
     15  11d0					      ENDIF
     16  11d0
     17  11d0				  -	      REPEAT	.CYCLES / 2
     18  11d0				  -	      nop
     19  11d0					      REPEND
    464  11d0		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    465  11d3
    466  11d3
    467  11d3							;------------------------------------------------------------------------------
      0  11d3					      DEFINE_SUBROUTINE	DrawDigits
      1  11d3		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d3					      SUBROUTINE
      3  11d3				   DrawDigits
    469  11d3
    470  11d3				   VblankLoopGame
    471  11d3		       ac 84 02 	      ldy	INTIM
    472  11d6		       d0 fb		      bne	VblankLoopGame
    473  11d8
    474  11d8		       84 41		      sty	VBLANK	; 3	     <-- 0
    475  11da		       a5 c7		      lda	scoringFlags	; 3
    476  11dc		       29 03		      and	#DISPLAY_FLAGS	; 2
    477  11de		       aa		      tax		; 2
    478  11df
    479  11df							;    DEFINE_SUBROUTINE DrawDigit2
    480  11df							;
    481  11df							;    ; Generic interface to scoring routine
    482  11df
    483  11df		       bd ea f1 	      lda	ScoreKernelLo,x	; 4
    484  11e2
    485  11e2		       85 42		      sta	WSYNC	; 3
    486  11e4							;---------------------------------------------------------------
    487  11e4		       8d e8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    488  11e7				   SMJUMP
    489  11e7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    490  11ea
    491  11ea				   ScoreKernelLo
    492  11ea		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    493  11eb		       00		      .byte.b	<Score1x6Fix	; score
    494  11ec		       99		      .byte.b	<Score3x2Fix	; player, lives, level
    495  11ed		       00		      .byte.b	<Score1x6Fix	; high score
    496  11ee
      0  11ee					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11ee					      LIST	ON
    498  11ee
    499  11ee							;------------------------------------------------------------------------------
      0  11ee					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11ee		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11ee					      SUBROUTINE
      3  11ee				   PrepareDrawDigits
    501  11ee							;					     @13
    502  11ee		       a0 d1		      ldy	#$d1	; 2
    503  11f0		       a9 13		      lda	#%010011	; 2
    504  11f2		       85 66		      sta	VDELP1	; 3 =	7
    505  11f4				   PrepareDrawDigits2		;	    @17/20
    506  11f4		       84 65		      sty	VDELP0	; 3 =	3
    507  11f6
    508  11f6		       85 45		      sta	NUSIZ1	; 3
    509  11f8		       85 44		      sta	NUSIZ0	; 3 =	6
    510  11fa
    511  11fa		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    512  11fd		       85 50		      sta	RESP0	; 3	     @33/36
    513  11ff		       85 51		      sta	RESP1	; 3 = 10    @36/39
    514  1201
    515  1201		       84 60		      sty	HMP0	; 3
    516  1203		       c8		      iny		; 2
    517  1204		       84 61		      sty	HMP1	; 3 =	8
    518  1206				   SMCOLOR
    519  1206		       a0 9a		      ldy	#SCORE_COL	; 2
    520  1208		       84 46		      sty	COLUP0	; 3
    521  120a		       84 47		      sty	COLUP1	; 3 =	8
    522  120c
    523  120c		       a0 07		      ldy	#DIGIT_H	; 2
    524  120e		       60		      rts		; 6 =	8
    525  120f							; total: 27
    526  120f
    527  120f
    528  120f							;------------------------------------------------------------------------------
      0  120f					      DEFINE_SUBROUTINE	UpdateScore
      1  120f		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  120f					      SUBROUTINE
      3  120f				   UpdateScore
    530  120f							; a = added score value
    531  120f
    532  120f							; initially switch to score:
    533  120f		       a0 01		      ldy	#DISPLAY_SCORE
    534  1211		       84 d8		      sty	newDisplay
    535  1213
    536  1213		       18		      clc
    537  1214		       f8		      sed
    538  1215		       a0 04		      ldy	#SM_OFS_SCORE
    539  1217				   .loopScore
    540  1217		       79 a9 f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    541  121a		       99 a9 f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    542  121d		       08		      php
    543  121e							; *** bonus life every 500 points: ***
    544  121e							;	  cpy #SM_OFS_SCORE+1
    545  121e							;	  bne .skipBonusLife
    546  121e							;	  tax
    547  121e
    548  121e							;	  and #$0f
    549  121e							;	  beq .bonusLife		      ; 000?
    550  121e							;	  cmp #$05
    551  121e							;	  bne .noBonusLife		      ; 500?
    552  121e							;.bonusLife:
    553  121e							; add extra life, limited to 9
    554  121e
    555  121e							;	  lda ManCount
    556  121e							;	  and #$0f
    557  121e							;	  cmp #9
    558  121e							;	  bcs .noBonusLife
    559  121e							;	  inc ManCount
    560  121e
    561  121e							; bonus life has priority over score:
    562  121e							;	  lda #DISPLAY_LIVES
    563  121e							;	  sta newDisplay
    564  121e							;lda #EXTRA_LIFE_TIMER
    565  121e							;sta extraLifeTimer
    566  121e
    567  121e				   .noBonusLife
    568  121e		       8a		      txa
    569  121f				   .skipBonusLife
    570  121f		       20 00 f3 	      jsr	SetupBCDPtr
    571  1222		       28		      plp
    572  1223		       a9 00		      lda	#0
    573  1225		       b0 f0		      bcs	.loopScore
    574  1227		       d8		      cld
    575  1228
    576  1228							; switch display
    577  1228		       a5 c7		      lda	scoringFlags
    578  122a		       29 03		      and	#DISPLAY_FLAGS
    579  122c		       c5 d8		      cmp	newDisplay	; lower priority than current?
    580  122e		       f0 08		      beq	.restartTime
    581  1230		       b0 0a		      bcs	.skipNew
    582  1232		       45 c7		      eor	scoringFlags	; remove existing score mode
    583  1234		       05 d8		      ora	newDisplay	; switch to new score mode
    584  1236		       85 c7		      sta	scoringFlags
    585  1238				   .restartTime
    586  1238		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    587  123a		       85 c6		      sta	scoringTimer
    588  123c				   .skipNew
    589  123c
    590  123c		       60		      rts
    591  123d
    592  123d							;---------------------------------------------------------------------------
    593  123d
      0  123d					      DEFINE_SUBROUTINE	SwapPlayers
      1  123d		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  123d					      SUBROUTINE
      3  123d				   SwapPlayers
    595  123d
    596  123d							; assume no new high score:
    597  123d		       a0 ff		      ldy	#-1
    598  123f		       84 db		      sty	highScoreSK
    599  1241
    600  1241							; update highscore after last live:
    601  1241		       a5 a7		      lda	ManCount
    602  1243		       29 0f		      and	#$0f	; player has lives left?
    603  1245		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    604  1247
    605  1247							; check for a new high score:
    606  1247							;	  ldy #-1
    607  1247		       18		      clc		; score has to be at least 1 bigger!
    608  1248				   .loopCheckHighScore
    609  1248		       c8		      iny
    610  1249		       b9 ad f3 	      lda	ScoreCurrent,y
    611  124c		       f9 b7 f3 	      sbc	HighScore,y
    612  124f		       98		      tya
    613  1250		       49 02		      eor	#2
    614  1252		       d0 f4		      bne	.loopCheckHighScore
    615  1254		       90 0d		      bcc	.noHighScore
    616  1256
    617  1256							; new high score, update:
    618  1256		       a2 04		      ldx	#5-1
    619  1258				   .loopSetHighScore
    620  1258		       bd ad f3 	      lda	ScoreCurrent,x
    621  125b		       9d b7 f7 	      sta	HighScore+RAM_WRITE,x
    622  125e		       95 db		      sta	highScoreSK,x
    623  1260		       ca		      dex
    624  1261		       10 f5		      bpl	.loopSetHighScore
    625  1263				   .noHighScore
    626  1263
    627  1263				   .playerAlive
    628  1263		       a5 a7		      lda	ManCount
    629  1265		       29 f0		      and	#$f0	; other player has lives left?
    630  1267		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    631  1269
    632  1269							; save the current player variables to the player's backup:
    633  1269		       a0 02		      ldy	#3-1
    634  126b				   .swapScore
    635  126b		       be b2 f3 	      ldx	PlayerScores,y
    636  126e		       b9 ad f3 	      lda	ScoreCurrent,y
    637  1271		       99 b2 f7 	      sta	PlayerScores+RAM_WRITE,y
    638  1274		       8a		      txa
    639  1275		       99 ad f7 	      sta	ScoreCurrent+RAM_WRITE,y
    640  1278		       88		      dey
    641  1279		       10 f0		      bpl	.swapScore
    642  127b
    643  127b							; swap levelx and level:
    644  127b		       a2 01		      ldx	#1
    645  127d				   .loopLevelXLevel
    646  127d		       bc b5 f3 	      ldy	PlayerLevelX,x
    647  1280		       b5 b3		      lda	levelX,x
    648  1282		       9d b5 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    649  1285		       94 b3		      sty	levelX,x
    650  1287		       ca		      dex
    651  1288		       10 f3		      bpl	.loopLevelXLevel
    652  128a
    653  128a				   .otherPlayerDead
    654  128a		       60		      rts
    655  128b
    656  128b							;---------------------------------------------------------------------------
    657  128b
    658  128b				   HighScoreColTbl
    659  128b		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    660  128d		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    661  128f
      0  128f					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  128f		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  128f					      SUBROUTINE
      3  128f				   GeneralScoringSetups
    663  128f
    664  128f		       a0 04		      ldy	#SM_OFS_SCORE
    665  1291				   .loopScore2
    666  1291		       a5 c7		      lda	scoringFlags
    667  1293		       29 03		      and	#DISPLAY_FLAGS
    668  1295		       c9 03		      cmp	#DISPLAY_HIGH
    669  1297		       a6 81		      ldx	Platform
    670  1299		       bd 8b f2 	      lda	HighScoreColTbl,x
    671  129c		       aa		      tax
    672  129d		       b9 b3 f3 	      lda	HighScore-SM_OFS_SCORE,y
    673  12a0		       b0 05		      bcs	.showHighScore
    674  12a2		       a2 9a		      ldx	#SCORE_COL
    675  12a4		       b9 a9 f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    676  12a7				   .showHighScore
    677  12a7		       8e 07 f6 	      stx	SMCOLOR+1+RAM_WRITE
    678  12aa		       20 00 f3 	      jsr	SetupBCDPtr
    679  12ad		       c0 07		      cpy	#SM_OFS_SCORE+3
    680  12af		       90 e0		      bcc	.loopScore2
    681  12b1
    682  12b1							; display number of lives in leftmost digit of middle score XX nX XX
    683  12b1
    684  12b1		       a5 a7		      lda	ManCount
    685  12b3		       29 0f		      and	#$0f
    686  12b5		       a8		      tay
    687  12b6		       b9 00 f0 	      lda	DigitVectorLOr,y
    688  12b9		       8d b6 f5 	      sta	SMMEN+1+RAM_WRITE
    689  12bc
    690  12bc							; modify player number pointer (Xp XX XX)
    691  12bc
    692  12bc		       a4 99		      ldy	whichPlayer
    693  12be		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    694  12c1		       8d ae f5 	      sta	SMPLAYER+1+RAM_WRITE
    695  12c4
    696  12c4							; fall through
    697  12c4
    698  12c4							;    ;---------------------------------------------------------------------------
    699  12c4
    700  12c4							; modify levelx character pointer (XX XX cX)
    701  12c4
    702  12c4		       a2 8a		      ldx	#<charPlace-1
    703  12c6		       a5 b5		      lda	levelDisplay
    704  12c8		       c9 80		      cmp	#$80
    705  12ca		       29 1f		      and	#$1f
    706  12cc		       a8		      tay
    707  12cd		       b0 05		      bcs	.intermission
    708  12cf		       be 27 f0 	      ldx	CharVectorLO,y
    709  12d2		       a4 b4		      ldy	level
    710  12d4				   .intermission
    711  12d4		       8e be f5 	      stx	SMLEVELX+1+RAM_WRITE
    712  12d7
    713  12d7							; modify level number pointer (XX XX Xl)
    714  12d7
    715  12d7		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    716  12da		       8d c7 f5 	      sta	SMLEVEL+1+RAM_WRITE
    717  12dd
    718  12dd							;---------------------------------------------------------------------------
    719  12dd
    720  12dd		       4c f7 f2 	      jmp	SetupTimePtr	; modify time pointers
    721  12e0
    722  12e0							;------------------------------------------------------------------------------
    723  12e0							;    DEFINE_SUBROUTINE SetupGameOverPtr
    724  12e0
    725  12e0							;		  ldy #8-1
    726  12e0							;.loopGameOver:
    727  12e0							;		  ldx SMGameOverOfs,y
    728  12e0							;		  lda SMGameOverPtr,y
    729  12e0							;		  sta SM_BASE+1+RAM_WRITE,x
    730  12e0							;		  dey
    731  12e0							;		  bpl .loopGameOver
    732  12e0
    733  12e0							;		  rts
    734  12e0
    735  12e0							;SMGameOverOfs:
    736  12e0							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    737  12e0							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    738  12e0							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    739  12e0							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    740  12e0							;SMGameOverPtr:
    741  12e0							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    742  12e0							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    743  12e0
    744  12e0							;------------------------------------------------------------------------------
    745  12e0
      0  12e0					      DEFINE_SUBROUTINE	DrawTargetsRequired
      1  12e0		       00 02	   BANK_DrawTargetsRequired =	_CURRENT_BANK
      2  12e0					      SUBROUTINE
      3  12e0				   DrawTargetsRequired
    747  12e0							; Show current TARGET counter in the top left
    748  12e0
    749  12e0		       a0 00		      ldy	#SM_OFS_TARGETS
    750  12e2		       a5 b8		      lda	targetsRequired
    751  12e4		       20 00 f3 	      jsr	SetupBCDPtr
    752  12e7
    753  12e7		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    754  12e9		       24 c7		      bit	scoringFlags	;
    755  12eb		       10 13		      bpl	SetupBCDPtr
    756  12ed		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    757  12ef		       50 0f		      bvc	SetupBCDPtr
    758  12f1		       09 01		      ora	#1	; display 1xx targets
    759  12f3		       d0 0b		      bne	SetupBCDPtr	; unconditional
    760  12f5
    761  12f5							;------------------------------------------------------------------------------
      0  12f5					      DEFINE_SUBROUTINE	DrawTime
      1  12f5		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12f5					      SUBROUTINE
      3  12f5				   DrawTime
    763  12f5
    764  12f5							; mid-digit-change, but we may be required to flash/display
    765  12f5		       a0 02		      ldy	#SM_OFS_TIME
    766  12f7							;------------------------------------------------------------------------------
      0  12f7					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12f7		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12f7					      SUBROUTINE
      3  12f7				   SetupTimePtr
    768  12f7
    769  12f7		       a5 b9		      lda	moveCounter
    770  12f9		       20 00 f3 	      jsr	SetupBCDPtr
    771  12fc		       a5 ba		      lda	moveCounter+1
    772  12fe		       09 d0		      ora	#ID_CLOCK<<4
    773  1300
    774  1300							; fall through
    775  1300
    776  1300							;------------------------------------------------------------------------------
      0  1300					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  1300		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  1300					      SUBROUTINE
      3  1300				   SetupBCDPtr
    778  1300
    779  1300							; a = BCD value
    780  1300							; y = SM table offset
    781  1300
    782  1300		       48		      pha
    783  1301		       29 0f		      and	#$0f
    784  1303		       aa		      tax
    785  1304		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    786  1307		       be 19 f0 	      ldx	SMTblLSB,y
    787  130a		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    788  130d		       68		      pla
    789  130e		       4a		      lsr
    790  130f		       4a		      lsr
    791  1310		       4a		      lsr
    792  1311		       4a		      lsr
    793  1312		       aa		      tax
    794  1313		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    795  1316		       be 20 f0 	      ldx	SMTblMSB,y
    796  1319		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    797  131c
    798  131c		       c8		      iny
    799  131d
    800  131d		       a5 c2		      lda	ROM_Bank
    801  131f				   RTS
    802  131f		       60		      rts
    803  1320
      0  1320					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
     10  1320					      LIST	ON
    805  1320
    806  1320				  -	      IF	<. = 0
    807  1320				  -	      .byte	0	; required!
    808  1320					      ENDIF
    809  1320
    810  1320				   BLANKR
    811  1320		       00 00 00 00*	      .ds	DIGIT_H, 0
    812  1327
    813  1327				   DequalsR
    814  1327		       00		      .byte.b	%00000000
    815  1328		       00		      .byte.b	%00000000
    816  1329		       f0		      .byte.b	%11110000
    817  132a		       00		      .byte.b	%00000000
    818  132b		       f0		      .byte.b	%11110000
    819  132c		       00		      .byte.b	%00000000
    820  132d		       f0		      .byte.b	%11110000
    821  132e				   DplusR
    822  132e		       10		      .byte.b	%00010000
    823  132f		       28		      .byte.b	%00101000
    824  1330		       6c		      .byte.b	%01101100
    825  1331		       c6		      .byte.b	%11000110
    826  1332		       6c		      .byte.b	%01101100
    827  1333		       28		      .byte.b	%00101000
    828  1334		       10		      .byte.b	%00010000
    829  1335
    830  1335				   ClockR
    831  1335		       00		      .byte.b	%00000000
    832  1336		       48		      .byte.b	%01001000
    833  1337		       fc		      .byte.b	%11111100
    834  1338		       48		      .byte.b	%01001000
    835  1339		       48		      .byte.b	%01001000
    836  133a		       fc		      .byte.b	%11111100
    837  133b		       48		      .byte.b	%01001000
    838  133c				   NineR
    839  133c		       0f		      .byte.b	%00001111
    840  133d		       01		      .byte.b	%00000001
    841  133e		       01		      .byte.b	%00000001
    842  133f		       7f		      .byte.b	%01111111
    843  1340		       41		      .byte.b	%01000001
    844  1341		       41		      .byte.b	%01000001
    845  1342		       7f		      .byte.b	%01111111
    846  1343				   SixR
    847  1343		       7f		      .byte.b	%01111111
    848  1344		       41		      .byte.b	%01000001
    849  1345		       41		      .byte.b	%01000001
    850  1346		       7f		      .byte.b	%01111111
    851  1347		       40		      .byte.b	%01000000
    852  1348		       40		      .byte.b	%01000000
    853  1349		       78		      .byte.b	%01111000
    854  134a				   EightR
    855  134a							;  .byte %00111110
    856  134a							;  .byte %01000011
    857  134a							;  .byte %01000011
    858  134a							;  .byte %00111110
    859  134a							;  .byte %00100011
    860  134a							;  .byte %00100011
    861  134a							;  .byte %00011110
    862  134a
    863  134a
    864  134a		       7f		      .byte.b	%01111111
    865  134b		       41		      .byte.b	%01000001
    866  134c		       41		      .byte.b	%01000001
    867  134d		       7f		      .byte.b	%01111111
    868  134e		       41		      .byte.b	%01000001
    869  134f		       41		      .byte.b	%01000001
    870  1350		       7f		      .byte.b	%01111111
    871  1351
    872  1351				   ZeroR
    873  1351		       7f		      .byte.b	%01111111
    874  1352		       41		      .byte.b	%01000001
    875  1353		       41		      .byte.b	%01000001
    876  1354		       41		      .byte.b	%01000001
    877  1355		       41		      .byte.b	%01000001
    878  1356		       41		      .byte.b	%01000001
    879  1357		       7f		      .byte.b	%01111111
    880  1358
    881  1358							;	  .byte %00111110
    882  1358							;	  .byte %01000011
    883  1358							;	  .byte %01000011
    884  1358							;	  .byte %01000011
    885  1358							;	  .byte %01000011
    886  1358							;	  .byte %00100011
    887  1358							;	  .byte %00011110
    888  1358				   ThreeR
    889  1358		       7f		      .byte.b	%01111111
    890  1359		       01		      .byte.b	%00000001
    891  135a		       01		      .byte.b	%00000001
    892  135b		       0f		      .byte.b	%00001111
    893  135c		       01		      .byte.b	%00000001
    894  135d		       01		      .byte.b	%00000001
    895  135e		       7f		      .byte.b	%01111111
    896  135f				   OneR
    897  135f		       08		      .byte.b	%00001000
    898  1360		       08		      .byte.b	%00001000
    899  1361		       08		      .byte.b	%00001000
    900  1362		       08		      .byte.b	%00001000
    901  1363		       08		      .byte.b	%00001000
    902  1364		       08		      .byte.b	%00001000
    903  1365		       08		      .byte.b	%00001000
    904  1366
    905  1366				   SevenR
    906  1366		       08		      .byte.b	%00001000
    907  1367		       08		      .byte.b	%00001000
    908  1368		       08		      .byte.b	%00001000
    909  1369		       0f		      .byte.b	%00001111
    910  136a		       01		      .byte.b	%00000001
    911  136b		       01		      .byte.b	%00000001
    912  136c		       7f		      .byte.b	%01111111
    913  136d
    914  136d				   TwoR
    915  136d		       7f		      .byte.b	%01111111
    916  136e		       40		      .byte.b	%01000000
    917  136f		       40		      .byte.b	%01000000
    918  1370		       7f		      .byte.b	%01111111
    919  1371		       01		      .byte.b	%00000001
    920  1372		       01		      .byte.b	%00000001
    921  1373		       7f		      .byte.b	%01111111
    922  1374				   FiveR
    923  1374		       7f		      .byte.b	%01111111
    924  1375		       01		      .byte.b	%00000001
    925  1376		       01		      .byte.b	%00000001
    926  1377		       7f		      .byte.b	%01111111
    927  1378		       40		      .byte.b	%01000000
    928  1379		       40		      .byte.b	%01000000
    929  137a		       78		      .byte.b	%01111000
    930  137b				   FourR
    931  137b		       08		      .byte.b	%00001000
    932  137c		       08		      .byte.b	%00001000
    933  137d		       08		      .byte.b	%00001000
    934  137e		       7f		      .byte.b	%01111111
    935  137f		       48		      .byte.b	%01001000
    936  1380		       48		      .byte.b	%01001000
    937  1381		       48		      .byte.b	%01001000
    938  1382
    939  1382							;CharAL:
    940  1382							;    .byte %11100110
    941  1382							;    .byte %11100110
    942  1382							;    .byte %11111110
    943  1382							;    .byte %11100110
    944  1382							;    .byte %11100110
    945  1382							;    .byte %01111100
    946  1382							;    .byte %00111000
    947  1382							;CharEL:
    948  1382							;    .byte %11111110
    949  1382							;    .byte %11111110
    950  1382							;    .byte %11100000
    951  1382							;    .byte %11100000
    952  1382							;    .byte %11111100
    953  1382							;    .byte %11100000
    954  1382							;    .byte %11111110
    955  1382							;CharRL:
    956  1382							;    .byte %11100110
    957  1382							;    .byte %11100110
    958  1382							;    .byte %11111100
    959  1382							;    .byte %11111100
    960  1382							;    .byte %11100110
    961  1382							;    .byte %11100110
    962  1382							;    .byte %11111100
    963  1382							;CharVL:
    964  1382							;    .byte %00111000
    965  1382							;    .byte %01111100
    966  1382							;    .byte %11100110
    967  1382							;    .byte %11100110
    968  1382							;    .byte %11100110
    969  1382							;    .byte %11100110
    970  1382							;    .byte %11100110
    971  1382
      0  1382					      CHECKPAGE	BLANKR
      8  1382					      LIST	ON
    973  1382
    974  1382							;---------------------------------------------------------------------------
    975  1382
      0  1382					      DEFINE_SUBROUTINE	GameInitialise
      1  1382		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1382					      SUBROUTINE
      3  1382				   GameInitialise
    977  1382
    978  1382							; copy loaded SK high score into scoring RAM:
    979  1382		       a2 02		      ldx	#3-1
    980  1384				   .loopCopyHighScore
    981  1384		       b5 db		      lda	highScoreSK,x
    982  1386		       c9 ff		      cmp	#$ff
    983  1388		       f0 06		      beq	.noSaveKey
    984  138a		       9d b7 f7 	      sta	HighScore+RAM_WRITE,x
    985  138d		       ca		      dex
    986  138e		       10 f4		      bpl	.loopCopyHighScore
    987  1390				   .noSaveKey
    988  1390
    989  1390							; clear both players scores
    990  1390		       a0 05		      ldy	#2*3-1
    991  1392		       a9 00		      lda	#0
    992  1394				   .loopClearScore
    993  1394		       99 ad f7 	      sta	ScoreCurrent+RAM_WRITE,y
    994  1397		       88		      dey
    995  1398		       10 fa		      bpl	.loopClearScore
    996  139a
    997  139a							; copy levelX and level for other player and SaveKey:
    998  139a		       a5 b3		      lda	levelX
    999  139c		       8d b5 f7 	      sta	PlayerLevelX+RAM_WRITE
   1000  139f		       a5 de		      lda	startingLevel
   1001  13a1		       8d b0 f7 	      sta	StartLevelX+RAM_WRITE
   1002  13a4		       a5 b4		      lda	level
   1003  13a6		       8d b6 f7 	      sta	PlayerLevel+RAM_WRITE
   1004  13a9		       8d b1 f7 	      sta	StartLevel+RAM_WRITE
   1005  13ac		       60		      rts
   1006  13ad
   1007  13ad							;---------------------------------------------------------------------------
   1008  13ad
   1009  13ad		       00 00 00    ScoreCurrent ds	3, 0
   1010  13b0							; start levelx and level have to be after ScoreCurrent!
   1011  13b0		       00	   StartLevelX .byte.b	0
   1012  13b1		       00	   StartLevel .byte.b	0
   1013  13b2		       00 00 00    PlayerScores ds	3, 0
   1014  13b5							; levelx and level have to be consecutive variables!
   1015  13b5		       00	   PlayerLevelX .byte.b	0
   1016  13b6		       00	   PlayerLevel .byte.b	0
   1017  13b7		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1018  13bc
   1019  13bc
   1020  13bc
   1021  13bc							;------------------------------------------------------------------------------
   1022  13bc
      0  13bc					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  13bc
      2  13bc
      3  13bc		       03 bc	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $3bc , FREE= $44
      4  13bc					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  13bc				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  13bc				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  13bc				  -	      ERR
      8  13bc					      endif
   1024  13bc
   1025  13bc							;------------------------------------------------------------------------------
   1026  13bc
   1027  13bc							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1028  13bc							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1029  13bc							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1030  13bc							; this is defined before or after, as once the levels have processed it will be
   1031  13bc							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1032  13bc							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1033  13bc							; TODO: verify above is still valid
   1034  13bc
   1035  13bc
      0  13bc					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  13bc		       03 bc	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $3bc , FREE= $444
      2  13bc					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  13bc				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  13bc				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  13bc				  -	      ERR
      6  13bc					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  13bc					      include	"BANK_GENERIC.asm"
      1  13bc							;    Sokoboo - a Sokoban implementation
      2  13bc							;    using a generic tile-based display engine for the Atari 2600
      3  13bc							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  13bc							;
      5  13bc							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  13bc							;
      7  13bc							;    Code related to the generic tile-based display engine was developed by
      8  13bc							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  13bc							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  13bc							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  13bc							;
     12  13bc							;    Code related to music and sound effects uses the TIATracker music player
     13  13bc							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  13bc							;    directory for Apache licensing details.
     15  13bc							;
     16  13bc							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  13bc							;    See the copyright notices in the License directory for a list of level
     18  13bc							;    contributors.
     19  13bc							;
     20  13bc							;    Except where otherwise indicated, this software is released under the
     21  13bc							;    following licensing arrangement...
     22  13bc							;
     23  13bc							;    This program is free software: you can redistribute it and/or modify
     24  13bc							;    it under the terms of the GNU General Public License as published by
     25  13bc							;    the Free Software Foundation, either version 3 of the License, or
     26  13bc							;    (at your option) any later version.
     27  13bc							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  13bc
     29  13bc							;    This program is distributed in the hope that it will be useful,
     30  13bc							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  13bc							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  13bc							;    GNU General Public License for more details.
     33  13bc
     34  13bc							;------------------------------------------------------------------------------
     35  13bc							;##############################################################################
     36  13bc							;------------------------------------------------------------------------------
     37  13bc
      0  13bc					      NEWBANK	GENERIC_BANK_1
      1  1f1e ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 3
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800				   LEVELNUM   SET	0
     35  1800				   NUMBEROFLEVELS SET	0
     36  1800		       00 03	   LEVEL_DEFINITION_SIZE =	3
     37  1800
     38  1800					      MAC	add_level
     39  1800				   LEVEL_ACTIVE_{1} SET	1
     40  1800				   LEVEL_NAMED_{1} =	LEVELNUM
     41  1800					      .byte	<LEVEL_{1}
     42  1800					      .byte	>LEVEL_{1}
     43  1800					      .byte	BANK_LEVEL_{1}
     44  1800							;.byte LEVEL_SIZE_{1}
     45  1800				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
     46  1800				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     47  1800					      ENDM		; {name}
     48  1800
     49  1800				   LevelInformation
     50  1800
     51  1800							; The ordering here corresponds to the ordering when playing...
     52  1800
      0  1800					      ADD_LEVEL	_001_L
      1  1800				   LEVEL_ACTIVE__001_L SET	1
      2  1800		       00 00	   LEVEL_NAMED__001_L =	LEVELNUM
      3  1800		       00		      .byte.b	<LEVEL__001_L
      4  1801		       f0		      .byte.b	>LEVEL__001_L
      5  1802		       04		      .byte.b	BANK_LEVEL__001_L
      6  1803
      7  1803				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1803				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1803					      ADD_LEVEL	_001_R
      1  1803				   LEVEL_ACTIVE__001_R SET	1
      2  1803		       00 03	   LEVEL_NAMED__001_R =	LEVELNUM
      3  1803		       13		      .byte.b	<LEVEL__001_R
      4  1804		       f0		      .byte.b	>LEVEL__001_R
      5  1805		       04		      .byte.b	BANK_LEVEL__001_R
      6  1806
      7  1806				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1806				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1806					      ADD_LEVEL	_002_L
      1  1806				   LEVEL_ACTIVE__002_L SET	1
      2  1806		       00 06	   LEVEL_NAMED__002_L =	LEVELNUM
      3  1806		       20		      .byte.b	<LEVEL__002_L
      4  1807		       f0		      .byte.b	>LEVEL__002_L
      5  1808		       04		      .byte.b	BANK_LEVEL__002_L
      6  1809
      7  1809				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1809				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1809					      ADD_LEVEL	_002_R
      1  1809				   LEVEL_ACTIVE__002_R SET	1
      2  1809		       00 09	   LEVEL_NAMED__002_R =	LEVELNUM
      3  1809		       3a		      .byte.b	<LEVEL__002_R
      4  180a		       f0		      .byte.b	>LEVEL__002_R
      5  180b		       04		      .byte.b	BANK_LEVEL__002_R
      6  180c
      7  180c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180c					      ADD_LEVEL	_003_L
      1  180c				   LEVEL_ACTIVE__003_L SET	1
      2  180c		       00 0c	   LEVEL_NAMED__003_L =	LEVELNUM
      3  180c		       63		      .byte.b	<LEVEL__003_L
      4  180d		       f0		      .byte.b	>LEVEL__003_L
      5  180e		       04		      .byte.b	BANK_LEVEL__003_L
      6  180f
      7  180f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180f					      ADD_LEVEL	_003_R
      1  180f				   LEVEL_ACTIVE__003_R SET	1
      2  180f		       00 0f	   LEVEL_NAMED__003_R =	LEVELNUM
      3  180f		       90		      .byte.b	<LEVEL__003_R
      4  1810		       f0		      .byte.b	>LEVEL__003_R
      5  1811		       04		      .byte.b	BANK_LEVEL__003_R
      6  1812
      7  1812				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1812				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1812					      ADD_LEVEL	_004_L
      1  1812				   LEVEL_ACTIVE__004_L SET	1
      2  1812		       00 12	   LEVEL_NAMED__004_L =	LEVELNUM
      3  1812		       bb		      .byte.b	<LEVEL__004_L
      4  1813		       f0		      .byte.b	>LEVEL__004_L
      5  1814		       04		      .byte.b	BANK_LEVEL__004_L
      6  1815
      7  1815				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1815				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1815					      ADD_LEVEL	_004_R
      1  1815				   LEVEL_ACTIVE__004_R SET	1
      2  1815		       00 15	   LEVEL_NAMED__004_R =	LEVELNUM
      3  1815		       df		      .byte.b	<LEVEL__004_R
      4  1816		       f0		      .byte.b	>LEVEL__004_R
      5  1817		       04		      .byte.b	BANK_LEVEL__004_R
      6  1818
      7  1818				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1818				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1818					      ADD_LEVEL	_005_L
      1  1818				   LEVEL_ACTIVE__005_L SET	1
      2  1818		       00 18	   LEVEL_NAMED__005_L =	LEVELNUM
      3  1818		       fc		      .byte.b	<LEVEL__005_L
      4  1819		       f0		      .byte.b	>LEVEL__005_L
      5  181a		       04		      .byte.b	BANK_LEVEL__005_L
      6  181b
      7  181b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181b					      ADD_LEVEL	_005_R
      1  181b				   LEVEL_ACTIVE__005_R SET	1
      2  181b		       00 1b	   LEVEL_NAMED__005_R =	LEVELNUM
      3  181b		       2f		      .byte.b	<LEVEL__005_R
      4  181c		       f1		      .byte.b	>LEVEL__005_R
      5  181d		       04		      .byte.b	BANK_LEVEL__005_R
      6  181e
      7  181e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181e					      ADD_LEVEL	_006_L
      1  181e				   LEVEL_ACTIVE__006_L SET	1
      2  181e		       00 1e	   LEVEL_NAMED__006_L =	LEVELNUM
      3  181e		       6f		      .byte.b	<LEVEL__006_L
      4  181f		       f1		      .byte.b	>LEVEL__006_L
      5  1820		       04		      .byte.b	BANK_LEVEL__006_L
      6  1821
      7  1821				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1821				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1821					      ADD_LEVEL	_006_R
      1  1821				   LEVEL_ACTIVE__006_R SET	1
      2  1821		       00 21	   LEVEL_NAMED__006_R =	LEVELNUM
      3  1821		       ab		      .byte.b	<LEVEL__006_R
      4  1822		       f1		      .byte.b	>LEVEL__006_R
      5  1823		       04		      .byte.b	BANK_LEVEL__006_R
      6  1824
      7  1824				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1824				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1824					      ADD_LEVEL	_007_L
      1  1824				   LEVEL_ACTIVE__007_L SET	1
      2  1824		       00 24	   LEVEL_NAMED__007_L =	LEVELNUM
      3  1824		       ea		      .byte.b	<LEVEL__007_L
      4  1825		       f1		      .byte.b	>LEVEL__007_L
      5  1826		       04		      .byte.b	BANK_LEVEL__007_L
      6  1827
      7  1827				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1827				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1827					      ADD_LEVEL	_007_R
      1  1827				   LEVEL_ACTIVE__007_R SET	1
      2  1827		       00 27	   LEVEL_NAMED__007_R =	LEVELNUM
      3  1827		       18		      .byte.b	<LEVEL__007_R
      4  1828		       f2		      .byte.b	>LEVEL__007_R
      5  1829		       04		      .byte.b	BANK_LEVEL__007_R
      6  182a
      7  182a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182a					      ADD_LEVEL	_008_L
      1  182a				   LEVEL_ACTIVE__008_L SET	1
      2  182a		       00 2a	   LEVEL_NAMED__008_L =	LEVELNUM
      3  182a		       4c		      .byte.b	<LEVEL__008_L
      4  182b		       f2		      .byte.b	>LEVEL__008_L
      5  182c		       04		      .byte.b	BANK_LEVEL__008_L
      6  182d
      7  182d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182d					      ADD_LEVEL	_008_R
      1  182d				   LEVEL_ACTIVE__008_R SET	1
      2  182d		       00 2d	   LEVEL_NAMED__008_R =	LEVELNUM
      3  182d		       83		      .byte.b	<LEVEL__008_R
      4  182e		       f2		      .byte.b	>LEVEL__008_R
      5  182f		       04		      .byte.b	BANK_LEVEL__008_R
      6  1830
      7  1830				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1830				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1830					      ADD_LEVEL	_009_L
      1  1830				   LEVEL_ACTIVE__009_L SET	1
      2  1830		       00 30	   LEVEL_NAMED__009_L =	LEVELNUM
      3  1830		       b5		      .byte.b	<LEVEL__009_L
      4  1831		       f2		      .byte.b	>LEVEL__009_L
      5  1832		       04		      .byte.b	BANK_LEVEL__009_L
      6  1833
      7  1833				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1833				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1833					      ADD_LEVEL	_009_R
      1  1833				   LEVEL_ACTIVE__009_R SET	1
      2  1833		       00 33	   LEVEL_NAMED__009_R =	LEVELNUM
      3  1833		       e8		      .byte.b	<LEVEL__009_R
      4  1834		       f2		      .byte.b	>LEVEL__009_R
      5  1835		       04		      .byte.b	BANK_LEVEL__009_R
      6  1836
      7  1836				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1836				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1836					      ADD_LEVEL	_010_L
      1  1836				   LEVEL_ACTIVE__010_L SET	1
      2  1836		       00 36	   LEVEL_NAMED__010_L =	LEVELNUM
      3  1836		       19		      .byte.b	<LEVEL__010_L
      4  1837		       f3		      .byte.b	>LEVEL__010_L
      5  1838		       04		      .byte.b	BANK_LEVEL__010_L
      6  1839
      7  1839				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1839				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1839					      ADD_LEVEL	_010_R
      1  1839				   LEVEL_ACTIVE__010_R SET	1
      2  1839		       00 39	   LEVEL_NAMED__010_R =	LEVELNUM
      3  1839		       54		      .byte.b	<LEVEL__010_R
      4  183a		       f3		      .byte.b	>LEVEL__010_R
      5  183b		       04		      .byte.b	BANK_LEVEL__010_R
      6  183c
      7  183c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183c					      ADD_LEVEL	_011_L
      1  183c				   LEVEL_ACTIVE__011_L SET	1
      2  183c		       00 3c	   LEVEL_NAMED__011_L =	LEVELNUM
      3  183c		       88		      .byte.b	<LEVEL__011_L
      4  183d		       f3		      .byte.b	>LEVEL__011_L
      5  183e		       04		      .byte.b	BANK_LEVEL__011_L
      6  183f
      7  183f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183f					      ADD_LEVEL	_011_R
      1  183f				   LEVEL_ACTIVE__011_R SET	1
      2  183f		       00 3f	   LEVEL_NAMED__011_R =	LEVELNUM
      3  183f		       bc		      .byte.b	<LEVEL__011_R
      4  1840		       f3		      .byte.b	>LEVEL__011_R
      5  1841		       04		      .byte.b	BANK_LEVEL__011_R
      6  1842
      7  1842				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1842				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1842					      ADD_LEVEL	_012_L
      1  1842				   LEVEL_ACTIVE__012_L SET	1
      2  1842		       00 42	   LEVEL_NAMED__012_L =	LEVELNUM
      3  1842		       f7		      .byte.b	<LEVEL__012_L
      4  1843		       f3		      .byte.b	>LEVEL__012_L
      5  1844		       04		      .byte.b	BANK_LEVEL__012_L
      6  1845
      7  1845				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1845				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1845					      ADD_LEVEL	_012_R
      1  1845				   LEVEL_ACTIVE__012_R SET	1
      2  1845		       00 45	   LEVEL_NAMED__012_R =	LEVELNUM
      3  1845		       28		      .byte.b	<LEVEL__012_R
      4  1846		       f4		      .byte.b	>LEVEL__012_R
      5  1847		       04		      .byte.b	BANK_LEVEL__012_R
      6  1848
      7  1848				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1848				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1848					      ADD_LEVEL	_013_L
      1  1848				   LEVEL_ACTIVE__013_L SET	1
      2  1848		       00 48	   LEVEL_NAMED__013_L =	LEVELNUM
      3  1848		       65		      .byte.b	<LEVEL__013_L
      4  1849		       f4		      .byte.b	>LEVEL__013_L
      5  184a		       04		      .byte.b	BANK_LEVEL__013_L
      6  184b
      7  184b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184b					      ADD_LEVEL	_013_R
      1  184b				   LEVEL_ACTIVE__013_R SET	1
      2  184b		       00 4b	   LEVEL_NAMED__013_R =	LEVELNUM
      3  184b		       a5		      .byte.b	<LEVEL__013_R
      4  184c		       f4		      .byte.b	>LEVEL__013_R
      5  184d		       04		      .byte.b	BANK_LEVEL__013_R
      6  184e
      7  184e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184e					      ADD_LEVEL	_014_L
      1  184e				   LEVEL_ACTIVE__014_L SET	1
      2  184e		       00 4e	   LEVEL_NAMED__014_L =	LEVELNUM
      3  184e		       d9		      .byte.b	<LEVEL__014_L
      4  184f		       f4		      .byte.b	>LEVEL__014_L
      5  1850		       04		      .byte.b	BANK_LEVEL__014_L
      6  1851
      7  1851				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1851				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1851					      ADD_LEVEL	_014_R
      1  1851				   LEVEL_ACTIVE__014_R SET	1
      2  1851		       00 51	   LEVEL_NAMED__014_R =	LEVELNUM
      3  1851		       1d		      .byte.b	<LEVEL__014_R
      4  1852		       f5		      .byte.b	>LEVEL__014_R
      5  1853		       04		      .byte.b	BANK_LEVEL__014_R
      6  1854
      7  1854				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1854				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1854					      ADD_LEVEL	_015_L
      1  1854				   LEVEL_ACTIVE__015_L SET	1
      2  1854		       00 54	   LEVEL_NAMED__015_L =	LEVELNUM
      3  1854		       61		      .byte.b	<LEVEL__015_L
      4  1855		       f5		      .byte.b	>LEVEL__015_L
      5  1856		       04		      .byte.b	BANK_LEVEL__015_L
      6  1857
      7  1857				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1857				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1857					      ADD_LEVEL	_015_R
      1  1857				   LEVEL_ACTIVE__015_R SET	1
      2  1857		       00 57	   LEVEL_NAMED__015_R =	LEVELNUM
      3  1857		       97		      .byte.b	<LEVEL__015_R
      4  1858		       f5		      .byte.b	>LEVEL__015_R
      5  1859		       04		      .byte.b	BANK_LEVEL__015_R
      6  185a
      7  185a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185a					      ADD_LEVEL	_016_L
      1  185a				   LEVEL_ACTIVE__016_L SET	1
      2  185a		       00 5a	   LEVEL_NAMED__016_L =	LEVELNUM
      3  185a		       dd		      .byte.b	<LEVEL__016_L
      4  185b		       f5		      .byte.b	>LEVEL__016_L
      5  185c		       04		      .byte.b	BANK_LEVEL__016_L
      6  185d
      7  185d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185d					      ADD_LEVEL	_016_R
      1  185d				   LEVEL_ACTIVE__016_R SET	1
      2  185d		       00 5d	   LEVEL_NAMED__016_R =	LEVELNUM
      3  185d		       15		      .byte.b	<LEVEL__016_R
      4  185e		       f6		      .byte.b	>LEVEL__016_R
      5  185f		       04		      .byte.b	BANK_LEVEL__016_R
      6  1860
      7  1860				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1860				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1860					      ADD_LEVEL	_017_L
      1  1860				   LEVEL_ACTIVE__017_L SET	1
      2  1860		       00 60	   LEVEL_NAMED__017_L =	LEVELNUM
      3  1860		       49		      .byte.b	<LEVEL__017_L
      4  1861		       f6		      .byte.b	>LEVEL__017_L
      5  1862		       04		      .byte.b	BANK_LEVEL__017_L
      6  1863
      7  1863				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1863				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1863					      ADD_LEVEL	_017_R
      1  1863				   LEVEL_ACTIVE__017_R SET	1
      2  1863		       00 63	   LEVEL_NAMED__017_R =	LEVELNUM
      3  1863		       94		      .byte.b	<LEVEL__017_R
      4  1864		       f6		      .byte.b	>LEVEL__017_R
      5  1865		       04		      .byte.b	BANK_LEVEL__017_R
      6  1866
      7  1866				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1866				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1866					      ADD_LEVEL	_018_L
      1  1866				   LEVEL_ACTIVE__018_L SET	1
      2  1866		       00 66	   LEVEL_NAMED__018_L =	LEVELNUM
      3  1866		       d8		      .byte.b	<LEVEL__018_L
      4  1867		       f6		      .byte.b	>LEVEL__018_L
      5  1868		       04		      .byte.b	BANK_LEVEL__018_L
      6  1869
      7  1869				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1869				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1869					      ADD_LEVEL	_018_R
      1  1869				   LEVEL_ACTIVE__018_R SET	1
      2  1869		       00 69	   LEVEL_NAMED__018_R =	LEVELNUM
      3  1869		       0d		      .byte.b	<LEVEL__018_R
      4  186a		       f7		      .byte.b	>LEVEL__018_R
      5  186b		       04		      .byte.b	BANK_LEVEL__018_R
      6  186c
      7  186c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186c					      ADD_LEVEL	_019_L
      1  186c				   LEVEL_ACTIVE__019_L SET	1
      2  186c		       00 6c	   LEVEL_NAMED__019_L =	LEVELNUM
      3  186c		       4a		      .byte.b	<LEVEL__019_L
      4  186d		       f7		      .byte.b	>LEVEL__019_L
      5  186e		       04		      .byte.b	BANK_LEVEL__019_L
      6  186f
      7  186f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186f					      ADD_LEVEL	_019_R
      1  186f				   LEVEL_ACTIVE__019_R SET	1
      2  186f		       00 6f	   LEVEL_NAMED__019_R =	LEVELNUM
      3  186f		       86		      .byte.b	<LEVEL__019_R
      4  1870		       f7		      .byte.b	>LEVEL__019_R
      5  1871		       04		      .byte.b	BANK_LEVEL__019_R
      6  1872
      7  1872				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1872				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1872					      ADD_LEVEL	_020_L
      1  1872				   LEVEL_ACTIVE__020_L SET	1
      2  1872		       00 72	   LEVEL_NAMED__020_L =	LEVELNUM
      3  1872		       00		      .byte.b	<LEVEL__020_L
      4  1873		       f0		      .byte.b	>LEVEL__020_L
      5  1874		       05		      .byte.b	BANK_LEVEL__020_L
      6  1875
      7  1875				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1875				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1875					      ADD_LEVEL	_020_R
      1  1875				   LEVEL_ACTIVE__020_R SET	1
      2  1875		       00 75	   LEVEL_NAMED__020_R =	LEVELNUM
      3  1875		       40		      .byte.b	<LEVEL__020_R
      4  1876		       f0		      .byte.b	>LEVEL__020_R
      5  1877		       05		      .byte.b	BANK_LEVEL__020_R
      6  1878
      7  1878				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1878				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1878					      ADD_LEVEL	_021_L
      1  1878				   LEVEL_ACTIVE__021_L SET	1
      2  1878		       00 78	   LEVEL_NAMED__021_L =	LEVELNUM
      3  1878		       81		      .byte.b	<LEVEL__021_L
      4  1879		       f0		      .byte.b	>LEVEL__021_L
      5  187a		       05		      .byte.b	BANK_LEVEL__021_L
      6  187b
      7  187b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187b					      ADD_LEVEL	_021_R
      1  187b				   LEVEL_ACTIVE__021_R SET	1
      2  187b		       00 7b	   LEVEL_NAMED__021_R =	LEVELNUM
      3  187b		       d8		      .byte.b	<LEVEL__021_R
      4  187c		       f0		      .byte.b	>LEVEL__021_R
      5  187d		       05		      .byte.b	BANK_LEVEL__021_R
      6  187e
      7  187e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187e					      ADD_LEVEL	_022_L
      1  187e				   LEVEL_ACTIVE__022_L SET	1
      2  187e		       00 7e	   LEVEL_NAMED__022_L =	LEVELNUM
      3  187e		       0d		      .byte.b	<LEVEL__022_L
      4  187f		       f1		      .byte.b	>LEVEL__022_L
      5  1880		       05		      .byte.b	BANK_LEVEL__022_L
      6  1881
      7  1881				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1881				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1881					      ADD_LEVEL	_022_R
      1  1881				   LEVEL_ACTIVE__022_R SET	1
      2  1881		       00 81	   LEVEL_NAMED__022_R =	LEVELNUM
      3  1881		       54		      .byte.b	<LEVEL__022_R
      4  1882		       f1		      .byte.b	>LEVEL__022_R
      5  1883		       05		      .byte.b	BANK_LEVEL__022_R
      6  1884
      7  1884				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1884				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1884					      ADD_LEVEL	_023_L
      1  1884				   LEVEL_ACTIVE__023_L SET	1
      2  1884		       00 84	   LEVEL_NAMED__023_L =	LEVELNUM
      3  1884		       91		      .byte.b	<LEVEL__023_L
      4  1885		       f1		      .byte.b	>LEVEL__023_L
      5  1886		       05		      .byte.b	BANK_LEVEL__023_L
      6  1887
      7  1887				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1887				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1887					      ADD_LEVEL	_023_R
      1  1887				   LEVEL_ACTIVE__023_R SET	1
      2  1887		       00 87	   LEVEL_NAMED__023_R =	LEVELNUM
      3  1887		       d3		      .byte.b	<LEVEL__023_R
      4  1888		       f1		      .byte.b	>LEVEL__023_R
      5  1889		       05		      .byte.b	BANK_LEVEL__023_R
      6  188a
      7  188a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     99  188a
      0  188a					      ADD_LEVEL	_050_L
      1  188a				   LEVEL_ACTIVE__050_L SET	1
      2  188a		       00 8a	   LEVEL_NAMED__050_L =	LEVELNUM
      3  188a		       16		      .byte.b	<LEVEL__050_L
      4  188b		       f2		      .byte.b	>LEVEL__050_L
      5  188c		       05		      .byte.b	BANK_LEVEL__050_L
      6  188d
      7  188d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  188d					      ADD_LEVEL	_050_R
      1  188d				   LEVEL_ACTIVE__050_R SET	1
      2  188d		       00 8d	   LEVEL_NAMED__050_R =	LEVELNUM
      3  188d		       64		      .byte.b	<LEVEL__050_R
      4  188e		       f2		      .byte.b	>LEVEL__050_R
      5  188f		       05		      .byte.b	BANK_LEVEL__050_R
      6  1890
      7  1890				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1890				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1890					      ADD_LEVEL	_051_L
      1  1890				   LEVEL_ACTIVE__051_L SET	1
      2  1890		       00 90	   LEVEL_NAMED__051_L =	LEVELNUM
      3  1890		       9e		      .byte.b	<LEVEL__051_L
      4  1891		       f2		      .byte.b	>LEVEL__051_L
      5  1892		       05		      .byte.b	BANK_LEVEL__051_L
      6  1893
      7  1893				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1893				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1893					      ADD_LEVEL	_051_R
      1  1893				   LEVEL_ACTIVE__051_R SET	1
      2  1893		       00 93	   LEVEL_NAMED__051_R =	LEVELNUM
      3  1893		       f2		      .byte.b	<LEVEL__051_R
      4  1894		       f2		      .byte.b	>LEVEL__051_R
      5  1895		       05		      .byte.b	BANK_LEVEL__051_R
      6  1896
      7  1896				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1896				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1896					      ADD_LEVEL	_052_L
      1  1896				   LEVEL_ACTIVE__052_L SET	1
      2  1896		       00 96	   LEVEL_NAMED__052_L =	LEVELNUM
      3  1896		       44		      .byte.b	<LEVEL__052_L
      4  1897		       f3		      .byte.b	>LEVEL__052_L
      5  1898		       05		      .byte.b	BANK_LEVEL__052_L
      6  1899
      7  1899				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1899				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1899					      ADD_LEVEL	_052_R
      1  1899				   LEVEL_ACTIVE__052_R SET	1
      2  1899		       00 99	   LEVEL_NAMED__052_R =	LEVELNUM
      3  1899		       7f		      .byte.b	<LEVEL__052_R
      4  189a		       f3		      .byte.b	>LEVEL__052_R
      5  189b		       05		      .byte.b	BANK_LEVEL__052_R
      6  189c
      7  189c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189c					      ADD_LEVEL	_053_L
      1  189c				   LEVEL_ACTIVE__053_L SET	1
      2  189c		       00 9c	   LEVEL_NAMED__053_L =	LEVELNUM
      3  189c		       c8		      .byte.b	<LEVEL__053_L
      4  189d		       f3		      .byte.b	>LEVEL__053_L
      5  189e		       05		      .byte.b	BANK_LEVEL__053_L
      6  189f
      7  189f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189f					      ADD_LEVEL	_053_R
      1  189f				   LEVEL_ACTIVE__053_R SET	1
      2  189f		       00 9f	   LEVEL_NAMED__053_R =	LEVELNUM
      3  189f		       1e		      .byte.b	<LEVEL__053_R
      4  18a0		       f4		      .byte.b	>LEVEL__053_R
      5  18a1		       05		      .byte.b	BANK_LEVEL__053_R
      6  18a2
      7  18a2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a2					      ADD_LEVEL	_054_L
      1  18a2				   LEVEL_ACTIVE__054_L SET	1
      2  18a2		       00 a2	   LEVEL_NAMED__054_L =	LEVELNUM
      3  18a2		       6c		      .byte.b	<LEVEL__054_L
      4  18a3		       f4		      .byte.b	>LEVEL__054_L
      5  18a4		       05		      .byte.b	BANK_LEVEL__054_L
      6  18a5
      7  18a5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a5					      ADD_LEVEL	_054_R
      1  18a5				   LEVEL_ACTIVE__054_R SET	1
      2  18a5		       00 a5	   LEVEL_NAMED__054_R =	LEVELNUM
      3  18a5		       b9		      .byte.b	<LEVEL__054_R
      4  18a6		       f4		      .byte.b	>LEVEL__054_R
      5  18a7		       05		      .byte.b	BANK_LEVEL__054_R
      6  18a8
      7  18a8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a8					      ADD_LEVEL	_055_L
      1  18a8				   LEVEL_ACTIVE__055_L SET	1
      2  18a8		       00 a8	   LEVEL_NAMED__055_L =	LEVELNUM
      3  18a8		       03		      .byte.b	<LEVEL__055_L
      4  18a9		       f5		      .byte.b	>LEVEL__055_L
      5  18aa		       05		      .byte.b	BANK_LEVEL__055_L
      6  18ab
      7  18ab				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ab				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ab					      ADD_LEVEL	_055_R
      1  18ab				   LEVEL_ACTIVE__055_R SET	1
      2  18ab		       00 ab	   LEVEL_NAMED__055_R =	LEVELNUM
      3  18ab		       5e		      .byte.b	<LEVEL__055_R
      4  18ac		       f5		      .byte.b	>LEVEL__055_R
      5  18ad		       05		      .byte.b	BANK_LEVEL__055_R
      6  18ae
      7  18ae				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ae				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ae					      ADD_LEVEL	_056_L
      1  18ae				   LEVEL_ACTIVE__056_L SET	1
      2  18ae		       00 ae	   LEVEL_NAMED__056_L =	LEVELNUM
      3  18ae		       b4		      .byte.b	<LEVEL__056_L
      4  18af		       f5		      .byte.b	>LEVEL__056_L
      5  18b0		       05		      .byte.b	BANK_LEVEL__056_L
      6  18b1
      7  18b1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b1					      ADD_LEVEL	_056_R
      1  18b1				   LEVEL_ACTIVE__056_R SET	1
      2  18b1		       00 b1	   LEVEL_NAMED__056_R =	LEVELNUM
      3  18b1		       0f		      .byte.b	<LEVEL__056_R
      4  18b2		       f6		      .byte.b	>LEVEL__056_R
      5  18b3		       05		      .byte.b	BANK_LEVEL__056_R
      6  18b4
      7  18b4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b4					      ADD_LEVEL	_057_L
      1  18b4				   LEVEL_ACTIVE__057_L SET	1
      2  18b4		       00 b4	   LEVEL_NAMED__057_L =	LEVELNUM
      3  18b4		       6b		      .byte.b	<LEVEL__057_L
      4  18b5		       f6		      .byte.b	>LEVEL__057_L
      5  18b6		       05		      .byte.b	BANK_LEVEL__057_L
      6  18b7
      7  18b7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    115  18b7
      0  18b7					      ADD_LEVEL	_060_R
      1  18b7				   LEVEL_ACTIVE__060_R SET	1
      2  18b7		       00 b7	   LEVEL_NAMED__060_R =	LEVELNUM
      3  18b7		       00		      .byte.b	<LEVEL__060_R
      4  18b8		       f0		      .byte.b	>LEVEL__060_R
      5  18b9		       06		      .byte.b	BANK_LEVEL__060_R
      6  18ba
      7  18ba				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ba				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ba					      ADD_LEVEL	_061_R
      1  18ba				   LEVEL_ACTIVE__061_R SET	1
      2  18ba		       00 ba	   LEVEL_NAMED__061_R =	LEVELNUM
      3  18ba		       9e		      .byte.b	<LEVEL__061_R
      4  18bb		       f0		      .byte.b	>LEVEL__061_R
      5  18bc		       06		      .byte.b	BANK_LEVEL__061_R
      6  18bd
      7  18bd				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18bd				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18bd					      ADD_LEVEL	_061_L
      1  18bd				   LEVEL_ACTIVE__061_L SET	1
      2  18bd		       00 bd	   LEVEL_NAMED__061_L =	LEVELNUM
      3  18bd		       49		      .byte.b	<LEVEL__061_L
      4  18be		       f0		      .byte.b	>LEVEL__061_L
      5  18bf		       06		      .byte.b	BANK_LEVEL__061_L
      6  18c0
      7  18c0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c0					      ADD_LEVEL	_062_L
      1  18c0				   LEVEL_ACTIVE__062_L SET	1
      2  18c0		       00 c0	   LEVEL_NAMED__062_L =	LEVELNUM
      3  18c0		       e8		      .byte.b	<LEVEL__062_L
      4  18c1		       f0		      .byte.b	>LEVEL__062_L
      5  18c2		       06		      .byte.b	BANK_LEVEL__062_L
      6  18c3
      7  18c3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c3					      ADD_LEVEL	_062_R
      1  18c3				   LEVEL_ACTIVE__062_R SET	1
      2  18c3		       00 c3	   LEVEL_NAMED__062_R =	LEVELNUM
      3  18c3		       40		      .byte.b	<LEVEL__062_R
      4  18c4		       f1		      .byte.b	>LEVEL__062_R
      5  18c5		       06		      .byte.b	BANK_LEVEL__062_R
      6  18c6
      7  18c6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c6					      ADD_LEVEL	_063_L
      1  18c6				   LEVEL_ACTIVE__063_L SET	1
      2  18c6		       00 c6	   LEVEL_NAMED__063_L =	LEVELNUM
      3  18c6		       8d		      .byte.b	<LEVEL__063_L
      4  18c7		       f1		      .byte.b	>LEVEL__063_L
      5  18c8		       06		      .byte.b	BANK_LEVEL__063_L
      6  18c9
      7  18c9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c9					      ADD_LEVEL	_063_R
      1  18c9				   LEVEL_ACTIVE__063_R SET	1
      2  18c9		       00 c9	   LEVEL_NAMED__063_R =	LEVELNUM
      3  18c9		       de		      .byte.b	<LEVEL__063_R
      4  18ca		       f1		      .byte.b	>LEVEL__063_R
      5  18cb		       06		      .byte.b	BANK_LEVEL__063_R
      6  18cc
      7  18cc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cc					      ADD_LEVEL	_064_R
      1  18cc				   LEVEL_ACTIVE__064_R SET	1
      2  18cc		       00 cc	   LEVEL_NAMED__064_R =	LEVELNUM
      3  18cc		       8d		      .byte.b	<LEVEL__064_R
      4  18cd		       f2		      .byte.b	>LEVEL__064_R
      5  18ce		       06		      .byte.b	BANK_LEVEL__064_R
      6  18cf
      7  18cf				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cf				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cf					      ADD_LEVEL	_064_L
      1  18cf				   LEVEL_ACTIVE__064_L SET	1
      2  18cf		       00 cf	   LEVEL_NAMED__064_L =	LEVELNUM
      3  18cf		       31		      .byte.b	<LEVEL__064_L
      4  18d0		       f2		      .byte.b	>LEVEL__064_L
      5  18d1		       06		      .byte.b	BANK_LEVEL__064_L
      6  18d2
      7  18d2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d2					      ADD_LEVEL	_065_R
      1  18d2				   LEVEL_ACTIVE__065_R SET	1
      2  18d2		       00 d2	   LEVEL_NAMED__065_R =	LEVELNUM
      3  18d2		       33		      .byte.b	<LEVEL__065_R
      4  18d3		       f3		      .byte.b	>LEVEL__065_R
      5  18d4		       06		      .byte.b	BANK_LEVEL__065_R
      6  18d5
      7  18d5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d5					      ADD_LEVEL	_065_L
      1  18d5				   LEVEL_ACTIVE__065_L SET	1
      2  18d5		       00 d5	   LEVEL_NAMED__065_L =	LEVELNUM
      3  18d5		       da		      .byte.b	<LEVEL__065_L
      4  18d6		       f2		      .byte.b	>LEVEL__065_L
      5  18d7		       06		      .byte.b	BANK_LEVEL__065_L
      6  18d8
      7  18d8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d8					      ADD_LEVEL	_066_R
      1  18d8				   LEVEL_ACTIVE__066_R SET	1
      2  18d8		       00 d8	   LEVEL_NAMED__066_R =	LEVELNUM
      3  18d8		       d7		      .byte.b	<LEVEL__066_R
      4  18d9		       f3		      .byte.b	>LEVEL__066_R
      5  18da		       06		      .byte.b	BANK_LEVEL__066_R
      6  18db
      7  18db				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18db				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18db					      ADD_LEVEL	_066_L
      1  18db				   LEVEL_ACTIVE__066_L SET	1
      2  18db		       00 db	   LEVEL_NAMED__066_L =	LEVELNUM
      3  18db		       7c		      .byte.b	<LEVEL__066_L
      4  18dc		       f3		      .byte.b	>LEVEL__066_L
      5  18dd		       06		      .byte.b	BANK_LEVEL__066_L
      6  18de
      7  18de				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18de				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18de					      ADD_LEVEL	_067_R
      1  18de				   LEVEL_ACTIVE__067_R SET	1
      2  18de		       00 de	   LEVEL_NAMED__067_R =	LEVELNUM
      3  18de		       7c		      .byte.b	<LEVEL__067_R
      4  18df		       f4		      .byte.b	>LEVEL__067_R
      5  18e0		       06		      .byte.b	BANK_LEVEL__067_R
      6  18e1
      7  18e1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e1					      ADD_LEVEL	_067_L
      1  18e1				   LEVEL_ACTIVE__067_L SET	1
      2  18e1		       00 e1	   LEVEL_NAMED__067_L =	LEVELNUM
      3  18e1		       2e		      .byte.b	<LEVEL__067_L
      4  18e2		       f4		      .byte.b	>LEVEL__067_L
      5  18e3		       06		      .byte.b	BANK_LEVEL__067_L
      6  18e4
      7  18e4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e4					      ADD_LEVEL	_068_R
      1  18e4				   LEVEL_ACTIVE__068_R SET	1
      2  18e4		       00 e4	   LEVEL_NAMED__068_R =	LEVELNUM
      3  18e4		       37		      .byte.b	<LEVEL__068_R
      4  18e5		       f5		      .byte.b	>LEVEL__068_R
      5  18e6		       06		      .byte.b	BANK_LEVEL__068_R
      6  18e7
      7  18e7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e7					      ADD_LEVEL	_068_L
      1  18e7				   LEVEL_ACTIVE__068_L SET	1
      2  18e7		       00 e7	   LEVEL_NAMED__068_L =	LEVELNUM
      3  18e7		       e2		      .byte.b	<LEVEL__068_L
      4  18e8		       f4		      .byte.b	>LEVEL__068_L
      5  18e9		       06		      .byte.b	BANK_LEVEL__068_L
      6  18ea
      7  18ea				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ea				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ea					      ADD_LEVEL	_069_R
      1  18ea				   LEVEL_ACTIVE__069_R SET	1
      2  18ea		       00 ea	   LEVEL_NAMED__069_R =	LEVELNUM
      3  18ea		       dd		      .byte.b	<LEVEL__069_R
      4  18eb		       f5		      .byte.b	>LEVEL__069_R
      5  18ec		       06		      .byte.b	BANK_LEVEL__069_R
      6  18ed
      7  18ed				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ed				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ed					      ADD_LEVEL	_069_L
      1  18ed				   LEVEL_ACTIVE__069_L SET	1
      2  18ed		       00 ed	   LEVEL_NAMED__069_L =	LEVELNUM
      3  18ed		       8e		      .byte.b	<LEVEL__069_L
      4  18ee		       f5		      .byte.b	>LEVEL__069_L
      5  18ef		       06		      .byte.b	BANK_LEVEL__069_L
      6  18f0
      7  18f0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    135  18f0
      0  18f0					      ADD_LEVEL	_103_Arielle
      1  18f0				   LEVEL_ACTIVE__103_Arielle SET	1
      2  18f0		       00 f0	   LEVEL_NAMED__103_Arielle =	LEVELNUM
      3  18f0		       ef		      .byte.b	<LEVEL__103_Arielle
      4  18f1		       f1		      .byte.b	>LEVEL__103_Arielle
      5  18f2		       07		      .byte.b	BANK_LEVEL__103_Arielle
      6  18f3
      7  18f3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f3					      ADD_LEVEL	_103_Ajalae
      1  18f3				   LEVEL_ACTIVE__103_Ajalae SET	1
      2  18f3		       00 f3	   LEVEL_NAMED__103_Ajalae =	LEVELNUM
      3  18f3		       a7		      .byte.b	<LEVEL__103_Ajalae
      4  18f4		       f1		      .byte.b	>LEVEL__103_Ajalae
      5  18f5		       07		      .byte.b	BANK_LEVEL__103_Ajalae
      6  18f6
      7  18f6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f6					      ADD_LEVEL	_103_Adin
      1  18f6				   LEVEL_ACTIVE__103_Adin SET	1
      2  18f6		       00 f6	   LEVEL_NAMED__103_Adin =	LEVELNUM
      3  18f6		       5b		      .byte.b	<LEVEL__103_Adin
      4  18f7		       f1		      .byte.b	>LEVEL__103_Adin
      5  18f8		       07		      .byte.b	BANK_LEVEL__103_Adin
      6  18f9
      7  18f9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f9					      ADD_LEVEL	_102_Raven
      1  18f9				   LEVEL_ACTIVE__102_Raven SET	1
      2  18f9		       00 f9	   LEVEL_NAMED__102_Raven =	LEVELNUM
      3  18f9		       ec		      .byte.b	<LEVEL__102_Raven
      4  18fa		       f0		      .byte.b	>LEVEL__102_Raven
      5  18fb		       07		      .byte.b	BANK_LEVEL__102_Raven
      6  18fc
      7  18fc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18fc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18fc					      ADD_LEVEL	_102_Oralia
      1  18fc				   LEVEL_ACTIVE__102_Oralia SET	1
      2  18fc		       00 fc	   LEVEL_NAMED__102_Oralia =	LEVELNUM
      3  18fc		       a7		      .byte.b	<LEVEL__102_Oralia
      4  18fd		       f0		      .byte.b	>LEVEL__102_Oralia
      5  18fe		       07		      .byte.b	BANK_LEVEL__102_Oralia
      6  18ff
      7  18ff				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ff				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ff					      ADD_LEVEL	_102_Natalie
      1  18ff				   LEVEL_ACTIVE__102_Natalie SET	1
      2  18ff		       00 ff	   LEVEL_NAMED__102_Natalie =	LEVELNUM
      3  18ff		       00		      .byte.b	<LEVEL__102_Natalie
      4  1900		       f0		      .byte.b	>LEVEL__102_Natalie
      5  1901		       07		      .byte.b	BANK_LEVEL__102_Natalie
      6  1902
      7  1902				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1902				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1902					      ADD_LEVEL	_102_Mirabel
      1  1902				   LEVEL_ACTIVE__102_Mirabel SET	1
      2  1902		       01 02	   LEVEL_NAMED__102_Mirabel =	LEVELNUM
      3  1902		       47		      .byte.b	<LEVEL__102_Mirabel
      4  1903		       f0		      .byte.b	>LEVEL__102_Mirabel
      5  1904		       07		      .byte.b	BANK_LEVEL__102_Mirabel
      6  1905
      7  1905				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1905				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1905					      ADD_LEVEL	_1XJH_Tara_Gelson
      1  1905				   LEVEL_ACTIVE__1XJH_Tara_Gelson SET	1
      2  1905		       01 05	   LEVEL_NAMED__1XJH_Tara_Gelson =	LEVELNUM
      3  1905		       40		      .byte.b	<LEVEL__1XJH_Tara_Gelson
      4  1906		       f2		      .byte.b	>LEVEL__1XJH_Tara_Gelson
      5  1907		       07		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
      6  1908
      7  1908				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1908				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1908					      ADD_LEVEL	_1R7X_Alison
      1  1908				   LEVEL_ACTIVE__1R7X_Alison SET	1
      2  1908		       01 08	   LEVEL_NAMED__1R7X_Alison =	LEVELNUM
      3  1908		       7b		      .byte.b	<LEVEL__1R7X_Alison
      4  1909		       f2		      .byte.b	>LEVEL__1R7X_Alison
      5  190a		       07		      .byte.b	BANK_LEVEL__1R7X_Alison
      6  190b
      7  190b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190b					      ADD_LEVEL	_1KWD_Cecile_Clayworth
      1  190b				   LEVEL_ACTIVE__1KWD_Cecile_Clayworth SET	1
      2  190b		       01 0b	   LEVEL_NAMED__1KWD_Cecile_Clayworth =	LEVELNUM
      3  190b		       a9		      .byte.b	<LEVEL__1KWD_Cecile_Clayworth
      4  190c		       f2		      .byte.b	>LEVEL__1KWD_Cecile_Clayworth
      5  190d		       07		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
      6  190e
      7  190e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190e					      ADD_LEVEL	_1EKT_Samantha_Gelson
      1  190e				   LEVEL_ACTIVE__1EKT_Samantha_Gelson SET	1
      2  190e		       01 0e	   LEVEL_NAMED__1EKT_Samantha_Gelson =	LEVELNUM
      3  190e		       de		      .byte.b	<LEVEL__1EKT_Samantha_Gelson
      4  190f		       f2		      .byte.b	>LEVEL__1EKT_Samantha_Gelson
      5  1910		       07		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
      6  1911
      7  1911				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1911				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1911					      ADD_LEVEL	_0VM5_Andrea_Wadd
      1  1911				   LEVEL_ACTIVE__0VM5_Andrea_Wadd SET	1
      2  1911		       01 11	   LEVEL_NAMED__0VM5_Andrea_Wadd =	LEVELNUM
      3  1911		       18		      .byte.b	<LEVEL__0VM5_Andrea_Wadd
      4  1912		       f3		      .byte.b	>LEVEL__0VM5_Andrea_Wadd
      5  1913		       07		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
      6  1914
      7  1914				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1914				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1914					      ADD_LEVEL	_0PAL_Jill_Leatherby
      1  1914				   LEVEL_ACTIVE__0PAL_Jill_Leatherby SET	1
      2  1914		       01 14	   LEVEL_NAMED__0PAL_Jill_Leatherby =	LEVELNUM
      3  1914		       46		      .byte.b	<LEVEL__0PAL_Jill_Leatherby
      4  1915		       f3		      .byte.b	>LEVEL__0PAL_Jill_Leatherby
      5  1916		       07		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
      6  1917
      7  1917				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1917				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1917					      ADD_LEVEL	_0IZ1_Sophia
      1  1917				   LEVEL_ACTIVE__0IZ1_Sophia SET	1
      2  1917		       01 17	   LEVEL_NAMED__0IZ1_Sophia =	LEVELNUM
      3  1917		       71		      .byte.b	<LEVEL__0IZ1_Sophia
      4  1918		       f3		      .byte.b	>LEVEL__0IZ1_Sophia
      5  1919		       07		      .byte.b	BANK_LEVEL__0IZ1_Sophia
      6  191a
      7  191a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  191a					      ADD_LEVEL	_0CNH_Alice
      1  191a				   LEVEL_ACTIVE__0CNH_Alice SET	1
      2  191a		       01 1a	   LEVEL_NAMED__0CNH_Alice =	LEVELNUM
      3  191a		       9d		      .byte.b	<LEVEL__0CNH_Alice
      4  191b		       f3		      .byte.b	>LEVEL__0CNH_Alice
      5  191c		       07		      .byte.b	BANK_LEVEL__0CNH_Alice
      6  191d
      7  191d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  191d					      ADD_LEVEL	Thomas_Reinke16
      1  191d				   LEVEL_ACTIVE_Thomas_Reinke16 SET	1
      2  191d		       01 1d	   LEVEL_NAMED_Thomas_Reinke16 =	LEVELNUM
      3  191d		       6d		      .byte.b	<LEVEL_Thomas_Reinke16
      4  191e		       f5		      .byte.b	>LEVEL_Thomas_Reinke16
      5  191f		       07		      .byte.b	BANK_LEVEL_Thomas_Reinke16
      6  1920
      7  1920				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1920				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1920					      ADD_LEVEL	bDarcy_Burnsell101
      1  1920				   LEVEL_ACTIVE_bDarcy_Burnsell101 SET	1
      2  1920		       01 20	   LEVEL_NAMED_bDarcy_Burnsell101 =	LEVELNUM
      3  1920		       f3		      .byte.b	<LEVEL_bDarcy_Burnsell101
      4  1921		       f4		      .byte.b	>LEVEL_bDarcy_Burnsell101
      5  1922		       07		      .byte.b	BANK_LEVEL_bDarcy_Burnsell101
      6  1923
      7  1923				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1923				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1923					      ADD_LEVEL	bAlfa_DrFogh
      1  1923				   LEVEL_ACTIVE_bAlfa_DrFogh SET	1
      2  1923		       01 23	   LEVEL_NAMED_bAlfa_DrFogh =	LEVELNUM
      3  1923		       ca		      .byte.b	<LEVEL_bAlfa_DrFogh
      4  1924		       f3		      .byte.b	>LEVEL_bAlfa_DrFogh
      5  1925		       07		      .byte.b	BANK_LEVEL_bAlfa_DrFogh
      6  1926
      7  1926				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1926				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1926					      ADD_LEVEL	bAislin101
      1  1926				   LEVEL_ACTIVE_bAislin101 SET	1
      2  1926		       01 26	   LEVEL_NAMED_bAislin101 =	LEVELNUM
      3  1926		       30		      .byte.b	<LEVEL_bAislin101
      4  1927		       f5		      .byte.b	>LEVEL_bAislin101
      5  1928		       07		      .byte.b	BANK_LEVEL_bAislin101
      6  1929
      7  1929				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1929				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1929					      ADD_LEVEL	b51X_Sharpen
      1  1929				   LEVEL_ACTIVE_b51X_Sharpen SET	1
      2  1929		       01 29	   LEVEL_NAMED_b51X_Sharpen =	LEVELNUM
      3  1929		       72		      .byte.b	<LEVEL_b51X_Sharpen
      4  192a		       f4		      .byte.b	>LEVEL_b51X_Sharpen
      5  192b		       07		      .byte.b	BANK_LEVEL_b51X_Sharpen
      6  192c
      7  192c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  192c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    156  192c							;    ADD_LEVEL b82X_Sharpen
    157  192c
    158  192c
    159  192c				   finX
    160  192c							; now put the soil in - fill from the outsides
    161  192c
    162  192c		       a9 01		      lda	#CHARACTER_SOIL
    163  192e		       85 8e		      sta	POS_Type
    164  1930
    165  1930		       a9 15		      lda	#SIZE_BOARD_Y-1
    166  1932		       85 8b		      sta	POS_Y
    167  1934
    168  1934		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    169  1936		       85 8a		      sta	POS_X
    170  1938		       20 29 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    171  193b		       c9 01		      cmp	#CHARACTER_SOIL
    172  193d		       f0 07		      beq	kg2a
    173  193f		       c9 00		      cmp	#0
    174  1941		       d0 07		      bne	endzap1
    175  1943		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    176  1946		       c6 8a	   kg2a       dec	POS_X
    177  1948		       10 ee		      bpl	zap1
    178  194a
    179  194a		       a9 00	   endzap1    lda	#0
    180  194c		       85 8a		      sta	POS_X
    181  194e		       20 29 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    182  1951		       c9 01		      cmp	#CHARACTER_SOIL
    183  1953		       f0 07		      beq	kg2
    184  1955		       c9 00		      cmp	#0
    185  1957		       d0 0b		      bne	endzap2
    186  1959		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    187  195c		       e6 8a	   kg2	      inc	POS_X
    188  195e		       a5 8a		      lda	POS_X
    189  1960		       c9 28		      cmp	#SIZE_BOARD_X
    190  1962		       d0 ea		      bne	zap2
    191  1964
    192  1964		       c6 8b	   endzap2    dec	POS_Y
    193  1966		       10 cc		      bpl	xlin
    194  1968
    195  1968
    196  1968		       a9 27		      lda	#SIZE_BOARD_X-1
    197  196a		       85 8a		      sta	POS_X
    198  196c
    199  196c		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    200  196e		       85 8b		      sta	POS_Y
    201  1970		       20 29 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    202  1973		       c9 01		      cmp	#CHARACTER_SOIL
    203  1975		       f0 07		      beq	kg3
    204  1977		       c9 00		      cmp	#0
    205  1979		       d0 07		      bne	endzapy1
    206  197b		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    207  197e		       c6 8b	   kg3	      dec	POS_Y
    208  1980		       10 ee		      bpl	zapy1
    209  1982
    210  1982		       a9 00	   endzapy1   lda	#0
    211  1984		       85 8b		      sta	POS_Y
    212  1986		       20 29 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    213  1989		       c9 01		      cmp	#CHARACTER_SOIL
    214  198b		       f0 07		      beq	kg3b
    215  198d		       c9 00		      cmp	#0
    216  198f		       d0 0b		      bne	endzapy2
    217  1991		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    218  1994		       e6 8b	   kg3b       inc	POS_Y
    219  1996		       a5 8b		      lda	POS_Y
    220  1998		       c9 16		      cmp	#SIZE_BOARD_Y
    221  199a		       d0 ea		      bne	zapy2
    222  199c
    223  199c		       c6 8a	   endzapy2   dec	POS_X
    224  199e		       10 cc		      bpl	ylin
    225  19a0		       60		      rts
    226  19a1
      0  19a1					      DEFINE_SUBROUTINE	RegisterOneMoreTarget
      1  19a1		       00 03	   BANK_RegisterOneMoreTarget =	_CURRENT_BANK
      2  19a1					      SUBROUTINE
      3  19a1				   RegisterOneMoreTarget
    228  19a1
    229  19a1		       f8		      sed
    230  19a2		       18		      clc
    231  19a3		       a5 b8		      lda	targetsRequired
    232  19a5		       69 01		      adc	#1
    233  19a7		       85 b8		      sta	targetsRequired
    234  19a9		       d8		      cld
    235  19aa		       60		      rts
    236  19ab
    237  19ab
      0  19ab					      DEFINE_SUBROUTINE	UnpackLevel
      1  19ab		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  19ab					      SUBROUTINE
      3  19ab				   UnpackLevel
    239  19ab
    240  19ab		       85 c3		      sta	RAM_Bank
    241  19ad
    242  19ad							; has to be done before decoding the level to have the platform right:
      0  19ad					      SET_PLATFORM
      1  19ad
      2  19ad
      3  19ad
      4  19ad
      5  19ad		       ad 82 02 	      lda	SWCHB
      6  19b0		       2a		      rol
      7  19b1		       2a		      rol
      8  19b2		       2a		      rol
      9  19b3		       29 03		      and	#%11
     10  19b5					      if	NTSC_MODE = NO
     11  19b5		       49 02		      eor	#PAL
     12  19b7					      endif
     13  19b7		       a9 00		      lda	#0
     14  19b9		       85 81		      sta	Platform
    244  19bb
    245  19bb		       a9 00		      lda	#CHARACTER_BLANK
    246  19bd		       85 8e		      sta	POS_Type
    247  19bf
    248  19bf		       a9 15		      lda	#SIZE_BOARD_Y-1
    249  19c1		       85 8b		      sta	POS_Y
    250  19c3		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    251  19c5		       85 8a		      sta	POS_X
    252  19c7		       20 3d f8    xyClear    jsr	PutBoardCharacterFromRAM
    253  19ca		       c6 8a		      dec	POS_X
    254  19cc		       10 f9		      bpl	xyClear
    255  19ce		       c6 8b		      dec	POS_Y
    256  19d0		       10 f1		      bpl	xyLine
    257  19d2
    258  19d2		       a9 06		      lda	#6
    259  19d4		       85 d8		      sta	base_x
    260  19d6		       85 d9		      sta	base_y
    261  19d8
    262  19d8		       a5 c8		      lda	NextLevelTrigger
    263  19da		       09 80		      ora	#BIT_NEXTLEVEL
    264  19dc		       85 c8		      sta	NextLevelTrigger
    265  19de
    266  19de		       a5 b3		      lda	levelX
    267  19e0		       0a		      asl
    268  19e1		       65 b3		      adc	levelX
    269  19e3		       a8		      tay
    270  19e4		       38		      sec
    271  19e5		       b9 00 f0 	      lda	LevelInformation,y
    272  19e8		       e9 01		      sbc	#1
    273  19ea		       85 be		      sta	Board_AddressR
    274  19ec		       b9 01 f0 	      lda	LevelInformation+1,y
    275  19ef		       e9 00		      sbc	#0
    276  19f1		       85 bf		      sta	Board_AddressR+1
    277  19f3		       b9 02 f0 	      lda	LevelInformation+2,y
    278  19f6		       85 af		      sta	LEVEL_bank
    279  19f8
    280  19f8		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    281  19fa		       85 c2		      sta	ROM_Bank	; GetROMByte returns to this bank
    282  19fc
    283  19fc							;NEXT_RANDOM
    284  19fc							;and #$F0
    285  19fc							;ora #$A
    286  19fc		       a9 8a		      lda	#$8a	;ba
    287  19fe		       85 bb		      sta	color
    288  1a00		       a9 44		      lda	#$44
    289  1a02							;lda #$A0
    290  1a02		       85 bc		      sta	color+1
    291  1a04		       a9 2a		      lda	#$2a	;lda #$9C
    292  1a06		       85 bd		      sta	color+2
    293  1a08
    294  1a08		       a9 00		      lda	#$00
    295  1a0a		       85 b9		      sta	moveCounter
    296  1a0c		       85 ba		      sta	moveCounterHi
    297  1a0e
    298  1a0e		       a9 00		      lda	#$00	; BCD reminder!
    299  1a10		       85 b8		      sta	targetsRequired	; # of targets that do NOT have boxes on them
    300  1a12
    301  1a12							;lda #SIZE_BOARD_X
    302  1a12							;sta BoardLimit_Width
    303  1a12							;lda #SIZE_BOARD_Y
    304  1a12							;sta BoardLimit_Height
    305  1a12							;lda #$5
    306  1a12							;sta targetsRequired		   ;	   should never be 0
    307  1a12
    308  1a12		       a9 18		      lda	#24	; arbitrary
    309  1a14		       85 b7		      sta	ThrottleSpeed
    310  1a16
    311  1a16							; first fill bg with character_soil
    312  1a16							; then rle unpack level
    313  1a16							; change level colours
    314  1a16
    315  1a16		       a9 00		      lda	#0
    316  1a18		       85 8a		      sta	POS_X
    317  1a1a		       85 8b		      sta	POS_Y
    318  1a1c		       85 94		      sta	BoardLimit_Width
    319  1a1e		       85 95		      sta	BoardLimit_Height
    320  1a20
    321  1a20				   GetNextItem
    322  1a20
    323  1a20		       a9 01		      lda	#1
    324  1a22		       85 da		      sta	upk_length
    325  1a24		       a9 00		      lda	#0
    326  1a26		       85 db		      sta	upk_column	; reuse var - this flags a digit already
    327  1a28
    328  1a28		       e6 be	   Get2       inc	Board_AddressR
    329  1a2a		       d0 02		      bne	addrOK
    330  1a2c		       e6 bf		      inc	Board_AddressR+1
    331  1a2e				   addrOK
    332  1a2e
    333  1a2e		       a5 af		      lda	LEVEL_bank
    334  1a30		       a0 00		      ldy	#0
    335  1a32		       20 12 f8 	      jsr	GetROMByte
    336  1a35		       85 dc		      sta	upk_temp	;scratch
    337  1a37
    338  1a37
    339  1a37		       c9 00		      cmp	#0
    340  1a39		       d0 03		      bne	parse
    341  1a3b		       4c 2c f1 	      jmp	finX
    342  1a3e				   parse
    343  1a3e		       c9 3a		      cmp	#"9"+1
    344  1a40		       b0 1e		      bcs	notDigit
    345  1a42		       c9 30		      cmp	#"0"
    346  1a44		       90 1a		      bcc	notDigit
    347  1a46
    348  1a46		       a5 db		      lda	upk_column
    349  1a48		       f0 09		      beq	firstDig
    350  1a4a
    351  1a4a		       a5 da		      lda	upk_length
    352  1a4c		       0a		      asl
    353  1a4d		       0a		      asl
    354  1a4e		       0a		      asl
    355  1a4f		       65 da		      adc	upk_length
    356  1a51		       65 da		      adc	upk_length
    357  1a53
    358  1a53		       18	   firstDig   clc
    359  1a54		       65 dc		      adc	upk_temp
    360  1a56		       38		      sec
    361  1a57		       e9 30		      sbc	#"0"
    362  1a59		       85 da		      sta	upk_length
    363  1a5b		       e6 db		      inc	upk_column	; flag we have seen a digit
    364  1a5d		       4c 28 f2 	      jmp	Get2
    365  1a60
    366  1a60		       c9 7c	   notDigit   cmp	#"|"	; newline
    367  1a62		       d0 11		      bne	checkWall
    368  1a64
    369  1a64							; Handle new-line
    370  1a64		       a9 00		      lda	#0
    371  1a66		       85 8a		      sta	POS_X
    372  1a68		       e6 8b		      inc	POS_Y
    373  1a6a
    374  1a6a
    375  1a6a		       a5 8b		      lda	POS_Y
    376  1a6c		       c5 95		      cmp	BoardLimit_Height
    377  1a6e		       90 02		      bcc	wOK2
    378  1a70		       85 95		      sta	BoardLimit_Height	;???^^^
    379  1a72				   wOK2
    380  1a72
    381  1a72		       4c 20 f2 	      jmp	GetNextItem
    382  1a75
    383  1a75		       c9 23	   checkWall  cmp	#"#"	; wall
    384  1a77		       d0 04		      bne	checkForGap
    385  1a79		       a9 07		      lda	#CHARACTER_WALL
    386  1a7b		       d0 66		      bne	WriteChars
    387  1a7d
    388  1a7d		       c9 20	   checkForGap cmp	#32
    389  1a7f		       f0 08		      beq	writeGap
    390  1a81		       c9 2d		      cmp	#"-"
    391  1a83		       f0 04		      beq	writeGap
    392  1a85		       c9 5f		      cmp	#"_"
    393  1a87		       d0 05		      bne	checkForMan
    394  1a89
    395  1a89		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    396  1a8b		       4c e3 f2 	      jmp	WriteChars
    397  1a8e
    398  1a8e				   checkForMan
    399  1a8e		       c9 2b		      cmp	#"+"	; player on goal square
    400  1a90		       d0 07		      bne	notPlayerGoal
    401  1a92
    402  1a92		       20 a1 f1 	      jsr	RegisterOneMoreTarget
    403  1a95
    404  1a95							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    405  1a95
    406  1a95		       a9 03		      lda	#CHARACTER_TARGET
    407  1a97		       d0 06		      bne	genPlayer
    408  1a99
    409  1a99				   notPlayerGoal
    410  1a99		       c9 40		      cmp	#"@"	; player on normal square
    411  1a9b		       d0 2d		      bne	checkBox
    412  1a9d
    413  1a9d		       a9 00		      lda	#CHARACTER_BLANK
    414  1a9f
    415  1a9f				   genPlayer
    416  1a9f
    417  1a9f		       85 8f		      sta	POS_VAR	; character man is on
    418  1aa1
    419  1aa1		       18		      clc
    420  1aa2		       a5 8a		      lda	POS_X
    421  1aa4		       48		      pha
    422  1aa5		       65 d8		      adc	base_x
    423  1aa7		       85 8a		      sta	POS_X
    424  1aa9		       85 9b		      sta	ManX
    425  1aab
    426  1aab		       a5 8b		      lda	POS_Y
    427  1aad		       48		      pha
    428  1aae		       65 d9		      adc	base_y
    429  1ab0		       85 8b		      sta	POS_Y
    430  1ab2		       85 9c		      sta	ManY
    431  1ab4
    432  1ab4							; POS_X     x position
    433  1ab4							; POS_Y     y position
    434  1ab4							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    435  1ab4							; POS_Type  type of object
    436  1ab4
    437  1ab4		       a9 00		      lda	#TYPE_MAN
    438  1ab6		       85 8e		      sta	POS_Type	;	 creature TYPE
    439  1ab8		       20 8c f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    440  1abb
    441  1abb		       a9 00		      lda	#0
    442  1abd		       85 9a		      sta	manAnimationIndex
    443  1abf
    444  1abf		       68		      pla
    445  1ac0		       85 8b		      sta	POS_Y
    446  1ac2		       68		      pla
    447  1ac3		       85 8a		      sta	POS_X
    448  1ac5
    449  1ac5		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    450  1ac7		       4c e3 f2 	      jmp	WriteChars
    451  1aca
    452  1aca		       c9 24	   checkBox   cmp	#"$"
    453  1acc		       d0 04		      bne	checkBoxTarget
    454  1ace
    455  1ace		       a9 02		      lda	#CHARACTER_BOX
    456  1ad0		       d0 11		      bne	WriteChars
    457  1ad2
    458  1ad2		       c9 2a	   checkBoxTarget cmp	#"*"
    459  1ad4		       d0 04		      bne	checkTarget
    460  1ad6
    461  1ad6		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    462  1ad8		       d0 09		      bne	WriteChars
    463  1ada
    464  1ada		       c9 2e	   checkTarget cmp	#"."
    465  1adc		       f0 03		      beq	targ
    466  1ade		       4c 20 f2 	      jmp	GetNextItem
    467  1ae1				   targ
    468  1ae1
    469  1ae1		       a9 03		      lda	#CHARACTER_TARGET
    470  1ae3
    471  1ae3		       85 8e	   WriteChars sta	POS_Type
    472  1ae5
    473  1ae5		       18	   Wc2x       clc
    474  1ae6		       a5 8a		      lda	POS_X
    475  1ae8		       48		      pha
    476  1ae9		       65 d8		      adc	base_x
    477  1aeb		       85 8a		      sta	POS_X
    478  1aed
    479  1aed		       a5 8b		      lda	POS_Y
    480  1aef		       48		      pha
    481  1af0		       65 d9		      adc	base_y
    482  1af2		       85 8b		      sta	POS_Y
    483  1af4
    484  1af4		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    485  1af7
    486  1af7		       a5 8e		      lda	POS_Type
    487  1af9		       c9 03		      cmp	#CHARACTER_TARGET
    488  1afb		       d0 03		      bne	notargdet
    489  1afd		       20 a1 f1 	      jsr	RegisterOneMoreTarget
    490  1b00				   notargdet
    491  1b00
    492  1b00		       68		      pla
    493  1b01		       85 8b		      sta	POS_Y
    494  1b03		       68		      pla
    495  1b04		       85 8a		      sta	POS_X
    496  1b06
    497  1b06		       18		      clc
    498  1b07		       69 01		      adc	#1
    499  1b09		       85 8a		      sta	POS_X
    500  1b0b
    501  1b0b		       c5 94		      cmp	BoardLimit_Width
    502  1b0d		       90 02		      bcc	wOK
    503  1b0f		       85 94		      sta	BoardLimit_Width
    504  1b11				   wOK
    505  1b11
    506  1b11		       c6 da		      dec	upk_length
    507  1b13		       d0 d0		      bne	Wc2x
    508  1b15		       4c 20 f2 	      jmp	GetNextItem
    509  1b18
    510  1b18				   finishedUnpack
    511  1b18
    512  1b18		       60		      rts
    513  1b18					      endif
------- FILE BANK_GENERIC.asm
     44  1b19
      0  1b19					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1b19
      2  1b19
      3  1b19		       03 19	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $319 , FREE= $e7
      4  1b19					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1b19				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1b19				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1b19				  -	      ERR
      8  1b19					      endif
     46  1b19
     47  1b19							;------------------------------------------------------------------------------
     48  1b19							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1b19							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1b19							; bank finishes.  Just continue on from where it left off...
     51  1b19							;------------------------------------------------------------------------------
     52  1b19
      0  1b19					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1b19		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1b19					      SUBROUTINE
      3  1b19				   Cart_Init
     54  1b19
     55  1b19							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1b19							; at any time.  So they need to be used immediately.
     57  1b19
     58  1b19
     59  1b19							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1b19
     61  1b19		       a9 01		      lda	#1
     62  1b1b		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1b1d		       a0 00		      ldy	#0	;sJoysticks
     64  1b1f		       84 a8		      sty	jtoggle
     65  1b21		       86 b4		      stx	level
     66  1b23		       85 a7		      sta	ManCount	; = #players
     67  1b25		       a9 00		      lda	#0
     68  1b27		       85 b3		      sta	levelX	; make an immediate copy to safe variables!
     69  1b29		       85 de		      sta	startingLevel
     70  1b2b
     71  1b2b							; multiply with LEVEL_DEFINITION_SIZE (5):
     72  1b2b		       0a		      asl
     73  1b2c		       0a		      asl
     74  1b2d		       85 b3		      sta	levelX
     75  1b2f
     76  1b2f		       a9 01		      lda	#1
     77  1b31		       85 99		      sta	whichPlayer	; will switch to 0 on 1st go
     78  1b33
     79  1b33		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     80  1b35		       a6 a7		      ldx	ManCount	; = sPlayers
     81  1b37		       f0 02		      beq	opg
     82  1b39		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     83  1b3b		       85 a7	   opg	      sta	ManCount	; P2P1 nybble each
     84  1b3d
     85  1b3d							;---------------------------------------------------------------------------
     86  1b3d
     87  1b3d		       a9 00		      lda	#0
     88  1b3f		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     89  1b42		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     90  1b45		       85 6b		      sta	HMCLR
     91  1b47
     92  1b47							; cleanup remains of title screen
     93  1b47		       85 5b		      sta	GRP0
     94  1b49		       85 5c		      sta	GRP1
     95  1b4b		       85 5b		      sta	GRP0
     96  1b4d
     97  1b4d		       85 89		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     98  1b4f		       85 a9		      sta	circle_d
     99  1b51		       85 aa		      sta	circle_d+1
    100  1b53
    101  1b53							;    IFCONST DEBUG_CREATURE
    102  1b53							;		  sta worstTime
    103  1b53							;    ENDIF
    104  1b53
    105  1b53		       a9 04		      lda	#%100	; players/missiles BEHIND BG
    106  1b55		       85 4a		      sta	CTRLPF
    107  1b57		       85 82		      sta	rnd	; anything non-0
    108  1b59
    109  1b59		       a9 ff		      lda	#$FF
    110  1b5b		       85 84		      sta	DrawStackPointer
    111  1b5d		       85 92		      sta	BufferedButton
    112  1b5f		       85 93		      sta	BufferedButton+1
    113  1b61
    114  1b61		       a9 07		      lda	#DIRECTION_BITS
    115  1b63		       85 a4		      sta	ManLastDirection
    116  1b65
    117  1b65		       a9 00		      lda	#0
    118  1b67							;		  sta ObjStackPtr		  ; object stack index of last entry
    119  1b67							;		  sta ObjStackPtr+1
    120  1b67							;		  sta ObjStackNum
    121  1b67							;		  sta ObjIterator
    122  1b67
    123  1b67		       85 ca		      sta	sortPtr
    124  1b69		       a9 ff		      lda	#<(-1)
    125  1b6b		       85 c9		      sta	sortRequired
    126  1b6d
    127  1b6d							; read high score from SaveKey and store in highScoreSK,
    128  1b6d							; which is transferred to high score variable in RAM by GeneralScoringSetups
    129  1b6d		       4c d6 f5 	      jmp	ReadSaveKey
    130  1b70
    131  1b70							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    132  1b70							;		  .byte -1
    133  1b70
    134  1b70							;------------------------------------------------------------------------------
    135  1b70
      0  1b70					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1b70		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1b70					      SUBROUTINE
      3  1b70				   SwapPlayersGeneric
    137  1b70
    138  1b70							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    139  1b70							; into the gameMode variable.
    140  1b70
    141  1b70		       a5 80		      lda	gameMode
    142  1b72		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    143  1b74		       85 80		      sta	gameMode
    144  1b76		       ad 82 02 	      lda	SWCHB
    145  1b79		       29 08		      and	#BW_SWITCH
    146  1b7b		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    147  1b7d		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    148  1b7f
    149  1b7f
    150  1b7f							; restart level
    151  1b7f		       a5 c8		      lda	NextLevelTrigger
    152  1b81		       29 bf		      and	#<(~BIT_NEXTLIFE)
    153  1b83		       85 c8		      sta	NextLevelTrigger
    154  1b85
    155  1b85							; if new high score was set by SwapPlayers, update it:
    156  1b85
    157  1b85		       4c fc f5 	      jmp	WriteSaveKey
    158  1b88
    159  1b88
    160  1b88							;------------------------------------------------------------------------------
    161  1b88
      0  1b88					      DEFINE_SUBROUTINE	CreateCreatures
      1  1b88		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1b88					      SUBROUTINE
      3  1b88				   CreateCreatures
    163  1b88
    164  1b88							; Calculate rightmost value for scrolling edge.  .
    165  1b88
    166  1b88		       85 c2		      sta	ROM_Bank
    167  1b8a
    168  1b8a		       38		      sec
    169  1b8b		       a5 94		      lda	BoardLimit_Width
    170  1b8d		       e9 09		      sbc	#SCREEN_WIDTH-1
    171  1b8f		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    172  1b91
    173  1b91							;		  sec			     already set
    174  1b91		       a5 95		      lda	BoardLimit_Height
    175  1b93		       e9 07		      sbc	#SCREEN_LINES-1
    176  1b95		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    177  1b97
    178  1b97							; kludge position scroll roughly at player
    179  1b97
    180  1b97							;		  sec			 already set
    181  1b97		       a5 9b		      lda	ManX
    182  1b99		       e9 05		      sbc	#5
    183  1b9b		       b0 02		      bcs	notL0
    184  1b9d		       a9 00		      lda	#0
    185  1b9f		       85 97	   notL0      sta	BoardScrollX
    186  1ba1
    187  1ba1
    188  1ba1		       38		      sec
    189  1ba2		       a5 9c		      lda	ManY
    190  1ba4		       e9 05		      sbc	#5	; TJ: why 5???
    191  1ba6		       b0 02		      bcs	notU0
    192  1ba8		       a9 00		      lda	#0
    193  1baa		       85 96	   notU0      sta	BoardScrollY
    194  1bac
    195  1bac		       a9 00		      lda	#0
    196  1bae		       85 9f		      sta	ManMode
    197  1bb0		       85 a0		      sta	ManDelayCount
    198  1bb2
    199  1bb2		       a9 1a		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    200  1bb4		       85 a1		      sta	ManAnimation
    201  1bb6							;lda #>AnimateBLANK ;
    202  1bb6							;sta ManAnimation+1
    203  1bb6
    204  1bb6		       a9 ff		      lda	#$FF
    205  1bb8		       85 b0		      sta	LastSpriteY
    206  1bba
    207  1bba		       a9 07		      lda	#DIRECTION_BITS
    208  1bbc		       85 a4		      sta	ManLastDirection
    209  1bbe		       60		      rts
    210  1bbf
    211  1bbf							;-------------------------------------------------------------------------------------
    212  1bbf
      0  1bbf					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1bbf		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1bbf					      SUBROUTINE
      3  1bbf				   LevelInit
    214  1bbf
    215  1bbf		       a9 00		      lda	#0
    216  1bc1		       85 86		      sta	ObjStackPtr
    217  1bc3		       85 87		      sta	ObjStackPtr+1	; kill all creatures
    218  1bc5		       85 85		      sta	ObjStackNum
    219  1bc7		       85 cb		      sta	ObjIterator
    220  1bc9
    221  1bc9		       85 98		      sta	scrollBits
    222  1bcb		       85 89		      sta	ScreenDrawPhase
    223  1bcd
    224  1bcd		       85 b2		      sta	BGColour
    225  1bcf		       85 c4		      sta	ColourTimer
    226  1bd1
    227  1bd1		       85 59		      sta	AUDV0
    228  1bd3		       85 5a		      sta	AUDV1	; turn off music while levels init
    229  1bd5							;		  sta AUDC0
    230  1bd5
    231  1bd5		       85 a4		      sta	ManLastDirection
    232  1bd7		       85 a5		      sta	ManPushCounter
    233  1bd9
    234  1bd9		       85 ca		      sta	sortPtr	; sort stopped
    235  1bdb		       a9 ff		      lda	#<(-1)
    236  1bdd		       85 c9		      sta	sortRequired	; nothing needed
    237  1bdf		       85 84		      sta	DrawStackPointer
    238  1be1
    239  1be1		       a9 02		      lda	#DISPLAY_LIVES
    240  1be3		       85 c7		      sta	scoringFlags
    241  1be5		       a9 96		      lda	#SCORING_TIMER_FIRST	; We want the first timer display to be long, to show level and lives
    242  1be7		       85 c6		      sta	scoringTimer
    243  1be9		       60		      rts
    244  1bea
    245  1bea							;-------------------------------------------------------------------------------------
    246  1bea
      0  1bea					      DEFINE_SUBROUTINE	Resync
      1  1bea		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1bea					      SUBROUTINE
      3  1bea				   Resync
      0  1bea					      RESYNC
      1  1bea
      2  1bea		       a9 02		      lda	#%10
      3  1bec		       85 41		      sta	VBLANK
      4  1bee
      5  1bee		       a2 08		      ldx	#8
      6  1bf0				   .loopResync
      0  1bf0					      VERTICAL_SYNC
      1  1bf0		       a9 0e		      lda	#%1110
      2  1bf2		       85 42	   .VSLP1     sta	WSYNC
      3  1bf4		       85 40		      sta	VSYNC
      4  1bf6		       4a		      lsr
      5  1bf7		       d0 f9		      bne	.VSLP1
      8  1bf9
      9  1bf9		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1bfb		       a5 81		      lda	Platform
     11  1bfd		       49 02		      eor	#PAL_50
     12  1bff		       d0 02		      bne	.ntsc
     13  1c01		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1c03				   .ntsc
     15  1c03				   .loopWait
     16  1c03		       85 42		      sta	WSYNC
     17  1c05		       85 42		      sta	WSYNC
     18  1c07		       88		      dey
     19  1c08		       d0 f9		      bne	.loopWait
     20  1c0a		       ca		      dex
     21  1c0b		       d0 e3		      bne	.loopResync
    249  1c0d		       60	   Ret	      rts
    250  1c0e
    251  1c0e							;---------------------------------------------------------------------------
    252  1c0e
      0  1c0e					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1c0e		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1c0e					      SUBROUTINE
      3  1c0e				   TrackPlayer
    254  1c0e
    255  1c0e		       a5 a6		      lda	LookingAround	; 3
    256  1c10		       30 fb		      bmi	Ret	; 2/3=5/6   don't track when looking around
    257  1c12
    258  1c12							; Contribution by Thomas Jentzsch
    259  1c12
    260  1c12							; scrolling constants:
    261  1c12		       00 03	   .SCRL_START_LEFT =	3	; 3
    262  1c12		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    263  1c12		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    264  1c12		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    265  1c12		       00 11	   .SCRL_LEFT_BIT =	%00010001
    266  1c12		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    267  1c12		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    268  1c12
    269  1c12		       00 02	   .SCRL_START_UP =	2	; 2
    270  1c12		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    271  1c12		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    272  1c12		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    273  1c12		       00 44	   .SCRL_UP_BIT =	%01000100
    274  1c12		       00 88	   .SCRL_DOWN_BIT =	%10001000
    275  1c12		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    276  1c12
    277  1c12							; *** horizontal scrolling (unoptimized version): ***
    278  1c12
    279  1c12							; check for enabling horizontal scrolling:
    280  1c12		       a5 9b		      lda	ManX	; 3
    281  1c14		       38		      sec		; 2
    282  1c15		       e5 97		      sbc	BoardScrollX	; 3
    283  1c17		       a8		      tay		; 2	     for later use
    284  1c18		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    285  1c1a		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    286  1c1c		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    287  1c1e		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    288  1c20		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    289  1c22		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    290  1c24				   .startXScroll
    291  1c24		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    292  1c26		       05 98		      ora	scrollBits	; 3
    293  1c28		       85 98		      sta	scrollBits	; 3 =	8
    294  1c2a				   .skipStartXScroll
    295  1c2a
    296  1c2a							; do horizontal scrolling:
    297  1c2a		       a5 98		      lda	scrollBits	; 3
    298  1c2c		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    299  1c2e		       f0 23		      beq	.skipXScroll	; 2/3
    300  1c30		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    301  1c32		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    302  1c34
    303  1c34							; scroll left:
    304  1c34		       a5 97		      lda	BoardScrollX	; 3	     already at left edge?
    305  1c36		       f0 15		      beq	.stopXScroll	; 2
    306  1c38		       c6 97		      dec	BoardScrollX	; 5
    307  1c3a		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    308  1c3c		       10 0f		      bpl	.stopXScroll	; 2/3=15
    309  1c3e		       30 13		      bmi	.skipXScroll	; 3
    310  1c40							;---------------------------------------
    311  1c40				   .xScrollRight
    312  1c40		       a6 97		      ldx	BoardScrollX	; 3
    313  1c42		       e8		      inx		; 2
    314  1c43		       e4 94		      cpx	BoardEdge_Right	; 3	     already at right edge?
    315  1c45		       10 06		      bpl	.stopXScroll	; 2/3
    316  1c47		       86 97		      stx	BoardScrollX	; 3
    317  1c49		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    318  1c4b		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    319  1c4d				   .stopXScroll
    320  1c4d		       a5 98		      lda	scrollBits	; 3
    321  1c4f		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    322  1c51		       85 98		      sta	scrollBits	; 3 =	8
    323  1c53				   .skipXScroll
    324  1c53							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    325  1c53
    326  1c53							; *** vertical scrolling (unoptimized version): ***
    327  1c53
    328  1c53							; check for enabling vertical scrolling:
    329  1c53		       a5 9c		      lda	ManY	; 3
    330  1c55		       38		      sec		; 2
    331  1c56		       e5 96		      sbc	BoardScrollY	; 3
    332  1c58		       a8		      tay		; 2	     for later use
    333  1c59		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    334  1c5b		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    335  1c5d		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    336  1c5f		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    337  1c61		       30 08		      bmi	.skipStartYScroll	; 2/3
    338  1c63		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    339  1c65				   .startYScroll
    340  1c65		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    341  1c67		       05 98		      ora	scrollBits	; 3
    342  1c69		       85 98		      sta	scrollBits	; 3 =	8
    343  1c6b				   .skipStartYScroll
    344  1c6b
    345  1c6b							; do vertical scrolling:
    346  1c6b		       a5 98		      lda	scrollBits	; 3
    347  1c6d		       29 cc		      and	#.SCRL_Y_BITS	; 2
    348  1c6f		       f0 23		      beq	.skipYScroll	; 2/3
    349  1c71		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    350  1c73		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    351  1c75
    352  1c75							; scroll up
    353  1c75		       a5 96		      lda	BoardScrollY	; 3
    354  1c77		       f0 15		      beq	.stopYScroll	; 2
    355  1c79		       c6 96		      dec	BoardScrollY	; 5
    356  1c7b		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    357  1c7d		       10 0f		      bpl	.stopYScroll	; 2/3=15
    358  1c7f		       30 13		      bmi	.skipYScroll	; 3
    359  1c81							;---------------------------------------
    360  1c81				   .yScrollDown
    361  1c81		       a6 96		      ldx	BoardScrollY	; 3
    362  1c83		       e8		      inx		; 2
    363  1c84		       e4 95		      cpx	BoardEdge_Bottom	;     ; 3
    364  1c86		       10 06		      bpl	.stopYScroll	; 2/3
    365  1c88		       86 96		      stx	BoardScrollY	; 3
    366  1c8a		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    367  1c8c		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    368  1c8e				   .stopYScroll
    369  1c8e		       a5 98		      lda	scrollBits	; 3
    370  1c90		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    371  1c92		       85 98		      sta	scrollBits	; 3 =	8
    372  1c94				   .skipYScroll
    373  1c94							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    374  1c94
    375  1c94		       60	   EarlyAbortx rts		; 6 =	6
    376  1c95							; total: 5+67*2+6 = 145
    377  1c95
    378  1c95							;------------------------------------------------------------------------------
    379  1c95
    380  1c95
    381  1c95
    382  1c95							; worst case time from positive last check to rts: 123
    383  1c95							; cycles until 0-check: 15
    384  1c95							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    385  1c95							; MINIMUM_SORT_TIME = 3 = 129
    386  1c95							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    387  1c95
    388  1c95							;------------------------------------------------------------------------------
    389  1c95
    390  1c95							; This is a GOOD home for these tables.
    391  1c95
      0  1c95					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1c95		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1c95					      SUBROUTINE
      3  1c95				   TS_PhaseVectorLO
    393  1c95
    394  1c95							; Gives LO byte of addresses of subroutines for timeslice processing
    395  1c95
    396  1c95		       53		      .byte.b	<ProcessObjStack
    397  1c96		       d8		      .byte.b	<DrawFullScreen
    398  1c97		       b4		      .byte.b	<BuildDrawStack
    399  1c98		       bb		      .byte.b	<DrawAIntoStack
    400  1c99		       96		      .byte.b	<SwitchObjects
    401  1c9a
    402  1c9a				   TS_PhaseVectorHI
    403  1c9a
    404  1c9a							; Gives HI byte of addresses of subroutines for timeslice processing
    405  1c9a
    406  1c9a		       f8		      .byte.b	>ProcessObjStack
    407  1c9b		       f2		      .byte.b	>DrawFullScreen
    408  1c9c		       fa		      .byte.b	>BuildDrawStack
    409  1c9d		       fa		      .byte.b	>DrawAIntoStack
    410  1c9e		       f8		      .byte.b	>SwitchObjects
    411  1c9f
    412  1c9f				   TS_PhaseBank
    413  1c9f
    414  1c9f							; Gives bank of subroutines for timeslice processing
    415  1c9f
    416  1c9f		       0f		      .byte.b	BANK_ProcessObjStack
    417  1ca0		       08		      .byte.b	BANK_DrawFullScreen
    418  1ca1		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    419  1ca2		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    420  1ca3		       0f		      .byte.b	BANK_SwitchObjects
    421  1ca4
    422  1ca4							;------------------------------------------------------------------------------
    423  1ca4		       02 02	   lookColour2 .byte.b	$02, $02
    424  1ca6		       04 04		      .byte.b	$04, $04
    425  1ca8
    426  1ca8				   OverscanTime
    427  1ca8		       33 33		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    428  1caa		       46 33		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    429  1cac
    430  1cac
    431  1cac
    432  1cac
      0  1cac					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1cac		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1cac					      SUBROUTINE
      3  1cac				   PostScreenCleanup
    434  1cac
    435  1cac		       c8		      iny		; --> 0
    436  1cad
    437  1cad		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    438  1caf							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    439  1caf
    440  1caf		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    441  1cb1							; TJ: no idea why, but you had removed it in revision 758 ;)
    442  1cb1							; completely accidental -- one of our cats may have deleted it.
    443  1cb1		       84 4e		      sty	PF1
    444  1cb3		       84 4f		      sty	PF2
    445  1cb5		       84 5d		      sty	ENAM0
    446  1cb7		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    447  1cb9		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    448  1cbb
    449  1cbb
    450  1cbb
    451  1cbb							; D1 VBLANK turns off beam
    452  1cbb							; It needs to be turned on 37 scanlines later
    453  1cbb
    454  1cbb		       a9 42		      lda	#%01000010	; bit6 is not required
    455  1cbd		       85 41		      sta	VBLANK	; end of screen - enter blanking
    456  1cbf
    457  1cbf							;------------------------------------------------------------------------------
    458  1cbf							; This is where the PAL system has a bit of extra time on a per-frame basis.
    459  1cbf
    460  1cbf		       a6 81		      ldx	Platform
    461  1cc1		       bd a8 f4 	      lda	OverscanTime,x
    462  1cc4		       8d 96 02 	      sta	TIM64T
    463  1cc7
    464  1cc7							; Background colour priorities. Increasing order of priority...
    465  1cc7							;	black -- nothing happening
    466  1cc7							;	looking around			     lookingAround<0		     BLUE
    467  1cc7							;	when paused			     gameMode... BIT7		     RED
    468  1cc7							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    469  1cc7
    470  1cc7
    471  1cc7							;		  lda LookingAround
    472  1cc7							;		  bpl nolooker			  ; if not looking around, that will do nicely
    473  1cc7							;		  ldy #0 ;sok
    474  1cc7							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    475  1cc7							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    476  1cc7
    477  1cc7		       a5 b7		      lda	ThrottleSpeed
    478  1cc9		       18		      clc
    479  1cca		       65 b6		      adc	Throttle
    480  1ccc		       b0 02		      bcs	noVerflo
    481  1cce		       85 b6		      sta	Throttle
    482  1cd0				   noVerflo
    483  1cd0
    484  1cd0
    485  1cd0							;----------------------------------------------------------------------------------------------
    486  1cd0							; handle pause button for 2600 and 7800
    487  1cd0
    488  1cd0							; Timings:  NOT including palette setting or platform detect
    489  1cd0							; 2600:     no button press:	 11 cycles
    490  1cd0							;	     with button press:  21 cycles
    491  1cd0							; 7800      no button press:	 16 cycles
    492  1cd0							;	     with button press:  21 cycles
    493  1cd0
    494  1cd0
    495  1cd0
    496  1cd0		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    497  1cd0
    498  1cd0		       24 80		      bit	gameMode
    499  1cd2		       50 0b		      bvc	.pause7800	; 7800 platform
    500  1cd4
    501  1cd4							; 2600 pause logic...
    502  1cd4
    503  1cd4		       ad 82 02 	      lda	SWCHB
    504  1cd7		       45 80		      eor	gameMode
    505  1cd9		       29 08		      and	#BW_SWITCH
    506  1cdb		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    507  1cdd		       d0 0f		      bne	.buttonDown	; unconditional
    508  1cdf
    509  1cdf							; 7800 pause logic...
    510  1cdf
    511  1cdf							; When the button is pressed, we check if it's the FIRST time it's pressed.
    512  1cdf							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    513  1cdf							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    514  1cdf							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    515  1cdf							; is next pressed.
    516  1cdf
    517  1cdf		       a9 08	   .pause7800 lda	#BW_SWITCH
    518  1ce1		       2c 82 02 	      bit	SWCHB
    519  1ce4		       f0 04		      beq	.pausePress
    520  1ce6		       05 80		      ora	gameMode	; not pressed, so enable first time press
    521  1ce8		       d0 08		      bne	.fixPause	; unconditional
    522  1cea
    523  1cea		       24 80	   .pausePress bit	gameMode
    524  1cec		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    525  1cee
    526  1cee							; Button is down, and we have detected it as a FIRST-TIME button press.
    527  1cee
    528  1cee		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    529  1cf0		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    530  1cf2		       85 80	   .fixPause  sta	gameMode
    531  1cf4
    532  1cf4		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    533  1cf6		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    534  1cf8
    535  1cf8		       a6 81		      ldx	Platform
    536  1cfa		       bd 67 f5 	      lda	pscol,x
    537  1cfd		       85 b2		      sta	BGColour	; set main screen background colour.  RED is paused.
    538  1cff
    539  1cff				   .exitPause
    540  1cff
    541  1cff							;----------------------------------------------------------------------------------------------
    542  1cff
    543  1cff							; has to be done AFTER screen display, because it disables the effect!
    544  1cff		       a5 82		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    545  1d01		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    546  1d03
    547  1d03							; "Flash" has highest BG colour priority
    548  1d03
    549  1d03		       a6 c4		      ldx	ColourTimer
    550  1d05		       f0 04		      beq	noFlashBG
    551  1d07		       c6 c4		      dec	ColourTimer
    552  1d09		       a2 0e		      ldx	#WHITE
    553  1d0b		       86 b2	   noFlashBG  stx	BGColour
    554  1d0d
    555  1d0d							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    556  1d0d							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    557  1d0d
    558  1d0d		       a5 90		      lda	BufferedJoystick	; previous frame
    559  1d0f		       85 91		      sta	BufferedJoystick+1	; -> buffered
    560  1d11
    561  1d11
    562  1d11							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    563  1d11							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    564  1d11
    565  1d11		       a5 99		      lda	whichPlayer	; 3
    566  1d13		       25 a8		      and	jtoggle	; 3
    567  1d15		       aa		      tax		; 2
    568  1d16
    569  1d16		       b5 4c		      lda	INPT4,x	; 4
    570  1d18		       25 92		      and	BufferedButton
    571  1d1a		       85 92		      sta	BufferedButton	; 3 = 15
    572  1d1c
    573  1d1c		       ad 80 02 	      lda	SWCHA	; 4
    574  1d1f
    575  1d1f		       ca		      dex		; 2
    576  1d20		       30 04		      bmi	notP2	; 2/3= 8/9
    577  1d22
    578  1d22		       0a		      asl		; 2
    579  1d23		       0a		      asl		; 2
    580  1d24		       0a		      asl		; 2
    581  1d25		       0a		      asl		; 2 =	8
    582  1d26		       85 90	   notP2      sta	BufferedJoystick	; 3
    583  1d28
    584  1d28
    585  1d28							; "Scoring timer" reset stomp comment
    586  1d28
    587  1d28		       a5 c6		      lda	scoringTimer
    588  1d2a		       f0 0a		      beq	timer0now
    589  1d2c		       c6 c6		      dec	scoringTimer
    590  1d2e		       d0 06		      bne	timer0now
    591  1d30		       a5 c7		      lda	scoringFlags
    592  1d32		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    593  1d34		       85 c7		      sta	scoringFlags
    594  1d36				   timer0now
    595  1d36
    596  1d36							; fall through
    597  1d36
    598  1d36							;-------------------------------------------------------------------------------------
    599  1d36							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    600  1d36							; the player animation consists of running a small animation 'program', and then actually drawing
    601  1d36							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    602  1d36							; inside the actual draw kernel in the appropriate bank.
    603  1d36
    604  1d36
      0  1d36					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  1d36		       00 03	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  1d36					      SUBROUTINE
      3  1d36				   AnimatePlayers
    606  1d36
    607  1d36							; Optimised 7/1/2012 -- single page tables
    608  1d36
    609  1d36							; This interesting code performs the animations for the player(s) and sets the
    610  1d36							; pointers INSIDE the row bank for the draw code to point to the correct player
    611  1d36							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    612  1d36
    613  1d36
    614  1d36							; Cycle the player through his animation list.  The animation of a player is a direct
    615  1d36							; pointer to the actual shape used to display the player.  This shape is in turn
    616  1d36							; written to the current bank's self-modifying locations for the draw.  Since
    617  1d36							; we are effectively drawing from this current bank, the same code can be used
    618  1d36							; to 'undraw' the player as required.
    619  1d36
    620  1d36
    621  1d36							; x = player index
    622  1d36							; sets ManAnimation = FRAME to display for player
    623  1d36							; ManAnimation = index of player program into Manimate list
    624  1d36
    625  1d36		       24 80		      bit	gameMode
    626  1d38		       30 2c		      bmi	AnimationOK	; don't animate during pause
    627  1d3a
    628  1d3a		       c6 a0		      dec	ManDelayCount
    629  1d3c		       10 28		      bpl	AnimationOK
    630  1d3e
    631  1d3e		       a4 a1	   ReloadAnimation ldy	ManAnimation
    632  1d40		       b9 00 f7    ContinueAnim lda	Manimate,y	; delay count
    633  1d43		       d0 07		      bne	NewFrameOK
    634  1d45		       b9 01 f7 	      lda	Manimate+1,y
    635  1d48		       a8		      tay
    636  1d49		       4c 40 f5 	      jmp	ContinueAnim
    637  1d4c
    638  1d4c		       10 0d	   NewFrameOK bpl	doDelay
    639  1d4e
    640  1d4e		       c8		      iny		; handle a REFLECT
    641  1d4f		       a5 a4		      lda	ManLastDirection
    642  1d51		       29 f7		      and	#%11110111
    643  1d53		       19 00 f7 	      ora	Manimate,y
    644  1d56		       85 a4		      sta	ManLastDirection
    645  1d58
    646  1d58		       c8		      iny
    647  1d59		       d0 e5		      bne	ContinueAnim
    648  1d5b
    649  1d5b		       85 a0	   doDelay    sta	ManDelayCount
    650  1d5d
    651  1d5d		       c8		      iny
    652  1d5e		       b9 00 f7 	      lda	Manimate,y
    653  1d61		       85 a3		      sta	ManAnimationFrameLO
    654  1d63
    655  1d63		       c8		      iny
    656  1d64		       84 a1		      sty	ManAnimation
    657  1d66
    658  1d66		       60	   AnimationOK rts
    659  1d67
    660  1d67
    661  1d67
    662  1d67		       40 40	   pscol      .byte.b	$40, $40
    663  1d69		       60 60		      .byte.b	$60, $60
    664  1d6b
    665  1d6b							;------------------------------------------------------------------------------
    666  1d6b
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  1d6b					      include	"i2c_v2.2.inc"
      1  1d6b							;
      2  1d6b							; i2c_v2.2.inc
      3  1d6b							;
      4  1d6b							;
      5  1d6b							; AtariVox EEPROM Driver
      6  1d6b							;
      7  1d6b							; By Alex Herbert, 2004
      8  1d6b							;
      9  1d6b							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1d6b							;
     11  1d6b
     12  1d6b
     13  1d6b							; I/O Constants
     14  1d6b
     15  1d6b		       00 04	   I2C_SDA_MASK equ	$04
     16  1d6b		       00 08	   I2C_SCL_MASK equ	$08
     17  1d6b
     18  1d6b
     19  1d6b							; Signalling Macros
     20  1d6b
     21  1d6b							;  MAC     I2C_SCL_0
     22  1d6b							;    lda     #$00
     23  1d6b							;    sta     SWCHA
     24  1d6b							;  ENDM
     25  1d6b
     26  1d6b							;  MAC     I2C_SCL_1
     27  1d6b							;    lda     #I2C_SCL_MASK
     28  1d6b							;    sta     SWCHA
     29  1d6b							;  ENDM
     30  1d6b
     31  1d6b							;  MAC     I2C_SDA_IN
     32  1d6b							;    lda     #I2C_SCL_MASK
     33  1d6b							;    sta     SWACNT
     34  1d6b							;  ENDM
     35  1d6b
     36  1d6b							;  MAC     I2C_SDA_OUT
     37  1d6b							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1d6b							;    sta     SWACNT
     39  1d6b							;  ENDM
     40  1d6b
     41  1d6b
     42  1d6b					      MAC	i2c_start
     43  1d6b							; I2C_SCL_1
     44  1d6b					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1d6b					      sta	SWCHA	; 4
     46  1d6b							; I2C_SDA_OUT
     47  1d6b					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1d6b					      sta	SWACNT	; 4
     49  1d6b							; total: 12 cycles
     50  1d6b					      ENDM
     51  1d6b
     52  1d6b
     53  1d6b					      MAC	i2c_txbit
     54  1d6b							; I2C_SCL_0
     55  1d6b					      lda	#%0011	; 2
     56  1d6b					      sta	SWCHA	; 4
     57  1d6b							; set bit
     58  1d6b					      adc	#%1000	; 2
     59  1d6b					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1d6b							; I2C_SCL_1
     61  1d6b					      lda	#I2C_SCL_MASK	; 2
     62  1d6b					      sta	SWCHA	; 4
     63  1d6b							; total: 18 cycles
     64  1d6b					      ENDM
     65  1d6b
     66  1d6b
     67  1d6b					      MAC	i2c_txnack
     68  1d6b							; I2C_SCL_0
     69  1d6b					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1d6b					      sta	SWCHA	; 4
     71  1d6b							; I2C_SDA_IN
     72  1d6b					      lsr		; 2	     I2C_SCL_MASK
     73  1d6b					      sta	SWACNT	; 4
     74  1d6b							; I2C_SCL_1
     75  1d6b					      nop		; 2	     required for timing!
     76  1d6b					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1d6b							; total: 18 cycles
     78  1d6b					      ENDM
     79  1d6b
     80  1d6b
     81  1d6b							; Subroutine Macros
     82  1d6b
     83  1d6b					      MAC	i2c_subs
     84  1d6b
     85  1d6b				   i2c_startread
     86  1d6b							; use V to flag if previous byte needs ACK
     87  1d6b					      ldy	#%10100001	; 2	     eeprom read command
     88  1d6b					      .byte	$2c	; 2
     89  1d6b				   i2c_startwrite
     90  1d6b					      ldy	#%10100000	; 2	     eeprom write command
     91  1d6b					      I2C_START		;12	     start signal (clears V flag)
     92  1d6b					      tya		; 2 = 16
     93  1d6b				   i2c_txbyte
     94  1d6b					      eor	#$ff	; 2	     invert data byte
     95  1d6b					      sec		; 2
     96  1d6b					      rol		; 2 =	6    shift loop bit into a
     97  1d6b				   i2c_txbyteloop
     98  1d6b					      tay		; 2
     99  1d6b					      I2C_TXBIT		;18	     transmit
    100  1d6b					      tya		; 2
    101  1d6b					      asl		; 2	     shift next bit into C
    102  1d6b					      bne	i2c_txbyteloop	; 2= 26/27
    103  1d6b
    104  1d6b							; receive acknowledge bit
    105  1d6b
    106  1d6b					      beq	i2c_rxbit	;43 = 43
    107  1d6b							; i2c_txbyte: 264 cycles
    108  1d6b							;-------------------------------------------------------------------------------
    109  1d6b
    110  1d6b				   i2c_rxbyte
    111  1d6b					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1d6b					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1d6b
    114  1d6b				   i2c_rxskipack
    115  1d6b					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1d6b
    117  1d6b					      lda	#1	; 2
    118  1d6b				   i2c_rxbyteloop
    119  1d6b					      tay		; 2 =	2
    120  1d6b				   i2c_rxbit		;	     receive bit in C
    121  1d6b					      I2C_TXNACK		;18 = 18
    122  1d6b
    123  1d6b					      lda	SWCHA	; 4
    124  1d6b					      lsr		; 2
    125  1d6b					      lsr		; 2
    126  1d6b					      lsr		; 2 = 10    C = SDA
    127  1d6b
    128  1d6b					      tya		; 2
    129  1d6b					      rol		; 2	     rotate into Y
    130  1d6b					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1d6b
    132  1d6b							; received byte in A
    133  1d6b					      rts		; 6 =	6
    134  1d6b							; i2c_rxbit:  40 cycles
    135  1d6b							; i2c_rxbyte: 310/333 cycles
    136  1d6b							;-------------------------------------------------------------------------------
    137  1d6b
    138  1d6b				   i2c_stopread
    139  1d6b					      bvc	i2c_stopwrite	; 2
    140  1d6b					      ldy	#$80	; 2
    141  1d6b					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1d6b
    143  1d6b				   i2c_stopwrite
    144  1d6b					      jsr	i2c_txack	;30
    145  1d6b
    146  1d6b							; return port to input mode
    147  1d6b					      lda	#0	; 2	     0
    148  1d6b					      sta	SWACNT	; 4
    149  1d6b					      rts		; 6 = 12
    150  1d6b							; i2c_stopread:  45/92
    151  1d6b							; i2c_stopwrite: 42
    152  1d6b							;-------------------------------------------------------------------------------
    153  1d6b
    154  1d6b				   i2c_txack
    155  1d6b							; I2C_SCL_0
    156  1d6b					      lda	#0	; 2	     $00
    157  1d6b					      sta	SWCHA	; 4
    158  1d6b							; I2C_SDA_OUT
    159  1d6b					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1d6b					      sta	SWACNT	; 4
    161  1d6b							; I2C_SCL_1
    162  1d6b					      asl		; 2	     I2C_SCL_MASK
    163  1d6b					      sta	SWCHA	; 4
    164  1d6b
    165  1d6b					      rts		; 6
    166  1d6b							; total: 24 cycles
    167  1d6b							;-------------------------------------------------------------------------------
    168  1d6b
    169  1d6b					      ENDM
    170  1d6b
    171  1d6b
    172  1d6b
------- FILE BANK_GENERIC.asm
    668  1d6b
      0  1d6b					      i2c_subs
      1  1d6b
      2  1d6b				   i2c_startread
      3  1d6b
      4  1d6b		       a0 a1		      ldy	#%10100001
      5  1d6d		       2c		      .byte.b	$2c
      6  1d6e				   i2c_startwrite
      7  1d6e		       a0 a0		      ldy	#%10100000
      0  1d70					      I2C_START
      1  1d70
      2  1d70		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1d72		       8d 80 02 	      sta	SWCHA
      4  1d75
      5  1d75		       4a		      lsr
      6  1d76		       8d 81 02 	      sta	SWACNT
      7  1d79
      9  1d79		       98		      tya
     10  1d7a				   i2c_txbyte
     11  1d7a		       49 ff		      eor	#$ff
     12  1d7c		       38		      sec
     13  1d7d		       2a		      rol
     14  1d7e				   i2c_txbyteloop
     15  1d7e		       a8		      tay
      0  1d7f					      I2C_TXBIT
      1  1d7f
      2  1d7f		       a9 03		      lda	#%0011
      3  1d81		       8d 80 02 	      sta	SWCHA
      4  1d84
      5  1d84		       69 08		      adc	#%1000
      6  1d86		       8d 81 02 	      sta	SWACNT
      7  1d89
      8  1d89		       a9 08		      lda	#I2C_SCL_MASK
      9  1d8b		       8d 80 02 	      sta	SWCHA
     10  1d8e
     17  1d8e		       98		      tya
     18  1d8f		       0a		      asl
     19  1d90		       d0 ec		      bne	i2c_txbyteloop
     20  1d92
     21  1d92
     22  1d92
     23  1d92		       f0 0b		      beq	i2c_rxbit
     24  1d94
     25  1d94
     26  1d94
     27  1d94				   i2c_rxbyte
     28  1d94		       50 03		      bvc	i2c_rxskipack
     29  1d96		       20 c7 f5 	      jsr	i2c_txack
     30  1d99
     31  1d99				   i2c_rxskipack
     32  1d99		       2c 94 f5 	      bit	i2c_rxbyte
     33  1d9c
     34  1d9c		       a9 01		      lda	#1
     35  1d9e				   i2c_rxbyteloop
     36  1d9e		       a8		      tay
     37  1d9f				   i2c_rxbit
      0  1d9f					      I2C_TXNACK
      1  1d9f
      2  1d9f		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1da1		       8d 80 02 	      sta	SWCHA
      4  1da4
      5  1da4		       4a		      lsr
      6  1da5		       8d 81 02 	      sta	SWACNT
      7  1da8
      8  1da8		       ea		      nop
      9  1da9		       8d 80 02 	      sta	SWCHA
     10  1dac
     39  1dac
     40  1dac		       ad 80 02 	      lda	SWCHA
     41  1daf		       4a		      lsr
     42  1db0		       4a		      lsr
     43  1db1		       4a		      lsr
     44  1db2
     45  1db2		       98		      tya
     46  1db3		       2a		      rol
     47  1db4		       90 e8		      bcc	i2c_rxbyteloop
     48  1db6
     49  1db6
     50  1db6		       60		      rts
     51  1db7
     52  1db7
     53  1db7
     54  1db7
     55  1db7				   i2c_stopread
     56  1db7		       50 05		      bvc	i2c_stopwrite
     57  1db9		       a0 80		      ldy	#$80
     58  1dbb		       20 9f f5 	      jsr	i2c_rxbit
     59  1dbe
     60  1dbe				   i2c_stopwrite
     61  1dbe		       20 c7 f5 	      jsr	i2c_txack
     62  1dc1
     63  1dc1
     64  1dc1		       a9 00		      lda	#0
     65  1dc3		       8d 81 02 	      sta	SWACNT
     66  1dc6		       60		      rts
     67  1dc7
     68  1dc7
     69  1dc7
     70  1dc7
     71  1dc7				   i2c_txack
     72  1dc7
     73  1dc7		       a9 00		      lda	#0
     74  1dc9		       8d 80 02 	      sta	SWCHA
     75  1dcc
     76  1dcc		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1dce		       8d 81 02 	      sta	SWACNT
     78  1dd1
     79  1dd1		       0a		      asl
     80  1dd2		       8d 80 02 	      sta	SWCHA
     81  1dd5
     82  1dd5		       60		      rts
     83  1dd6
     84  1dd6
     85  1dd6
    670  1dd6
    671  1dd6				   HandleSaveKey SUBROUTINE
    672  1dd6
    673  1dd6		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    674  1dd6
    675  1dd6							;------------------------------------------------------------------------------
      0  1dd6					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1dd6		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1dd6					      SUBROUTINE
      3  1dd6				   ReadSaveKey
    677  1dd6
    678  1dd6							; assume no SaveKey found:
    679  1dd6		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    680  1dd8		       85 dd		      sta	highScoreSK+2	; 3
    681  1dda
    682  1dda							; setup SaveKey:
    683  1dda		       a5 de		      lda	startingLevel	; 3	     load start levelX*5 and level
    684  1ddc		       a6 b4		      ldx	level	; 3
    685  1dde		       20 17 f6 	      jsr	SetupSaveKey	;6+853
    686  1de1		       90 52		      bcc	NoSKfound	; 2/3
    687  1de3
    688  1de3							;    lda     #$34
    689  1de3							;    sta     COLUBK
    690  1de3
    691  1de3							; start read
    692  1de3		       20 be f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    693  1de6		       20 6b f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    694  1de9
    695  1de9							; read high score:
    696  1de9		       a2 02		      ldx	#3-1	; 2 = 1187
    697  1deb				   .loopRead
    698  1deb		       20 94 f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    699  1dee		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    700  1df0		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    701  1df2		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    702  1df4				   .skipEmpty
    703  1df4		       95 db		      sta	highScoreSK,x	; 4
    704  1df6		       ca		      dex		; 2
    705  1df7		       10 f2		      bpl	.loopRead	; 2/3= 354
    706  1df9
    707  1df9							; stop read:
    708  1df9		       4c b7 f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    709  1dfc
    710  1dfc							;------------------------------------------------------------------------------
      0  1dfc					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1dfc		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1dfc					      SUBROUTINE
      3  1dfc				   WriteSaveKey
    712  1dfc
    713  1dfc							; check if new high score:
    714  1dfc		       a6 db		      ldx	highScoreSK	; 3
    715  1dfe		       e8		      inx		; 2
    716  1dff		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    717  1e01
    718  1e01							; setup SaveKey:
    719  1e01		       a5 de		      lda	startingLevel	; 3	     load start levelX*5 and level
    720  1e03		       a6 df		      ldx	startLevel	; 3
    721  1e05		       20 17 f6 	      jsr	SetupSaveKey	; 6+853
    722  1e08		       90 2b		      bcc	NoSKfound	; 2/3
    723  1e0a
    724  1e0a							;    lda     #$64
    725  1e0a							;    sta     COLUBK
    726  1e0a
    727  1e0a							; write high score:
    728  1e0a		       a2 02		      ldx	#3-1	; 2 = 841
    729  1e0c				   .loopWrite
    730  1e0c		       b5 db		      lda	highScoreSK,x	; 4
    731  1e0e		       20 7a f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    732  1e11		       ca		      dex		; 2
    733  1e12		       10 f8		      bpl	.loopWrite	; 2/3= 837
    734  1e14
    735  1e14							; stop write:
    736  1e14		       4c be f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    737  1e17
    738  1e17
    739  1e17							;------------------------------------------------------------------------------
      0  1e17					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1e17		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1e17					      SUBROUTINE
      3  1e17				   SetupSaveKey
    741  1e17
    742  1e17							; calculate slot;
    743  1e17							; a = levelX
    744  1e17							; x = level (0..4)
    745  1e17		       85 e0		      sta	offsetSK	; 3
    746  1e19		       8a		      txa		; 2
    747  1e1a		       18		      clc		; 2
    748  1e1b		       65 e0		      adc	offsetSK	; 3
    749  1e1d		       85 e0		      sta	offsetSK	; 3
    750  1e1f		       0a		      asl		; 2	     multiply by 3
    751  1e20		       65 e0		      adc	offsetSK	; 3
    752  1e22		       69 00		      adc	#<SAVEKEY_ADR	; 2
    753  1e24		       aa		      tax		; 2 = 22
    754  1e25							; detect SaveKey:
    755  1e25		       20 6e f5 	      jsr	i2c_startwrite	;6+280
    756  1e28		       d0 0a		      bne	.exitSK	; 2/3
    757  1e2a
    758  1e2a							; setup address:
    759  1e2a		       b8		      clv		; 2
    760  1e2b		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    761  1e2d		       20 7a f5 	      jsr	i2c_txbyte	;6+264
    762  1e30		       8a		      txa		; 2	     x = lower byte offset
    763  1e31		       4c 7a f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    764  1e34
    765  1e34				   .exitSK
    766  1e34		       18		      clc
    767  1e35				   NoSKfound
    768  1e35		       60		      rts
    769  1e35					      ENDIF
    770  1e36
    771  1f00		       00 00 00 00*	      align	256
    772  1f00
    773  1f00				   Manimate
    774  1f00				   AnimateSTAND
    775  1f00				   AnimateRIGHT
    776  1f00				   AnimateLEFT
    777  1f00				   AnimateUP
    778  1f00				   AnimateSTOPPED
    779  1f00		       7f		      .byte.b	127
    780  1f01		       1a		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    781  1f02							;.byte 10
    782  1f02							;.byte < PLAYER_BLINK
    783  1f02							;.byte 127
    784  1f02							;.byte < PLAYER_STAND
    785  1f02							;.byte 0
    786  1f02							;.word AnimateTAP
    787  1f02
    788  1f02				   AnimateTAP
    789  1f02							;.byte 128, %0 		  ; reflect off, always tap with left foot
    790  1f02							;.byte 8
    791  1f02							;.byte < PLAYER_TAP0
    792  1f02							;.byte 8
    793  1f02							;.byte < PLAYER_TAP1
    794  1f02							;.byte 8
    795  1f02							;.byte < PLAYER_TAP0
    796  1f02							;.byte 8
    797  1f02							;.byte < PLAYER_TAP1
    798  1f02							;.byte 8
    799  1f02							;.byte < PLAYER_TAP0
    800  1f02							;.byte 8
    801  1f02							;.byte < PLAYER_TAP1
    802  1f02		       00		      .byte.b	0
    803  1f03		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    804  1f04
    805  1f04							;AnimateRIGHT
    806  1f04		       80 00		      .byte.b	128, %0	; reflect off
    807  1f06		       05		      .byte.b	5
    808  1f07		       1a		      .byte.b	< PLAYER_RIGHT0
    809  1f08		       05		      .byte.b	5
    810  1f09		       2f		      .byte.b	< PLAYER_RIGHT1
    811  1f0a		       00		      .byte.b	0
    812  1f0b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    813  1f0c
    814  1f0c							;AnimateLEFT
    815  1f0c		       80 08		      .byte.b	128, %1000	; reflect ON
    816  1f0e		       05		      .byte.b	5
    817  1f0f		       1a		      .byte.b	< PLAYER_RIGHT0
    818  1f10		       05		      .byte.b	5
    819  1f11		       2f		      .byte.b	< PLAYER_RIGHT1
    820  1f12		       00		      .byte.b	0
    821  1f13		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    822  1f14
    823  1f14							;AnimateUP
    824  1f14							;    .byte 128, %0		   ; reflect off
    825  1f14							;    .byte 5
    826  1f14							;    .byte < PLAYER_TAP
    827  1f14							;    .byte 128, %1000
    828  1f14							;    .byte 5
    829  1f14							;    .byte < PLAYER_TAP
    830  1f14							;    .byte 0
    831  1f14							;    .word AnimateUP
    832  1f14
    833  1f14							;AnimateUP
    834  1f14		       05		      .byte.b	5
    835  1f15		       1a		      .byte.b	< PLAYER_RIGHT0
    836  1f16		       05		      .byte.b	5
    837  1f17		       2f		      .byte.b	< PLAYER_RIGHT1
    838  1f18		       00		      .byte.b	0
    839  1f19		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    840  1f1a
    841  1f1a				   AnimateBLANK
    842  1f1a		       7f		      .byte.b	127
    843  1f1b		       05		      .byte.b	< PLAYER_BLANK
    844  1f1c		       00		      .byte.b	0
    845  1f1d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    846  1f1e
    847  1f1e				   AnimateEND
      0  1f1e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  1f1e					      LIST	ON
    849  1f1e
    850  1f1e
      0  1f1e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1f1e		       07 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $71e , FREE= $e2
      2  1f1e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1f1e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1f1e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1f1e				  -	      ERR
      6  1f1e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 3
      0  1f1e					      include	"BANK_LEVELS1.asm"
      1  1f1e							;    Sokoboo - a Sokoban implementation
      2  1f1e							;    using a generic tile-based display engine for the Atari 2600
      3  1f1e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1f1e							;
      5  1f1e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1f1e							;
      7  1f1e							;    Code related to the generic tile-based display engine was developed by
      8  1f1e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1f1e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1f1e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1f1e							;
     12  1f1e							;    Code related to music and sound effects uses the TIATracker music player
     13  1f1e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1f1e							;    directory for Apache licensing details.
     15  1f1e							;
     16  1f1e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1f1e							;    See the copyright notices in the License directory for a list of level
     18  1f1e							;    contributors.
     19  1f1e							;
     20  1f1e							;    Except where otherwise indicated, this software is released under the
     21  1f1e							;    following licensing arrangement...
     22  1f1e							;
     23  1f1e							;    This program is free software: you can redistribute it and/or modify
     24  1f1e							;    it under the terms of the GNU General Public License as published by
     25  1f1e							;    the Free Software Foundation, either version 3 of the License, or
     26  1f1e							;    (at your option) any later version.
     27  1f1e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1f1e
     29  1f1e							;    This program is distributed in the hope that it will be useful,
     30  1f1e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1f1e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1f1e							;    GNU General Public License for more details.
     33  1f1e
      0  1f1e					      NEWBANK	LEVELS1
      1  27d7 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000							; "SOKWHOLE" collection...
     37  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00		      .byte.b	0
      2  2012		       00 13	   LEVEL_SIZE__001_L =	* - LEVEL_START
      3  2013					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      4  2013				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      5  2013					      ENDIF
      0  2013					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2013					      START_LEVEL	_001_R
      1  2013				   LEVEL_START SET	*
      2  2013		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2013				   LEVEL__001_R SUBROUTINE
      4  2013				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2013
      2  2013		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201f					      END_LEVEL	_001_R
      1  201f		       00		      .byte.b	0
      2  201f		       00 0d	   LEVEL_SIZE__001_R =	* - LEVEL_START
      3  2020				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      4  2020				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      5  2020					      ENDIF
      0  2020					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  2020					      START_LEVEL	_002_L
      1  2020				   LEVEL_START SET	*
      2  2020		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  2020				   LEVEL__002_L SUBROUTINE
      4  2020				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2020
      2  2020		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2039					      END_LEVEL	_002_L
      1  2039		       00		      .byte.b	0
      2  2039		       00 1a	   LEVEL_SIZE__002_L =	* - LEVEL_START
      3  203a					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      4  203a				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      5  203a					      ENDIF
      0  203a					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  203a					      START_LEVEL	_002_R
      1  203a				   LEVEL_START SET	*
      2  203a		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  203a				   LEVEL__002_R SUBROUTINE
      4  203a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  203a
      2  203a		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  2062					      END_LEVEL	_002_R
      1  2062		       00		      .byte.b	0
      2  2062		       00 29	   LEVEL_SIZE__002_R =	* - LEVEL_START
      3  2063					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      4  2063				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      5  2063					      ENDIF
      0  2063					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  2063					      START_LEVEL	_003_L
      1  2063				   LEVEL_START SET	*
      2  2063		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  2063				   LEVEL__003_L SUBROUTINE
      4  2063				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2063
      2  2063		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208f					      END_LEVEL	_003_L
      1  208f		       00		      .byte.b	0
      2  208f		       00 2d	   LEVEL_SIZE__003_L =	* - LEVEL_START
      3  2090					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      4  2090				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      5  2090					      ENDIF
      0  2090					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  2090					      START_LEVEL	_003_R
      1  2090				   LEVEL_START SET	*
      2  2090		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  2090				   LEVEL__003_R SUBROUTINE
      4  2090				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2090
      2  2090		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20ba					      END_LEVEL	_003_R
      1  20ba		       00		      .byte.b	0
      2  20ba		       00 2b	   LEVEL_SIZE__003_R =	* - LEVEL_START
      3  20bb				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      4  20bb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      5  20bb					      ENDIF
      0  20bb					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20bb					      START_LEVEL	_004_L
      1  20bb				   LEVEL_START SET	*
      2  20bb		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20bb				   LEVEL__004_L SUBROUTINE
      4  20bb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20bb
      2  20bb		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20de					      END_LEVEL	_004_L
      1  20de		       00		      .byte.b	0
      2  20de		       00 24	   LEVEL_SIZE__004_L =	* - LEVEL_START
      3  20df				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      4  20df				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      5  20df					      ENDIF
      0  20df					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20df					      START_LEVEL	_004_R
      1  20df				   LEVEL_START SET	*
      2  20df		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20df				   LEVEL__004_R SUBROUTINE
      4  20df				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20df
      2  20df		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20fb					      END_LEVEL	_004_R
      1  20fb		       00		      .byte.b	0
      2  20fb		       00 1d	   LEVEL_SIZE__004_R =	* - LEVEL_START
      3  20fc				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      4  20fc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      5  20fc					      ENDIF
      0  20fc					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20fc					      START_LEVEL	_005_L
      1  20fc				   LEVEL_START SET	*
      2  20fc		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20fc				   LEVEL__005_L SUBROUTINE
      4  20fc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20fc
      2  20fc		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  212e					      END_LEVEL	_005_L
      1  212e		       00		      .byte.b	0
      2  212e		       00 33	   LEVEL_SIZE__005_L =	* - LEVEL_START
      3  212f					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      4  212f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      5  212f					      ENDIF
      0  212f					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  212f					      START_LEVEL	_005_R
      1  212f				   LEVEL_START SET	*
      2  212f		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  212f				   LEVEL__005_R SUBROUTINE
      4  212f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  212f
      2  212f		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  216e					      END_LEVEL	_005_R
      1  216e		       00		      .byte.b	0
      2  216e		       00 40	   LEVEL_SIZE__005_R =	* - LEVEL_START
      3  216f					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      4  216f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      5  216f					      ENDIF
      0  216f					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  216f					      START_LEVEL	_006_L
      1  216f				   LEVEL_START SET	*
      2  216f		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  216f				   LEVEL__006_L SUBROUTINE
      4  216f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  216f
      2  216f		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21aa					      END_LEVEL	_006_L
      1  21aa		       00		      .byte.b	0
      2  21aa		       00 3c	   LEVEL_SIZE__006_L =	* - LEVEL_START
      3  21ab				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      4  21ab				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      5  21ab					      ENDIF
      0  21ab					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21ab					      START_LEVEL	_006_R
      1  21ab				   LEVEL_START SET	*
      2  21ab		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21ab				   LEVEL__006_R SUBROUTINE
      4  21ab				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ab
      2  21ab		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21e9					      END_LEVEL	_006_R
      1  21e9		       00		      .byte.b	0
      2  21e9		       00 3f	   LEVEL_SIZE__006_R =	* - LEVEL_START
      3  21ea				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      4  21ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      5  21ea					      ENDIF
      0  21ea					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21ea					      START_LEVEL	_007_L
      1  21ea				   LEVEL_START SET	*
      2  21ea		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21ea				   LEVEL__007_L SUBROUTINE
      4  21ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ea
      2  21ea		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  2217					      END_LEVEL	_007_L
      1  2217		       00		      .byte.b	0
      2  2217		       00 2e	   LEVEL_SIZE__007_L =	* - LEVEL_START
      3  2218				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      4  2218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      5  2218					      ENDIF
      0  2218					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  2218					      START_LEVEL	_007_R
      1  2218				   LEVEL_START SET	*
      2  2218		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  2218				   LEVEL__007_R SUBROUTINE
      4  2218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2218
      2  2218		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  224b					      END_LEVEL	_007_R
      1  224b		       00		      .byte.b	0
      2  224b		       00 34	   LEVEL_SIZE__007_R =	* - LEVEL_START
      3  224c				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      4  224c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      5  224c					      ENDIF
      0  224c					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  224c					      START_LEVEL	_008_L
      1  224c				   LEVEL_START SET	*
      2  224c		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  224c				   LEVEL__008_L SUBROUTINE
      4  224c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  224c
      2  224c		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2282					      END_LEVEL	_008_L
      1  2282		       00		      .byte.b	0
      2  2282		       00 37	   LEVEL_SIZE__008_L =	* - LEVEL_START
      3  2283				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      4  2283				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      5  2283					      ENDIF
      0  2283					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2283					      START_LEVEL	_008_R
      1  2283				   LEVEL_START SET	*
      2  2283		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2283				   LEVEL__008_R SUBROUTINE
      4  2283				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2283
      2  2283		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22b4					      END_LEVEL	_008_R
      1  22b4		       00		      .byte.b	0
      2  22b4		       00 32	   LEVEL_SIZE__008_R =	* - LEVEL_START
      3  22b5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      4  22b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      5  22b5					      ENDIF
      0  22b5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22b5					      START_LEVEL	_009_L
      1  22b5				   LEVEL_START SET	*
      2  22b5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22b5				   LEVEL__009_L SUBROUTINE
      4  22b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22b5
      2  22b5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22e7					      END_LEVEL	_009_L
      1  22e7		       00		      .byte.b	0
      2  22e7		       00 33	   LEVEL_SIZE__009_L =	* - LEVEL_START
      3  22e8				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      4  22e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      5  22e8					      ENDIF
      0  22e8					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22e8					      START_LEVEL	_009_R
      1  22e8				   LEVEL_START SET	*
      2  22e8		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22e8				   LEVEL__009_R SUBROUTINE
      4  22e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22e8
      2  22e8		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2318					      END_LEVEL	_009_R
      1  2318		       00		      .byte.b	0
      2  2318		       00 31	   LEVEL_SIZE__009_R =	* - LEVEL_START
      3  2319				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      4  2319				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      5  2319					      ENDIF
      0  2319					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2319					      START_LEVEL	_010_L
      1  2319				   LEVEL_START SET	*
      2  2319		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2319				   LEVEL__010_L SUBROUTINE
      4  2319				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2319
      2  2319		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2353					      END_LEVEL	_010_L
      1  2353		       00		      .byte.b	0
      2  2353		       00 3b	   LEVEL_SIZE__010_L =	* - LEVEL_START
      3  2354				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      4  2354				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      5  2354					      ENDIF
      0  2354					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2354					      START_LEVEL	_010_R
      1  2354				   LEVEL_START SET	*
      2  2354		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2354				   LEVEL__010_R SUBROUTINE
      4  2354				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2354
      2  2354		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2387					      END_LEVEL	_010_R
      1  2387		       00		      .byte.b	0
      2  2387		       00 34	   LEVEL_SIZE__010_R =	* - LEVEL_START
      3  2388				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      4  2388				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      5  2388					      ENDIF
      0  2388					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2388					      START_LEVEL	_011_L
      1  2388				   LEVEL_START SET	*
      2  2388		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2388				   LEVEL__011_L SUBROUTINE
      4  2388				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2388
      2  2388		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23bb					      END_LEVEL	_011_L
      1  23bb		       00		      .byte.b	0
      2  23bb		       00 34	   LEVEL_SIZE__011_L =	* - LEVEL_START
      3  23bc				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      4  23bc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      5  23bc					      ENDIF
      0  23bc					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23bc					      START_LEVEL	_011_R
      1  23bc				   LEVEL_START SET	*
      2  23bc		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23bc				   LEVEL__011_R SUBROUTINE
      4  23bc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23bc
      2  23bc		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23f6					      END_LEVEL	_011_R
      1  23f6		       00		      .byte.b	0
      2  23f6		       00 3b	   LEVEL_SIZE__011_R =	* - LEVEL_START
      3  23f7				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      4  23f7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      5  23f7					      ENDIF
      0  23f7					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23f7					      START_LEVEL	_012_L
      1  23f7				   LEVEL_START SET	*
      2  23f7		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23f7				   LEVEL__012_L SUBROUTINE
      4  23f7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23f7
      2  23f7		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2427					      END_LEVEL	_012_L
      1  2427		       00		      .byte.b	0
      2  2427		       00 31	   LEVEL_SIZE__012_L =	* - LEVEL_START
      3  2428				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      4  2428				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      5  2428					      ENDIF
      0  2428					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2428					      START_LEVEL	_012_R
      1  2428				   LEVEL_START SET	*
      2  2428		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2428				   LEVEL__012_R SUBROUTINE
      4  2428				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2428
      2  2428		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  2464					      END_LEVEL	_012_R
      1  2464		       00		      .byte.b	0
      2  2464		       00 3d	   LEVEL_SIZE__012_R =	* - LEVEL_START
      3  2465				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      4  2465				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      5  2465					      ENDIF
      0  2465					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  2465					      START_LEVEL	_013_L
      1  2465				   LEVEL_START SET	*
      2  2465		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  2465				   LEVEL__013_L SUBROUTINE
      4  2465				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2465
      2  2465		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  24a4					      END_LEVEL	_013_L
      1  24a4		       00		      .byte.b	0
      2  24a4		       00 40	   LEVEL_SIZE__013_L =	* - LEVEL_START
      3  24a5				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      4  24a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      5  24a5					      ENDIF
      0  24a5					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  24a5					      START_LEVEL	_013_R
      1  24a5				   LEVEL_START SET	*
      2  24a5		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  24a5				   LEVEL__013_R SUBROUTINE
      4  24a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24a5
      2  24a5		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24d8					      END_LEVEL	_013_R
      1  24d8		       00		      .byte.b	0
      2  24d8		       00 34	   LEVEL_SIZE__013_R =	* - LEVEL_START
      3  24d9				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      4  24d9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      5  24d9					      ENDIF
      0  24d9					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24d9					      START_LEVEL	_014_L
      1  24d9				   LEVEL_START SET	*
      2  24d9		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24d9				   LEVEL__014_L SUBROUTINE
      4  24d9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24d9
      2  24d9		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  251c					      END_LEVEL	_014_L
      1  251c		       00		      .byte.b	0
      2  251c		       00 44	   LEVEL_SIZE__014_L =	* - LEVEL_START
      3  251d					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      4  251d				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      5  251d					      ENDIF
      0  251d					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  251d					      START_LEVEL	_014_R
      1  251d				   LEVEL_START SET	*
      2  251d		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  251d				   LEVEL__014_R SUBROUTINE
      4  251d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  251d
      2  251d		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2560					      END_LEVEL	_014_R
      1  2560		       00		      .byte.b	0
      2  2560		       00 44	   LEVEL_SIZE__014_R =	* - LEVEL_START
      3  2561				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      4  2561				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      5  2561					      ENDIF
      0  2561					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2561					      START_LEVEL	_015_L
      1  2561				   LEVEL_START SET	*
      2  2561		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2561				   LEVEL__015_L SUBROUTINE
      4  2561				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2561
      2  2561		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  2596					      END_LEVEL	_015_L
      1  2596		       00		      .byte.b	0
      2  2596		       00 36	   LEVEL_SIZE__015_L =	* - LEVEL_START
      3  2597				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      4  2597				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      5  2597					      ENDIF
      0  2597					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  2597					      START_LEVEL	_015_R
      1  2597				   LEVEL_START SET	*
      2  2597		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  2597				   LEVEL__015_R SUBROUTINE
      4  2597				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2597
      2  2597		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25dc					      END_LEVEL	_015_R
      1  25dc		       00		      .byte.b	0
      2  25dc		       00 46	   LEVEL_SIZE__015_R =	* - LEVEL_START
      3  25dd					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      4  25dd				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      5  25dd					      ENDIF
      0  25dd					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25dd					      START_LEVEL	_016_L
      1  25dd				   LEVEL_START SET	*
      2  25dd		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25dd				   LEVEL__016_L SUBROUTINE
      4  25dd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25dd
      2  25dd		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  2614					      END_LEVEL	_016_L
      1  2614		       00		      .byte.b	0
      2  2614		       00 38	   LEVEL_SIZE__016_L =	* - LEVEL_START
      3  2615				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      4  2615				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      5  2615					      ENDIF
      0  2615					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  2615					      START_LEVEL	_016_R
      1  2615				   LEVEL_START SET	*
      2  2615		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  2615				   LEVEL__016_R SUBROUTINE
      4  2615				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2615
      2  2615		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2648					      END_LEVEL	_016_R
      1  2648		       00		      .byte.b	0
      2  2648		       00 34	   LEVEL_SIZE__016_R =	* - LEVEL_START
      3  2649				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      4  2649				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      5  2649					      ENDIF
      0  2649					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2649					      START_LEVEL	_017_L
      1  2649				   LEVEL_START SET	*
      2  2649		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2649				   LEVEL__017_L SUBROUTINE
      4  2649				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2649
      2  2649		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2693					      END_LEVEL	_017_L
      1  2693		       00		      .byte.b	0
      2  2693		       00 4b	   LEVEL_SIZE__017_L =	* - LEVEL_START
      3  2694					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      4  2694				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      5  2694					      ENDIF
      0  2694					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2694					      START_LEVEL	_017_R
      1  2694				   LEVEL_START SET	*
      2  2694		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2694				   LEVEL__017_R SUBROUTINE
      4  2694				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2694
      2  2694		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26d7					      END_LEVEL	_017_R
      1  26d7		       00		      .byte.b	0
      2  26d7		       00 44	   LEVEL_SIZE__017_R =	* - LEVEL_START
      3  26d8				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      4  26d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      5  26d8					      ENDIF
      0  26d8					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26d8					      START_LEVEL	_018_L
      1  26d8				   LEVEL_START SET	*
      2  26d8		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26d8				   LEVEL__018_L SUBROUTINE
      4  26d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26d8
      2  26d8		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  270c					      END_LEVEL	_018_L
      1  270c		       00		      .byte.b	0
      2  270c		       00 35	   LEVEL_SIZE__018_L =	* - LEVEL_START
      3  270d				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      4  270d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      5  270d					      ENDIF
      0  270d					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  270d					      START_LEVEL	_018_R
      1  270d				   LEVEL_START SET	*
      2  270d		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  270d				   LEVEL__018_R SUBROUTINE
      4  270d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  270d
      2  270d		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2749					      END_LEVEL	_018_R
      1  2749		       00		      .byte.b	0
      2  2749		       00 3d	   LEVEL_SIZE__018_R =	* - LEVEL_START
      3  274a				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      4  274a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      5  274a					      ENDIF
      0  274a					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  274a					      START_LEVEL	_019_L
      1  274a				   LEVEL_START SET	*
      2  274a		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  274a				   LEVEL__019_L SUBROUTINE
      4  274a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  274a
      2  274a		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2785					      END_LEVEL	_019_L
      1  2785		       00		      .byte.b	0
      2  2785		       00 3c	   LEVEL_SIZE__019_L =	* - LEVEL_START
      3  2786				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      4  2786				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      5  2786					      ENDIF
      0  2786					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2786					      START_LEVEL	_019_R
      1  2786				   LEVEL_START SET	*
      2  2786		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2786				   LEVEL__019_R SUBROUTINE
      4  2786				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2786
      2  2786		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27d6					      END_LEVEL	_019_R
      1  27d6		       00		      .byte.b	0
      2  27d6		       00 51	   LEVEL_SIZE__019_R =	* - LEVEL_START
      3  27d7					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      4  27d7				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      5  27d7					      ENDIF
     76  27d7
      0  27d7					      CHECK_BANK_SIZE	"LEVELS1"
      1  27d7		       07 d7	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7d7 , FREE= $29
      2  27d7					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27d7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27d7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27d7				  -	      ERR
      6  27d7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 3
      0  27d7					      include	"BANK_LEVELS2.asm"
      1  27d7							;    Sokoboo - a Sokoban implementation
      2  27d7							;    using a generic tile-based display engine for the Atari 2600
      3  27d7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27d7							;
      5  27d7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27d7							;
      7  27d7							;    Code related to the generic tile-based display engine was developed by
      8  27d7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27d7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27d7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27d7							;
     12  27d7							;    Code related to music and sound effects uses the TIATracker music player
     13  27d7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27d7							;    directory for Apache licensing details.
     15  27d7							;
     16  27d7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27d7							;    See the copyright notices in the License directory for a list of level
     18  27d7							;    contributors.
     19  27d7							;
     20  27d7							;    Except where otherwise indicated, this software is released under the
     21  27d7							;    following licensing arrangement...
     22  27d7							;
     23  27d7							;    This program is free software: you can redistribute it and/or modify
     24  27d7							;    it under the terms of the GNU General Public License as published by
     25  27d7							;    the Free Software Foundation, either version 3 of the License, or
     26  27d7							;    (at your option) any later version.
     27  27d7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27d7
     29  27d7							;    This program is distributed in the hope that it will be useful,
     30  27d7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27d7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27d7							;    GNU General Public License for more details.
     33  27d7
      0  27d7					      NEWBANK	LEVELS2
      1  2ec2 ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00		      .byte.b	0
      2  283f		       00 40	   LEVEL_SIZE__020_L =	* - LEVEL_START
      3  2840				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      4  2840				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      5  2840					      ENDIF
      0  2840					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  2840					      START_LEVEL	_020_R
      1  2840				   LEVEL_START SET	*
      2  2840		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  2840				   LEVEL__020_R SUBROUTINE
      4  2840				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2840
      2  2840		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  2880					      END_LEVEL	_020_R
      1  2880		       00		      .byte.b	0
      2  2880		       00 41	   LEVEL_SIZE__020_R =	* - LEVEL_START
      3  2881				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      4  2881				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      5  2881					      ENDIF
      0  2881					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  2881					      START_LEVEL	_021_L
      1  2881				   LEVEL_START SET	*
      2  2881		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  2881				   LEVEL__021_L SUBROUTINE
      4  2881				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2881
      2  2881		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d7					      END_LEVEL	_021_L
      1  28d7		       00		      .byte.b	0
      2  28d7		       00 57	   LEVEL_SIZE__021_L =	* - LEVEL_START
      3  28d8					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      4  28d8				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      5  28d8					      ENDIF
      0  28d8					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d8					      START_LEVEL	_021_R
      1  28d8				   LEVEL_START SET	*
      2  28d8		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d8				   LEVEL__021_R SUBROUTINE
      4  28d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d8
      2  28d8		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  290c					      END_LEVEL	_021_R
      1  290c		       00		      .byte.b	0
      2  290c		       00 35	   LEVEL_SIZE__021_R =	* - LEVEL_START
      3  290d				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      4  290d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      5  290d					      ENDIF
      0  290d					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  290d					      START_LEVEL	_022_L
      1  290d				   LEVEL_START SET	*
      2  290d		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  290d				   LEVEL__022_L SUBROUTINE
      4  290d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  290d
      2  290d		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  2953					      END_LEVEL	_022_L
      1  2953		       00		      .byte.b	0
      2  2953		       00 47	   LEVEL_SIZE__022_L =	* - LEVEL_START
      3  2954				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      4  2954				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      5  2954					      ENDIF
      0  2954					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  2954					      START_LEVEL	_022_R
      1  2954				   LEVEL_START SET	*
      2  2954		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  2954				   LEVEL__022_R SUBROUTINE
      4  2954				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2954
      2  2954		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  2990					      END_LEVEL	_022_R
      1  2990		       00		      .byte.b	0
      2  2990		       00 3d	   LEVEL_SIZE__022_R =	* - LEVEL_START
      3  2991				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      4  2991				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      5  2991					      ENDIF
      0  2991					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  2991					      START_LEVEL	_023_L
      1  2991				   LEVEL_START SET	*
      2  2991		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  2991				   LEVEL__023_L SUBROUTINE
      4  2991				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2991
      2  2991		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29d2					      END_LEVEL	_023_L
      1  29d2		       00		      .byte.b	0
      2  29d2		       00 42	   LEVEL_SIZE__023_L =	* - LEVEL_START
      3  29d3				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      4  29d3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      5  29d3					      ENDIF
      0  29d3					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29d3					      START_LEVEL	_023_R
      1  29d3				   LEVEL_START SET	*
      2  29d3		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29d3				   LEVEL__023_R SUBROUTINE
      4  29d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29d3
      2  29d3		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a15					      END_LEVEL	_023_R
      1  2a15		       00		      .byte.b	0
      2  2a15		       00 43	   LEVEL_SIZE__023_R =	* - LEVEL_START
      3  2a16				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      4  2a16				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      5  2a16					      ENDIF
     44  2a16
      0  2a16					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  2a16					      START_LEVEL	_050_L
      1  2a16				   LEVEL_START SET	*
      2  2a16		       00 05	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  2a16				   LEVEL__050_L SUBROUTINE
      4  2a16				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a16
      2  2a16		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  2a63					      END_LEVEL	_050_L
      1  2a63		       00		      .byte.b	0
      2  2a63		       00 4e	   LEVEL_SIZE__050_L =	* - LEVEL_START
      3  2a64				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      4  2a64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      5  2a64					      ENDIF
      0  2a64					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  2a64					      START_LEVEL	_050_R
      1  2a64				   LEVEL_START SET	*
      2  2a64		       00 05	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  2a64				   LEVEL__050_R SUBROUTINE
      4  2a64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a64
      2  2a64		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  2a9d					      END_LEVEL	_050_R
      1  2a9d		       00		      .byte.b	0
      2  2a9d		       00 3a	   LEVEL_SIZE__050_R =	* - LEVEL_START
      3  2a9e				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      4  2a9e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      5  2a9e					      ENDIF
      0  2a9e					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  2a9e					      START_LEVEL	_051_L
      1  2a9e				   LEVEL_START SET	*
      2  2a9e		       00 05	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  2a9e				   LEVEL__051_L SUBROUTINE
      4  2a9e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a9e
      2  2a9e		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  2af1					      END_LEVEL	_051_L
      1  2af1		       00		      .byte.b	0
      2  2af1		       00 54	   LEVEL_SIZE__051_L =	* - LEVEL_START
      3  2af2				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      4  2af2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      5  2af2					      ENDIF
      0  2af2					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  2af2					      START_LEVEL	_051_R
      1  2af2				   LEVEL_START SET	*
      2  2af2		       00 05	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  2af2				   LEVEL__051_R SUBROUTINE
      4  2af2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2af2
      2  2af2		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  2b43					      END_LEVEL	_051_R
      1  2b43		       00		      .byte.b	0
      2  2b43		       00 52	   LEVEL_SIZE__051_R =	* - LEVEL_START
      3  2b44				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      4  2b44				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      5  2b44					      ENDIF
      0  2b44					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  2b44					      START_LEVEL	_052_L
      1  2b44				   LEVEL_START SET	*
      2  2b44		       00 05	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  2b44				   LEVEL__052_L SUBROUTINE
      4  2b44				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b44
      2  2b44		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  2b7e					      END_LEVEL	_052_L
      1  2b7e		       00		      .byte.b	0
      2  2b7e		       00 3b	   LEVEL_SIZE__052_L =	* - LEVEL_START
      3  2b7f				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      4  2b7f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      5  2b7f					      ENDIF
      0  2b7f					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  2b7f					      START_LEVEL	_052_R
      1  2b7f				   LEVEL_START SET	*
      2  2b7f		       00 05	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  2b7f				   LEVEL__052_R SUBROUTINE
      4  2b7f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b7f
      2  2b7f		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  2bc7					      END_LEVEL	_052_R
      1  2bc7		       00		      .byte.b	0
      2  2bc7		       00 49	   LEVEL_SIZE__052_R =	* - LEVEL_START
      3  2bc8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      4  2bc8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      5  2bc8					      ENDIF
      0  2bc8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  2bc8					      START_LEVEL	_053_L
      1  2bc8				   LEVEL_START SET	*
      2  2bc8		       00 05	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  2bc8				   LEVEL__053_L SUBROUTINE
      4  2bc8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2bc8
      2  2bc8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  2c1d					      END_LEVEL	_053_L
      1  2c1d		       00		      .byte.b	0
      2  2c1d		       00 56	   LEVEL_SIZE__053_L =	* - LEVEL_START
      3  2c1e				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      4  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      5  2c1e					      ENDIF
      0  2c1e					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  2c1e					      START_LEVEL	_053_R
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  2c1e				   LEVEL__053_R SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  2c6b					      END_LEVEL	_053_R
      1  2c6b		       00		      .byte.b	0
      2  2c6b		       00 4e	   LEVEL_SIZE__053_R =	* - LEVEL_START
      3  2c6c				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      4  2c6c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      5  2c6c					      ENDIF
      0  2c6c					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  2c6c					      START_LEVEL	_054_L
      1  2c6c				   LEVEL_START SET	*
      2  2c6c		       00 05	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  2c6c				   LEVEL__054_L SUBROUTINE
      4  2c6c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6c
      2  2c6c		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  2cb8					      END_LEVEL	_054_L
      1  2cb8		       00		      .byte.b	0
      2  2cb8		       00 4d	   LEVEL_SIZE__054_L =	* - LEVEL_START
      3  2cb9				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      4  2cb9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      5  2cb9					      ENDIF
      0  2cb9					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  2cb9					      START_LEVEL	_054_R
      1  2cb9				   LEVEL_START SET	*
      2  2cb9		       00 05	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  2cb9				   LEVEL__054_R SUBROUTINE
      4  2cb9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb9
      2  2cb9		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  2d02					      END_LEVEL	_054_R
      1  2d02		       00		      .byte.b	0
      2  2d02		       00 4a	   LEVEL_SIZE__054_R =	* - LEVEL_START
      3  2d03				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      4  2d03				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      5  2d03					      ENDIF
      0  2d03					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  2d03					      START_LEVEL	_055_L
      1  2d03				   LEVEL_START SET	*
      2  2d03		       00 05	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  2d03				   LEVEL__055_L SUBROUTINE
      4  2d03				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d03
      2  2d03		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  2d5d					      END_LEVEL	_055_L
      1  2d5d		       00		      .byte.b	0
      2  2d5d		       00 5b	   LEVEL_SIZE__055_L =	* - LEVEL_START
      3  2d5e					      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      4  2d5e				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      5  2d5e					      ENDIF
      0  2d5e					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  2d5e					      START_LEVEL	_055_R
      1  2d5e				   LEVEL_START SET	*
      2  2d5e		       00 05	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  2d5e				   LEVEL__055_R SUBROUTINE
      4  2d5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d5e
      2  2d5e		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  2db3					      END_LEVEL	_055_R
      1  2db3		       00		      .byte.b	0
      2  2db3		       00 56	   LEVEL_SIZE__055_R =	* - LEVEL_START
      3  2db4				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      4  2db4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      5  2db4					      ENDIF
      0  2db4					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  2db4					      START_LEVEL	_056_L
      1  2db4				   LEVEL_START SET	*
      2  2db4		       00 05	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  2db4				   LEVEL__056_L SUBROUTINE
      4  2db4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2db4
      2  2db4		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  2e0e					      END_LEVEL	_056_L
      1  2e0e		       00		      .byte.b	0
      2  2e0e		       00 5b	   LEVEL_SIZE__056_L =	* - LEVEL_START
      3  2e0f				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      4  2e0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      5  2e0f					      ENDIF
      0  2e0f					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  2e0f					      START_LEVEL	_056_R
      1  2e0f				   LEVEL_START SET	*
      2  2e0f		       00 05	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  2e0f				   LEVEL__056_R SUBROUTINE
      4  2e0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e0f
      2  2e0f		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  2e6a					      END_LEVEL	_056_R
      1  2e6a		       00		      .byte.b	0
      2  2e6a		       00 5c	   LEVEL_SIZE__056_R =	* - LEVEL_START
      3  2e6b					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      4  2e6b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      5  2e6b					      ENDIF
      0  2e6b					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  2e6b					      START_LEVEL	_057_L
      1  2e6b				   LEVEL_START SET	*
      2  2e6b		       00 05	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  2e6b				   LEVEL__057_L SUBROUTINE
      4  2e6b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e6b
      2  2e6b		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  2ec1					      END_LEVEL	_057_L
      1  2ec1		       00		      .byte.b	0
      2  2ec1		       00 57	   LEVEL_SIZE__057_L =	* - LEVEL_START
      3  2ec2				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      4  2ec2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      5  2ec2					      ENDIF
     60  2ec2
      0  2ec2					      CHECK_BANK_SIZE	"LEVELS2"
      1  2ec2		       06 c2	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $6c2 , FREE= $13e
      2  2ec2					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2ec2				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2ec2				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2ec2				  -	      ERR
      6  2ec2					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 3
      0  2ec2					      include	"BANK_LEVELS3.asm"
      1  2ec2							;    Sokoboo - a Sokoban implementation
      2  2ec2							;    using a generic tile-based display engine for the Atari 2600
      3  2ec2							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2ec2							;
      5  2ec2							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2ec2							;
      7  2ec2							;    Code related to the generic tile-based display engine was developed by
      8  2ec2							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2ec2							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2ec2							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2ec2							;
     12  2ec2							;    Code related to music and sound effects uses the TIATracker music player
     13  2ec2							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2ec2							;    directory for Apache licensing details.
     15  2ec2							;
     16  2ec2							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2ec2							;    See the copyright notices in the License directory for a list of level
     18  2ec2							;    contributors.
     19  2ec2							;
     20  2ec2							;    Except where otherwise indicated, this software is released under the
     21  2ec2							;    following licensing arrangement...
     22  2ec2							;
     23  2ec2							;    This program is free software: you can redistribute it and/or modify
     24  2ec2							;    it under the terms of the GNU General Public License as published by
     25  2ec2							;    the Free Software Foundation, either version 3 of the License, or
     26  2ec2							;    (at your option) any later version.
     27  2ec2							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2ec2
     29  2ec2							;    This program is distributed in the hope that it will be useful,
     30  2ec2							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2ec2							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2ec2							;    GNU General Public License for more details.
     33  2ec2
      0  2ec2					      NEWBANK	LEVELS3
      1  362c ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  3000					      START_LEVEL	_060_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  3000				   LEVEL__060_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  3048					      END_LEVEL	_060_R
      1  3048		       00		      .byte.b	0
      2  3048		       00 49	   LEVEL_SIZE__060_R =	* - LEVEL_START
      3  3049				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      4  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      5  3049					      ENDIF
      0  3049					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  3049					      START_LEVEL	_061_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  3049				   LEVEL__061_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  309d					      END_LEVEL	_061_L
      1  309d		       00		      .byte.b	0
      2  309d		       00 55	   LEVEL_SIZE__061_L =	* - LEVEL_START
      3  309e				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      4  309e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      5  309e					      ENDIF
      0  309e					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  309e					      START_LEVEL	_061_R
      1  309e				   LEVEL_START SET	*
      2  309e		       00 06	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  309e				   LEVEL__061_R SUBROUTINE
      4  309e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  309e
      2  309e		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  30e7					      END_LEVEL	_061_R
      1  30e7		       00		      .byte.b	0
      2  30e7		       00 4a	   LEVEL_SIZE__061_R =	* - LEVEL_START
      3  30e8				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      4  30e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      5  30e8					      ENDIF
      0  30e8					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  30e8					      START_LEVEL	_062_L
      1  30e8				   LEVEL_START SET	*
      2  30e8		       00 06	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  30e8				   LEVEL__062_L SUBROUTINE
      4  30e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30e8
      2  30e8		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  313f					      END_LEVEL	_062_L
      1  313f		       00		      .byte.b	0
      2  313f		       00 58	   LEVEL_SIZE__062_L =	* - LEVEL_START
      3  3140				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      4  3140				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      5  3140					      ENDIF
      0  3140					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  3140					      START_LEVEL	_062_R
      1  3140				   LEVEL_START SET	*
      2  3140		       00 06	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  3140				   LEVEL__062_R SUBROUTINE
      4  3140				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3140
      2  3140		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  318c					      END_LEVEL	_062_R
      1  318c		       00		      .byte.b	0
      2  318c		       00 4d	   LEVEL_SIZE__062_R =	* - LEVEL_START
      3  318d				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      4  318d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      5  318d					      ENDIF
      0  318d					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  318d					      START_LEVEL	_063_L
      1  318d				   LEVEL_START SET	*
      2  318d		       00 06	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  318d				   LEVEL__063_L SUBROUTINE
      4  318d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  318d
      2  318d		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  31dd					      END_LEVEL	_063_L
      1  31dd		       00		      .byte.b	0
      2  31dd		       00 51	   LEVEL_SIZE__063_L =	* - LEVEL_START
      3  31de				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      4  31de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      5  31de					      ENDIF
      0  31de					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  31de					      START_LEVEL	_063_R
      1  31de				   LEVEL_START SET	*
      2  31de		       00 06	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  31de				   LEVEL__063_R SUBROUTINE
      4  31de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31de
      2  31de		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  3230					      END_LEVEL	_063_R
      1  3230		       00		      .byte.b	0
      2  3230		       00 53	   LEVEL_SIZE__063_R =	* - LEVEL_START
      3  3231				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      4  3231				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      5  3231					      ENDIF
      0  3231					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  3231					      START_LEVEL	_064_L
      1  3231				   LEVEL_START SET	*
      2  3231		       00 06	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  3231				   LEVEL__064_L SUBROUTINE
      4  3231				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3231
      2  3231		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  328c					      END_LEVEL	_064_L
      1  328c		       00		      .byte.b	0
      2  328c		       00 5c	   LEVEL_SIZE__064_L =	* - LEVEL_START
      3  328d				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      4  328d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      5  328d					      ENDIF
      0  328d					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  328d					      START_LEVEL	_064_R
      1  328d				   LEVEL_START SET	*
      2  328d		       00 06	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  328d				   LEVEL__064_R SUBROUTINE
      4  328d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  328d
      2  328d		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  32d9					      END_LEVEL	_064_R
      1  32d9		       00		      .byte.b	0
      2  32d9		       00 4d	   LEVEL_SIZE__064_R =	* - LEVEL_START
      3  32da				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      4  32da				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      5  32da					      ENDIF
      0  32da					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  32da					      START_LEVEL	_065_L
      1  32da				   LEVEL_START SET	*
      2  32da		       00 06	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  32da				   LEVEL__065_L SUBROUTINE
      4  32da				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32da
      2  32da		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  3332					      END_LEVEL	_065_L
      1  3332		       00		      .byte.b	0
      2  3332		       00 59	   LEVEL_SIZE__065_L =	* - LEVEL_START
      3  3333				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      4  3333				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      5  3333					      ENDIF
      0  3333					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  3333					      START_LEVEL	_065_R
      1  3333				   LEVEL_START SET	*
      2  3333		       00 06	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  3333				   LEVEL__065_R SUBROUTINE
      4  3333				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3333
      2  3333		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  337b					      END_LEVEL	_065_R
      1  337b		       00		      .byte.b	0
      2  337b		       00 49	   LEVEL_SIZE__065_R =	* - LEVEL_START
      3  337c				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      4  337c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      5  337c					      ENDIF
      0  337c					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  337c					      START_LEVEL	_066_L
      1  337c				   LEVEL_START SET	*
      2  337c		       00 06	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  337c				   LEVEL__066_L SUBROUTINE
      4  337c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  337c
      2  337c		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  33d6					      END_LEVEL	_066_L
      1  33d6		       00		      .byte.b	0
      2  33d6		       00 5b	   LEVEL_SIZE__066_L =	* - LEVEL_START
      3  33d7				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      4  33d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      5  33d7					      ENDIF
      0  33d7					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  33d7					      START_LEVEL	_066_R
      1  33d7				   LEVEL_START SET	*
      2  33d7		       00 06	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  33d7				   LEVEL__066_R SUBROUTINE
      4  33d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33d7
      2  33d7		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  342d					      END_LEVEL	_066_R
      1  342d		       00		      .byte.b	0
      2  342d		       00 57	   LEVEL_SIZE__066_R =	* - LEVEL_START
      3  342e				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      4  342e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      5  342e					      ENDIF
      0  342e					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  342e					      START_LEVEL	_067_L
      1  342e				   LEVEL_START SET	*
      2  342e		       00 06	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  342e				   LEVEL__067_L SUBROUTINE
      4  342e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342e
      2  342e		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  347b					      END_LEVEL	_067_L
      1  347b		       00		      .byte.b	0
      2  347b		       00 4e	   LEVEL_SIZE__067_L =	* - LEVEL_START
      3  347c				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      4  347c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      5  347c					      ENDIF
      0  347c					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  347c					      START_LEVEL	_067_R
      1  347c				   LEVEL_START SET	*
      2  347c		       00 06	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  347c				   LEVEL__067_R SUBROUTINE
      4  347c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347c
      2  347c		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  34e1					      END_LEVEL	_067_R
      1  34e1		       00		      .byte.b	0
      2  34e1		       00 66	   LEVEL_SIZE__067_R =	* - LEVEL_START
      3  34e2					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      4  34e2				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      5  34e2					      ENDIF
      0  34e2					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  34e2					      START_LEVEL	_068_L
      1  34e2				   LEVEL_START SET	*
      2  34e2		       00 06	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  34e2				   LEVEL__068_L SUBROUTINE
      4  34e2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34e2
      2  34e2		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  3536					      END_LEVEL	_068_L
      1  3536		       00		      .byte.b	0
      2  3536		       00 55	   LEVEL_SIZE__068_L =	* - LEVEL_START
      3  3537				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      4  3537				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      5  3537					      ENDIF
      0  3537					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  3537					      START_LEVEL	_068_R
      1  3537				   LEVEL_START SET	*
      2  3537		       00 06	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  3537				   LEVEL__068_R SUBROUTINE
      4  3537				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3537
      2  3537		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  358d					      END_LEVEL	_068_R
      1  358d		       00		      .byte.b	0
      2  358d		       00 57	   LEVEL_SIZE__068_R =	* - LEVEL_START
      3  358e				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      4  358e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      5  358e					      ENDIF
      0  358e					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  358e					      START_LEVEL	_069_L
      1  358e				   LEVEL_START SET	*
      2  358e		       00 06	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  358e				   LEVEL__069_L SUBROUTINE
      4  358e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  358e
      2  358e		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  35dc					      END_LEVEL	_069_L
      1  35dc		       00		      .byte.b	0
      2  35dc		       00 4f	   LEVEL_SIZE__069_L =	* - LEVEL_START
      3  35dd				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      4  35dd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      5  35dd					      ENDIF
      0  35dd					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  35dd					      START_LEVEL	_069_R
      1  35dd				   LEVEL_START SET	*
      2  35dd		       00 06	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  35dd				   LEVEL__069_R SUBROUTINE
      4  35dd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35dd
      2  35dd		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  362b					      END_LEVEL	_069_R
      1  362b		       00		      .byte.b	0
      2  362b		       00 4f	   LEVEL_SIZE__069_R =	* - LEVEL_START
      3  362c				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      4  362c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      5  362c					      ENDIF
     55  362c
     56  362c
     57  362c
      0  362c					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  362c		       06 2c	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $62c , FREE= $1d4
      2  362c					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  362c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  362c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  362c				  -	      ERR
      6  362c					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 3
      0  362c					      include	"BANK_LEVELS4.asm"
      1  362c							;    Sokoboo - a Sokoban implementation
      2  362c							;    using a generic tile-based display engine for the Atari 2600
      3  362c							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  362c							;
      5  362c							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  362c							;
      7  362c							;    Code related to the generic tile-based display engine was developed by
      8  362c							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  362c							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  362c							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  362c							;
     12  362c							;    Code related to music and sound effects uses the TIATracker music player
     13  362c							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  362c							;    directory for Apache licensing details.
     15  362c							;
     16  362c							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  362c							;    See the copyright notices in the License directory for a list of level
     18  362c							;    contributors.
     19  362c							;
     20  362c							;    Except where otherwise indicated, this software is released under the
     21  362c							;    following licensing arrangement...
     22  362c							;
     23  362c							;    This program is free software: you can redistribute it and/or modify
     24  362c							;    it under the terms of the GNU General Public License as published by
     25  362c							;    the Free Software Foundation, either version 3 of the License, or
     26  362c							;    (at your option) any later version.
     27  362c							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  362c
     29  362c							;    This program is distributed in the hope that it will be useful,
     30  362c							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  362c							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  362c							;    GNU General Public License for more details.
     33  362c
     34  362c							; level definitions
     35  362c							; Sample level definitions.
     36  362c							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  362c							; have as many banks as you like.
     38  362c
      0  362c					      NEWBANK	LEVELS4
      1  3db3 ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
     41  3800							; Level definitions
     42  3800
     43  3800							; "sokhard" collection
     44  3800
      0  3800					      START_LEVEL	_102_Natalie
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  3800				   LEVEL__102_Natalie SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
     46  3800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  3846					      END_LEVEL	_102_Natalie
      1  3846		       00		      .byte.b	0
      2  3846		       00 47	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      3  3847				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      4  3847				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      5  3847					      ENDIF
     48  3847
      0  3847					      START_LEVEL	_102_Mirabel
      1  3847				   LEVEL_START SET	*
      2  3847		       00 07	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  3847				   LEVEL__102_Mirabel SUBROUTINE
      4  3847				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3847
     50  3847		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  38a6					      END_LEVEL	_102_Mirabel
      1  38a6		       00		      .byte.b	0
      2  38a6		       00 60	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      3  38a7				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      4  38a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      5  38a7					      ENDIF
     52  38a7
      0  38a7					      START_LEVEL	_102_Oralia
      1  38a7				   LEVEL_START SET	*
      2  38a7		       00 07	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  38a7				   LEVEL__102_Oralia SUBROUTINE
      4  38a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38a7
     54  38a7		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  38eb					      END_LEVEL	_102_Oralia
      1  38eb		       00		      .byte.b	0
      2  38eb		       00 45	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      3  38ec				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      4  38ec				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      5  38ec					      ENDIF
     56  38ec
     57  38ec
     58  38ec							;---------------------------------------------------------------------------------------------------
     59  38ec							; IMAGE IS ABOVE DEFINITION
     60  38ec
     61  38ec							;  ###########
     62  38ec							;  #  #      #
     63  38ec							;  # $# $ $$ #
     64  38ec							;  #  ##$#$  #
     65  38ec							;  #  $    #@#
     66  38ec							;  # $## #  ##
     67  38ec							;  ##	# .## #
     68  38ec							;  ##$ #.*. ##
     69  38ec							;  # ..*. *. #
     70  38ec							;  # # .. #  #
     71  38ec							;  ###########
     72  38ec
      0  38ec					      START_LEVEL	_102_Raven
      1  38ec				   LEVEL_START SET	*
      2  38ec		       00 07	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  38ec				   LEVEL__102_Raven SUBROUTINE
      4  38ec				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38ec
     74  38ec		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  395a					      END_LEVEL	_102_Raven
      1  395a		       00		      .byte.b	0
      2  395a		       00 6f	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      3  395b					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      4  395b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      5  395b					      ENDIF
     76  395b
     77  395b							;  ############
     78  395b							;  #@##. #  # #
     79  395b							;  #**..$#    #
     80  395b							;  #. $..#  # #
     81  395b							;  # $#.$#$$$ #
     82  395b							;  #	      ##
     83  395b							;  #  ##  #   #
     84  395b							;  ############
     85  395b
      0  395b					      START_LEVEL	_103_Adin
      1  395b				   LEVEL_START SET	*
      2  395b		       00 07	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  395b				   LEVEL__103_Adin SUBROUTINE
      4  395b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  395b
     87  395b		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  39a6					      END_LEVEL	_103_Adin
      1  39a6		       00		      .byte.b	0
      2  39a6		       00 4c	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      3  39a7				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      4  39a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      5  39a7					      ENDIF
     89  39a7
     90  39a7							;  #######___
     91  39a7							;  #	  #___
     92  39a7							;  #	$$#___
     93  39a7							;  #.*  .#___
     94  39a7							;  #$*$#*###_
     95  39a7							;  #@*... .#_
     96  39a7							;  #####$ .##
     97  39a7							;  ___# $ $ #
     98  39a7							;  ___#     #
     99  39a7							;  ___#######	(_ = modified by boo from wall)
    100  39a7
      0  39a7					      START_LEVEL	_103_Ajalae
      1  39a7				   LEVEL_START SET	*
      2  39a7		       00 07	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  39a7				   LEVEL__103_Ajalae SUBROUTINE
      4  39a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39a7
    102  39a7		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  39ee					      END_LEVEL	_103_Ajalae
      1  39ee		       00		      .byte.b	0
      2  39ee		       00 48	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      3  39ef				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      4  39ef				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      5  39ef					      ENDIF
    104  39ef
    105  39ef							;  ############
    106  39ef							;  #@#  #     #
    107  39ef							;  #  # #$#$# #
    108  39ef							;  # *$       #
    109  39ef							;  #..##$#$   #
    110  39ef							;  #..#. #  $ #
    111  39ef							;  #....# $$$##
    112  39ef							;  #	       #
    113  39ef							;  ############
    114  39ef
      0  39ef					      START_LEVEL	_103_Arielle
      1  39ef				   LEVEL_START SET	*
      2  39ef		       00 07	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  39ef				   LEVEL__103_Arielle SUBROUTINE
      4  39ef				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39ef
    116  39ef		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  3a3f					      END_LEVEL	_103_Arielle
      1  3a3f		       00		      .byte.b	0
      2  3a3f		       00 51	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      3  3a40				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      4  3a40				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      5  3a40					      ENDIF
    118  3a40
    119  3a40
    120  3a40
      0  3a40					      START_LEVEL	_1XJH_Tara_Gelson
      1  3a40				   LEVEL_START SET	*
      2  3a40		       00 07	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  3a40				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  3a40				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a40
    122  3a40		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  3a7a					      END_LEVEL	_1XJH_Tara_Gelson
      1  3a7a		       00		      .byte.b	0
      2  3a7a		       00 3b	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      3  3a7b				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      4  3a7b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      5  3a7b					      ENDIF
    124  3a7b
      0  3a7b					      START_LEVEL	_1R7X_Alison
      1  3a7b				   LEVEL_START SET	*
      2  3a7b		       00 07	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  3a7b				   LEVEL__1R7X_Alison SUBROUTINE
      4  3a7b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a7b
    126  3a7b		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  3aa8					      END_LEVEL	_1R7X_Alison
      1  3aa8		       00		      .byte.b	0
      2  3aa8		       00 2e	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      3  3aa9				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      4  3aa9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      5  3aa9					      ENDIF
    128  3aa9
      0  3aa9					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  3aa9				   LEVEL_START SET	*
      2  3aa9		       00 07	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  3aa9				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  3aa9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3aa9
    130  3aa9		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  3add					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  3add		       00		      .byte.b	0
      2  3add		       00 35	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      3  3ade				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      4  3ade				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      5  3ade					      ENDIF
    132  3ade
      0  3ade					      START_LEVEL	_1EKT_Samantha_Gelson
      1  3ade				   LEVEL_START SET	*
      2  3ade		       00 07	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  3ade				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  3ade				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ade
    134  3ade		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  3b17					      END_LEVEL	_1EKT_Samantha_Gelson
      1  3b17		       00		      .byte.b	0
      2  3b17		       00 3a	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      3  3b18				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      4  3b18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      5  3b18					      ENDIF
    136  3b18
      0  3b18					      START_LEVEL	_0VM5_Andrea_Wadd
      1  3b18				   LEVEL_START SET	*
      2  3b18		       00 07	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  3b18				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  3b18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b18
    138  3b18		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  3b45					      END_LEVEL	_0VM5_Andrea_Wadd
      1  3b45		       00		      .byte.b	0
      2  3b45		       00 2e	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      3  3b46				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      4  3b46				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      5  3b46					      ENDIF
    140  3b46
      0  3b46					      START_LEVEL	_0PAL_Jill_Leatherby
      1  3b46				   LEVEL_START SET	*
      2  3b46		       00 07	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  3b46				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  3b46				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b46
    142  3b46		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  3b70					      END_LEVEL	_0PAL_Jill_Leatherby
      1  3b70		       00		      .byte.b	0
      2  3b70		       00 2b	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      3  3b71				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      4  3b71				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      5  3b71					      ENDIF
    144  3b71
      0  3b71					      START_LEVEL	_0IZ1_Sophia
      1  3b71				   LEVEL_START SET	*
      2  3b71		       00 07	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  3b71				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  3b71				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b71
    146  3b71		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  3b9c					      END_LEVEL	_0IZ1_Sophia
      1  3b9c		       00		      .byte.b	0
      2  3b9c		       00 2c	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      3  3b9d				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      4  3b9d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      5  3b9d					      ENDIF
    148  3b9d
      0  3b9d					      START_LEVEL	_0CNH_Alice
      1  3b9d				   LEVEL_START SET	*
      2  3b9d		       00 07	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  3b9d				   LEVEL__0CNH_Alice SUBROUTINE
      4  3b9d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b9d
    150  3b9d		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  3bc9					      END_LEVEL	_0CNH_Alice
      1  3bc9		       00		      .byte.b	0
      2  3bc9		       00 2d	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      3  3bca				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      4  3bca				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      5  3bca					      ENDIF
    152  3bca
    153  3bca							;  START_LEVEL TowC
    154  3bca							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    155  3bca							;  END_LEVEL TowC
    156  3bca
    157  3bca							;  START_LEVEL SimpleC
    158  3bca							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    159  3bca							;  END_LEVEL SimpleC
    160  3bca
      0  3bca					      START_LEVEL	bAlfa_DrFogh
      1  3bca				   LEVEL_START SET	*
      2  3bca		       00 07	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  3bca				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  3bca				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bca
    162  3bca		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  3c71					      END_LEVEL	bAlfa_DrFogh
      1  3c71		       00		      .byte.b	0
      2  3c71		       00 a8	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      3  3c72					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      4  3c72				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      5  3c72					      ENDIF
    164  3c72
      0  3c72					      START_LEVEL	b51X_Sharpen
      1  3c72				   LEVEL_START SET	*
      2  3c72		       00 07	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  3c72				   LEVEL_b51X_Sharpen SUBROUTINE
      4  3c72				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c72
    166  3c72		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  3cf2					      END_LEVEL	b51X_Sharpen
      1  3cf2		       00		      .byte.b	0
      2  3cf2		       00 81	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      3  3cf3				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      4  3cf3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      5  3cf3					      ENDIF
    168  3cf3
      0  3cf3					      START_LEVEL	bDarcy_Burnsell101
      1  3cf3				   LEVEL_START SET	*
      2  3cf3		       00 07	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  3cf3				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  3cf3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cf3
    170  3cf3		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  3d2f					      END_LEVEL	bDarcy_Burnsell101
      1  3d2f		       00		      .byte.b	0
      2  3d2f		       00 3d	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      3  3d30				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      4  3d30				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      5  3d30					      ENDIF
    172  3d30
      0  3d30					      START_LEVEL	bAislin101
      1  3d30				   LEVEL_START SET	*
      2  3d30		       00 07	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  3d30				   LEVEL_bAislin101 SUBROUTINE
      4  3d30				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d30
    174  3d30		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  3d6c					      END_LEVEL	bAislin101
      1  3d6c		       00		      .byte.b	0
      2  3d6c		       00 3d	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      3  3d6d				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      4  3d6d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      5  3d6d					      ENDIF
    176  3d6d
    177  3d6d							;  START_LEVEL b82X_Sharpen
    178  3d6d							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    179  3d6d							;  END_LEVEL b82X_Sharpen
    180  3d6d
      0  3d6d					      START_LEVEL	Thomas_Reinke16
      1  3d6d				   LEVEL_START SET	*
      2  3d6d		       00 07	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  3d6d				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  3d6d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d6d
    182  3d6d		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  3db2					      END_LEVEL	Thomas_Reinke16
      1  3db2		       00		      .byte.b	0
      2  3db2		       00 46	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      3  3db3				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      4  3db3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      5  3db3					      ENDIF
    184  3db3
    185  3db3							;Level element	Character	ASCII Code
    186  3db3							;Wall	#	0x23
    187  3db3							;Player	@	0x40
    188  3db3							;Player on goal square	+	0x2b
    189  3db3							;Box	$	0x24
    190  3db3							;Box on goal square	*	0x2a
    191  3db3							;Goal square	.	0x2e
    192  3db3							;Floor	(Space)	0x20 or underscore
    193  3db3
    194  3db3							;This level ("Claire", by Lee J Haywood):
    195  3db3
    196  3db3							;#######
    197  3db3							;#.@ # #
    198  3db3							;#$* $ #
    199  3db3							;#   $ #
    200  3db3							;# ..	#
    201  3db3							;#  *	#
    202  3db3							;#######
    203  3db3							;runlength encoded looks like this:
    204  3db3
    205  3db3							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    206  3db3
    207  3db3							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    208  3db3
    209  3db3
      0  3db3					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3db3		       05 b3	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $5b3 , FREE= $24d
      2  3db3					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3db3				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3db3				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3db3				  -	      ERR
      6  3db3					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  3db3					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  3db3							;    Sokoboo - a Sokoban implementation
      2  3db3							;    using a generic tile-based display engine for the Atari 2600
      3  3db3							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3db3							;
      5  3db3							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3db3							;
      7  3db3							;    Code related to the generic tile-based display engine was developed by
      8  3db3							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3db3							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3db3							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3db3							;
     12  3db3							;    Code related to music and sound effects uses the TIATracker music player
     13  3db3							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3db3							;    directory for Apache licensing details.
     15  3db3							;
     16  3db3							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3db3							;    See the copyright notices in the License directory for a list of level
     18  3db3							;    contributors.
     19  3db3							;
     20  3db3							;    Except where otherwise indicated, this software is released under the
     21  3db3							;    following licensing arrangement...
     22  3db3							;
     23  3db3							;    This program is free software: you can redistribute it and/or modify
     24  3db3							;    it under the terms of the GNU General Public License as published by
     25  3db3							;    the Free Software Foundation, either version 3 of the License, or
     26  3db3							;    (at your option) any later version.
     27  3db3							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3db3
     29  3db3							;    This program is distributed in the hope that it will be useful,
     30  3db3							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3db3							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3db3							;    GNU General Public License for more details.
     33  3db3
      0  3db3					      NEWBANK	INITBANK
      1  433b ????				      SEG	INITBANK
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   INITBANK   SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	INITBANK
     35  4000
     36  4000		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  4001
      0  4001					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  4001		       00 08	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  4001					      SUBROUTINE
      3  4001				   BoardLineStartLO
     39  4001
     40  4001							; Gives the start address (LO) of each board line
     41  4001
     42  4001				   .BOARD_LOCATION SET	Board
     43  4001					      REPEAT	SIZE_BOARD_Y
     44  4001				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4001				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4001					      ENDIF
     47  4001		       00		      .byte.b	<.BOARD_LOCATION
     48  4001				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4001					      REPEND
     44  4002				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4002				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4002					      ENDIF
     47  4002		       28		      .byte.b	<.BOARD_LOCATION
     48  4002				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4002					      REPEND
     44  4003				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4003				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4003					      ENDIF
     47  4003		       50		      .byte.b	<.BOARD_LOCATION
     48  4003				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4003					      REPEND
     44  4004				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4004				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4004					      ENDIF
     47  4004		       78		      .byte.b	<.BOARD_LOCATION
     48  4004				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4004					      REPEND
     44  4005				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4005				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4005					      ENDIF
     47  4005		       a0		      .byte.b	<.BOARD_LOCATION
     48  4005				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4005					      REPEND
     44  4006				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4006				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4006					      ENDIF
     47  4006		       c8		      .byte.b	<.BOARD_LOCATION
     48  4006				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4006					      REPEND
     44  4007					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4007				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4007					      ENDIF
     47  4007		       00		      .byte.b	<.BOARD_LOCATION
     48  4007				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4007					      REPEND
     44  4008				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4008				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4008					      ENDIF
     47  4008		       28		      .byte.b	<.BOARD_LOCATION
     48  4008				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4008					      REPEND
     44  4009				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4009				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4009					      ENDIF
     47  4009		       50		      .byte.b	<.BOARD_LOCATION
     48  4009				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4009					      REPEND
     44  400a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400a					      ENDIF
     47  400a		       78		      .byte.b	<.BOARD_LOCATION
     48  400a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400a					      REPEND
     44  400b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400b					      ENDIF
     47  400b		       a0		      .byte.b	<.BOARD_LOCATION
     48  400b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400b					      REPEND
     44  400c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400c					      ENDIF
     47  400c		       c8		      .byte.b	<.BOARD_LOCATION
     48  400c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400c					      REPEND
     44  400d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400d					      ENDIF
     47  400d		       00		      .byte.b	<.BOARD_LOCATION
     48  400d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400d					      REPEND
     44  400e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400e					      ENDIF
     47  400e		       28		      .byte.b	<.BOARD_LOCATION
     48  400e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400e					      REPEND
     44  400f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400f					      ENDIF
     47  400f		       50		      .byte.b	<.BOARD_LOCATION
     48  400f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400f					      REPEND
     44  4010				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4010				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4010					      ENDIF
     47  4010		       78		      .byte.b	<.BOARD_LOCATION
     48  4010				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4010					      REPEND
     44  4011				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4011				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4011					      ENDIF
     47  4011		       a0		      .byte.b	<.BOARD_LOCATION
     48  4011				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4011					      REPEND
     44  4012				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4012				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4012					      ENDIF
     47  4012		       c8		      .byte.b	<.BOARD_LOCATION
     48  4012				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4012					      REPEND
     44  4013					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4013				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4013					      ENDIF
     47  4013		       00		      .byte.b	<.BOARD_LOCATION
     48  4013				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4013					      REPEND
     44  4014				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4014				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4014					      ENDIF
     47  4014		       28		      .byte.b	<.BOARD_LOCATION
     48  4014				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4014					      REPEND
     44  4015				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4015				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4015					      ENDIF
     47  4015		       50		      .byte.b	<.BOARD_LOCATION
     48  4015				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4015					      REPEND
     44  4016				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4016				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4016					      ENDIF
     47  4016		       78		      .byte.b	<.BOARD_LOCATION
     48  4016				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  4017					      REPEND
      0  4017					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  4017					      LIST	ON
     51  4017
     52  4017		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  4017
     54  4017							;------------------------------------------------------------------------------
     55  4017
     56  4017				   BoardLineStartHiR
     57  4017
     58  4017							; Gives the start address (HI) of each board line
     59  4017							; Note this caters for the memory wrapping when we go from bank to bank, as
     60  4017							; the board overlays multiple banks!
     61  4017
     62  4017				   .BOARD_LOCATION SET	Board
     63  4017					      REPEAT	SIZE_BOARD_Y
     64  4017				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4017				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4017					      ENDIF
     67  4017		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4017				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4017					      REPEND
     64  4018				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4018				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4018					      ENDIF
     67  4018		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4018				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4018					      REPEND
     64  4019				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4019				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4019					      ENDIF
     67  4019		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4019				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4019					      REPEND
     64  401a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401a					      ENDIF
     67  401a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401a					      REPEND
     64  401b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401b					      ENDIF
     67  401b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401b					      REPEND
     64  401c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401c					      ENDIF
     67  401c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401c					      REPEND
     64  401d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401d					      ENDIF
     67  401d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401d					      REPEND
     64  401e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401e					      ENDIF
     67  401e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401e					      REPEND
     64  401f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401f					      ENDIF
     67  401f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401f					      REPEND
     64  4020				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4020				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4020					      ENDIF
     67  4020		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4020				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4020					      REPEND
     64  4021				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4021				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4021					      ENDIF
     67  4021		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4021				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4021					      REPEND
     64  4022				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4022				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4022					      ENDIF
     67  4022		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4022				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4022					      REPEND
     64  4023					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4023				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4023					      ENDIF
     67  4023		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4023				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4023					      REPEND
     64  4024				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4024				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4024					      ENDIF
     67  4024		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4024				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4024					      REPEND
     64  4025				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4025				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4025					      ENDIF
     67  4025		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4025				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4025					      REPEND
     64  4026				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4026				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4026					      ENDIF
     67  4026		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4026				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4026					      REPEND
     64  4027				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4027				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4027					      ENDIF
     67  4027		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4027				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4027					      REPEND
     64  4028				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4028				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4028					      ENDIF
     67  4028		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4028				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4028					      REPEND
     64  4029					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4029				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4029					      ENDIF
     67  4029		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4029				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4029					      REPEND
     64  402a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  402a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  402a					      ENDIF
     67  402a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  402a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  402a					      REPEND
     64  402b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  402b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  402b					      ENDIF
     67  402b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  402b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  402b					      REPEND
     64  402c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  402c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  402c					      ENDIF
     67  402c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  402c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     69  402d					      REPEND
      0  402d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  402d					      LIST	ON
     71  402d							;------------------------------------------------------------------------------
     72  402d
     73  402d				   BoardLineStartHiW
     74  402d
     75  402d							; Gives the start address (HI) of each board line
     76  402d							; Note this caters for the memory wrapping when we go from bank to bank, as
     77  402d							; the board overlays multiple banks!
     78  402d
     79  402d				   .BOARD_LOCATION SET	Board
     80  402d					      REPEAT	SIZE_BOARD_Y
     81  402d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  402d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  402d					      ENDIF
     84  402d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  402d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  402d					      REPEND
     81  402e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  402e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  402e					      ENDIF
     84  402e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  402e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  402e					      REPEND
     81  402f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  402f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  402f					      ENDIF
     84  402f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  402f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  402f					      REPEND
     81  4030				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4030				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4030					      ENDIF
     84  4030		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4030				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4030					      REPEND
     81  4031				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4031				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4031					      ENDIF
     84  4031		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4031				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4031					      REPEND
     81  4032				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4032				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4032					      ENDIF
     84  4032		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4032				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4032					      REPEND
     81  4033					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4033				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4033					      ENDIF
     84  4033		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4033				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4033					      REPEND
     81  4034				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4034				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4034					      ENDIF
     84  4034		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4034				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4034					      REPEND
     81  4035				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4035				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4035					      ENDIF
     84  4035		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4035				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4035					      REPEND
     81  4036				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4036				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4036					      ENDIF
     84  4036		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4036				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4036					      REPEND
     81  4037				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4037				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4037					      ENDIF
     84  4037		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4037				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4037					      REPEND
     81  4038				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4038				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4038					      ENDIF
     84  4038		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4038				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4038					      REPEND
     81  4039					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4039				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4039					      ENDIF
     84  4039		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4039				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4039					      REPEND
     81  403a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403a					      ENDIF
     84  403a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403a					      REPEND
     81  403b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403b					      ENDIF
     84  403b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403b					      REPEND
     81  403c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403c					      ENDIF
     84  403c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403c					      REPEND
     81  403d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403d					      ENDIF
     84  403d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403d					      REPEND
     81  403e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403e					      ENDIF
     84  403e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403e					      REPEND
     81  403f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403f					      ENDIF
     84  403f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403f					      REPEND
     81  4040				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4040				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4040					      ENDIF
     84  4040		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4040				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4040					      REPEND
     81  4041				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4041				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4041					      ENDIF
     84  4041		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4041				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4041					      REPEND
     81  4042				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4042				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4042					      ENDIF
     84  4042		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4042				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     86  4043					      REPEND
      0  4043					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  4043					      LIST	ON
     88  4043
     89  4043							;------------------------------------------------------------------------------
     90  4043				  -	      IF	MULTI_BANK_BOARD = YES
     91  4043				  -BoardBank
     92  4043					      ENDIF
     93  4043							; Gives the RAM bank of the start of the board row for a given row.
     94  4043
     95  4043				   .BOARD_LOCATION SET	Board - RAM_3E
     96  4043					      REPEAT	SIZE_BOARD_Y
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    104  4043					      REPEND
    105  4043				  -	      IF	MULTI_BANK_BOARD = YES
    106  4043				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
    107  4043					      ENDIF
    108  4043
    109  4043
    110  4043							;------------------------------------------------------------------------------
    111  4043
    112  4043				   CopyROMShadowToRAM_F000
    113  4043		       a9 f0		      lda	#>$F000
    114  4045
      0  4045					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  4045		       00 08	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  4045					      SUBROUTINE
      3  4045				   CopyROMShadowToRAM
    116  4045
    117  4045							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    118  4045							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    119  4045							; of the variable contents from ROM declarations, but still allows access to them as
    120  4045							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    121  4045							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    122  4045							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    123  4045							; code co-lives in all banks and may run even as bankswitching occurs between those
    124  4045							; banks -- by the very code itself.
    125  4045
    126  4045							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    127  4045		       85 bf		      sta	Board_AddressR+1
    128  4047		       86 d9		      stx	O_ROM_Source_Bank	; source bank
    129  4049		       84 c3		      sty	RAM_Bank	; destination bank
    130  404b
    131  404b		       a0 00		      ldy	#0
    132  404d		       84 be		      sty	Board_AddressR
    133  404f		       84 c0		      sty	Board_AddressW
    134  4051		       a9 14		      lda	#>($1000+RAM_WRITE)
    135  4053		       85 c1		      sta	Board_AddressW+1
    136  4055
    137  4055							; Iterate 4 pages (1K) for complete bank copy
    138  4055
    139  4055		       a9 04		      lda	#4
    140  4057		       85 d8		      sta	O_CopyCount
    141  4059
    142  4059		       84 da	   CopyPage   sty	O_Index
    143  405b		       a5 d9		      lda	O_ROM_Source_Bank
    144  405d		       20 12 f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    145  4060							;tax
    146  4060		       a4 da		      ldy	O_Index
    147  4062		       a6 c3		      ldx	RAM_Bank
    148  4064		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    149  4067
    150  4067		       a4 da		      ldy	O_Index
    151  4069		       c8		      iny
    152  406a		       d0 ed		      bne	CopyPage
    153  406c
    154  406c		       e6 bf		      inc	Board_AddressR+1
    155  406e		       e6 c1		      inc	Board_AddressW+1
    156  4070
    157  4070		       c6 d8		      dec	O_CopyCount
    158  4072		       d0 e5		      bne	CopyPage
    159  4074
    160  4074		       a4 c3		      ldy	RAM_Bank	; TODO: remove!?
    161  4076		       60		      rts
    162  4077
    163  4077
    164  4077							;------------------------------------------------------------------------------
      0  4077					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  4077		       00 08	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  4077					      SUBROUTINE
      3  4077				   SetPlatformColours
    166  4077
    167  4077							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    168  4077							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    169  4077							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    170  4077							; addressing will not violate the page-crossing restriction of 3E.
    171  4077
    172  4077							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    173  4077
    174  4077		       a9 00		      lda	#<DrawTheScreen	; = 0
    175  4079		       85 c0		      sta	Board_AddressW
    176  407b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    177  407d		       85 c1		      sta	Board_AddressW+1
    178  407f
    179  407f							; first, set the x index (with last one being a RTS ($60))
    180  407f
    181  407f		       a6 c3		      ldx	RAM_Bank
    182  4081		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    183  4083		       d0 07		      bne	.skipPatch
    184  4085		       a9 60		      lda	#$60	; rts
    185  4087		       a0 41		      ldy	#<SELFMOD_X
    186  4089		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    187  408c				   .skipPatch
    188  408c
    189  408c		       a2 02		      ldx	#3-1
    190  408e				   .loopColor
    191  408e		       86 d8		      stx	colorIdx
    192  4090							; set PF colors
    193  4090		       b5 bb		      lda	color,x
    194  4092		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    195  4095							;tax
    196  4095		       a6 c3		      ldx	RAM_Bank
    197  4097		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    198  409a							; set player colors
    199  409a		       a6 d8		      ldx	colorIdx
    200  409c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    201  409f		       a4 81		      ldy	Platform
    202  40a1		       c0 02		      cpy	#PAL
    203  40a3		       90 02		      bcc	.platform0
    204  40a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    205  40a7				   .platform0
    206  40a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    207  40aa							;tax
    208  40aa		       a6 c3		      ldx	RAM_Bank
    209  40ac		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    210  40af							; loop
    211  40af		       a6 d8		      ldx	colorIdx
    212  40b1		       ca		      dex
    213  40b2		       10 da		      bpl	.loopColor
    214  40b4
    215  40b4		       a4 c3		      ldy	RAM_Bank
    216  40b6		       60		      rts
    217  40b7
    218  40b7				   SelfModColOfsTbl
    219  40b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    220  40ba				   SelfModePlayerTbl
    221  40ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    222  40bd				   SelfModPlayerColOfsTbl
    223  40bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    224  40c0
    225  40c0
    226  40c0				   DrawLineStartLO
    227  40c0
    228  40c0							; Gives the start address of each line in the draw flags buffer
    229  40c0
    230  40c0				   .DRAW_LOCATION SET	DrawFlag
    231  40c0					      REPEAT	SCREEN_LINES
    232  40c0		       50		      .byte.b	<.DRAW_LOCATION
    233  40c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c0					      REPEND
    232  40c1		       5a		      .byte.b	<.DRAW_LOCATION
    233  40c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c1					      REPEND
    232  40c2		       64		      .byte.b	<.DRAW_LOCATION
    233  40c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c2					      REPEND
    232  40c3		       6e		      .byte.b	<.DRAW_LOCATION
    233  40c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c3					      REPEND
    232  40c4		       78		      .byte.b	<.DRAW_LOCATION
    233  40c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c4					      REPEND
    232  40c5		       82		      .byte.b	<.DRAW_LOCATION
    233  40c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c5					      REPEND
    232  40c6		       8c		      .byte.b	<.DRAW_LOCATION
    233  40c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c6					      REPEND
    232  40c7		       96		      .byte.b	<.DRAW_LOCATION
    233  40c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    234  40c8					      REPEND
    235  40c8
    236  40c8
    237  40c8							;------------------------------------------------------------------------------
    238  40c8
      0  40c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  40c8		       00 08	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  40c8					      SUBROUTINE
      3  40c8				   GetBoardAddressRW
    240  40c8							; Must share same bank as BoardLineStart tables
    241  40c8
    242  40c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    243  40cb		       85 be		      sta	Board_AddressR	; 3
    244  40cd		       85 c0		      sta	Board_AddressW	; 3
    245  40cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    246  40d2		       85 bf		      sta	Board_AddressR+1	; 3	     READ address
    247  40d4		       09 04		      ora	#>RAM_WRITE	; 2
    248  40d6		       85 c1		      sta	Board_AddressW+1	; 3	     WRITE address
    249  40d8				  -	      IF	MULTI_BANK_BOARD = YES
    250  40d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    251  40d8					      ELSE
    252  40d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    253  40da					      ENDIF
    254  40da		       60		      rts		; 6 = 32[-2]
    255  40db
    256  40db							;------------------------------------------------------------------------------
    257  40db
      0  40db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  40db		       00 08	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  40db					      SUBROUTINE
      3  40db				   GetBoardAddressR
    259  40db
    260  40db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    261  40de		       85 be		      sta	Board_AddressR	; 3
    262  40e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    263  40e3		       85 bf		      sta	Board_AddressR+1	; 3	 READ address
    264  40e5				  -	      IF	MULTI_BANK_BOARD = YES
    265  40e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    266  40e5					      ELSE
    267  40e5		       a9 0d		      lda	#BANK_BOARD	; 2
    268  40e7					      ENDIF
    269  40e7		       60		      rts		; 6[-2]
    270  40e8
    271  40e8							;------------------------------------------------------------------------------
    272  40e8
      0  40e8					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  40e8		       00 08	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  40e8					      SUBROUTINE
      3  40e8				   GetBoardAddressW
    274  40e8
    275  40e8							; Must share same bank as BoardLineStart tables
    276  40e8
    277  40e8		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    278  40eb		       85 c0		      sta	Board_AddressW	;3
    279  40ed		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    280  40f0		       85 c1		      sta	Board_AddressW+1	;3 WRITE address
    281  40f2				  -	      IF	MULTI_BANK_BOARD = YES
    282  40f2				  -	      ldx	BoardBank,y	;4 switch this on return
    283  40f2					      ELSE
    284  40f2		       a2 0d		      ldx	#BANK_BOARD	;2
    285  40f4					      ENDIF
    286  40f4		       60	   QRet       rts		;6
    287  40f5
    288  40f5							;-------------------------------------------------------------------------------
    289  40f5
    290  40f5
    291  40f5				   OBJTYPE    SET	0
    292  40f5					      MAC	define_character
    293  40f5				   CHARACTER_{1} =	OBJTYPE
    294  40f5				   OBJTYPE    .SET	OBJTYPE + 1
    295  40f5					      ENDM
    296  40f5
    297  40f5							; Modifications to character #/order must also ensure the following are correct...
    298  40f5							;   CharacterDataVecLO/HI	   in BANK_FIXED.asm
    299  40f5							;   MoveVecLO/HI		   in BANK_INITBANK
    300  40f5							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    301  40f5
      0  40f5					      DEFINE_CHARACTER	BLANK
      1  40f5		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	SOIL
      1  40f5		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	BOX
      1  40f5		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	TARGET
      1  40f5		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	TARGET2
      1  40f5		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	MANOCCUPIED
      1  40f5		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	STEEL
      1  40f5		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	WALL
      1  40f5		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  40f5		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	NOGO
      1  40f5		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
    312  40f5
      0  40f5					      DEFINE_CHARACTER	MAXIMUM
      1  40f5		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
    314  40f5
    315  40f5							;------------------------------------------------------------------------------
    316  40f5
      0  40f5					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  40f5		       00 08	   BANK_PushBox =	_CURRENT_BANK
      2  40f5					      SUBROUTINE
      3  40f5				   PushBox
    318  40f5
    319  40f5							; X = restoration character for square we are moving TO
    320  40f5							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    321  40f5
    322  40f5		       85 c2		      sta	ROM_Bank
    323  40f7
    324  40f7		       a5 a5		      lda	ManPushCounter
    325  40f9		       c9 01		      cmp	#PUSH_LIMIT
    326  40fb		       90 6c		      bcc	cannotPush
    327  40fd
    328  40fd		       86 da		      stx	restorationCharacter	; BOX'S NEW CHAR
    329  40ff
    330  40ff							; Determine if the box is pushable
    331  40ff							; we use the joystick to calculate the subsequent square
    332  40ff
    333  40ff		       a5 90		      lda	BufferedJoystick
    334  4101		       4a		      lsr
    335  4102		       4a		      lsr
    336  4103		       4a		      lsr
    337  4104		       4a		      lsr
    338  4105		       48		      pha
    339  4106		       a8		      tay
    340  4107
    341  4107		       18		      clc
    342  4108		       a5 8d		      lda	POS_Y_NEW
    343  410a		       79 c6 f2 	      adc	JoyMoveY,y
    344  410d		       a8		      tay
    345  410e		       20 c8 f0 	      jsr	GetBoardAddressRW
    346  4111
    347  4111		       68		      pla
    348  4112		       a8		      tay
    349  4113
    350  4113		       18		      clc
    351  4114		       a5 8c		      lda	POS_X_NEW
    352  4116		       79 ba f2 	      adc	JoyMoveX,y
    353  4119		       48		      pha
    354  411a		       a8		      tay
    355  411b
    356  411b				  -	      IF	MULTI_BANK_BOARD = YES
    357  411b				  -	      lda	RAM_Bank
    358  411b					      ELSE
    359  411b		       a9 0d		      lda	#BANK_BOARD	; 2
    360  411d					      ENDIF
    361  411d		       20 17 f8 	      jsr	GetBoardCharacter	;6+20(A)
    362  4120		       68		      pla
    363  4121		       a8		      tay
    364  4122
    365  4122		       a9 02		      lda	#CHARACTER_BOX
    366  4124		       e0 00		      cpx	#CHARACTER_BLANK
    367  4126		       f0 13		      beq	canPushTarget
    368  4128
    369  4128		       e0 03		      cpx	#CHARACTER_TARGET
    370  412a		       f0 04		      beq	decreaseTargets
    371  412c		       e0 04		      cpx	#CHARACTER_TARGET2
    372  412e		       d0 39		      bne	cannotPush
    373  4130
    374  4130							; Box is now on a target - so decrease the remaining targets
    375  4130
    376  4130		       f8	   decreaseTargets sed
    377  4131		       38		      sec
    378  4132		       a5 b8		      lda	targetsRequired
    379  4134		       e9 01		      sbc	#1
    380  4136		       85 b8		      sta	targetsRequired
    381  4138		       d8		      cld
    382  4139
    383  4139		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    384  413b		       48	   canPushTarget pha
    385  413c
    386  413c							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    387  413c							; then we increase targets (as there is one more to get)
    388  413c
    389  413c		       a5 da		      lda	restorationCharacter
    390  413e		       c9 03		      cmp	#CHARACTER_TARGET
    391  4140		       d0 09		      bne	notOnTargetAlready
    392  4142
    393  4142							; increase the required targets as box is leaving one
    394  4142
    395  4142		       f8		      sed
    396  4143		       18		      clc
    397  4144		       a5 b8		      lda	targetsRequired
    398  4146		       69 01		      adc	#1
    399  4148		       85 b8		      sta	targetsRequired
    400  414a		       d8		      cld
    401  414b
    402  414b				   notOnTargetAlready
    403  414b
    404  414b		       68		      pla
    405  414c
    406  414c
    407  414c				  -	      IF	MULTI_BANK_BOARD = YES
    408  414c				  -	      ldx	RAM_Bank
    409  414c					      ELSE
    410  414c		       a2 0d		      ldx	#BANK_BOARD	; 2
    411  414e					      ENDIF
    412  414e		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)
    413  4151
    414  4151		       a5 8f		      lda	POS_VAR	; player's restoration character
    415  4153		       48		      pha
    416  4154
    417  4154		       a6 8d		      ldx	POS_Y_NEW
    418  4156		       86 8b		      stx	POS_Y
    419  4158		       a4 8c		      ldy	POS_X_NEW
    420  415a		       84 8a		      sty	POS_X
    421  415c		       a5 da		      lda	restorationCharacter
    422  415e		       85 8f		      sta	POS_VAR
    423  4160
    424  4160		       20 65 f9 	      jsr	RestoreOriginalCharacter	; put back BOX's restoration character
    425  4163
    426  4163		       68		      pla
    427  4164		       85 8f		      sta	POS_VAR
    428  4166
    429  4166							;START_SOUND SOUND_BOX
    430  4166
    431  4166		       4c c4 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    432  4169
    433  4169		       e6 a5	   cannotPush inc	ManPushCounter
    434  416b		       60		      rts
    435  416c
    436  416c							;------------------------------------------------------------------------------
    437  416c
    438  416c							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    439  416c							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    440  416c
    441  416c							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    442  416c
    443  416c							; if the creature dies then jump NextObject
    444  416c
    445  416c
    446  416c
    447  416c		       ff	   RDirY      .byte.b	-1	;,0,1,0
    448  416d		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    449  416f		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    450  4173		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    451  4177		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    452  4185
    453  4185
    454  4185							;------------------------------------------------------------------------------
    455  4185
    456  4185							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    457  4185							; I don't particularly know why; probably because of the level variable-size array and the values
    458  4185							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    459  4185
    460  4185		       00 00	   MANMODE_STARTUP =	0
    461  4185		       00 01	   MANMODE_NORMAL =	1
    462  4185		       00 02	   MANMODE_DEAD =	2
    463  4185		       00 03	   MANMODE_WAITING =	3
    464  4185		       00 04	   MANMODE_WAITING2 =	4
    465  4185		       00 05	   MANMODE_WAITING_NT =	5
    466  4185		       00 06	   MANMODE_WAITING_NT2 =	6
    467  4185		       00 07	   MANMODE_NEXTLEVEL =	7
    468  4185		       00 08	   MANMODE_BONUS_START =	8
    469  4185		       00 09	   MANMODE_BONUS_RUN =	9
    470  4185
      0  4185					      DEFINE_SUBROUTINE	ManProcess	; in INITBANK
      1  4185		       00 08	   BANK_ManProcess =	_CURRENT_BANK
      2  4185					      SUBROUTINE
      3  4185				   ManProcess
    472  4185
    473  4185							;lda #$FF
    474  4185							;sta specialTimeFlag		  ; detects time overflow in bigbang (and TARGET grab)
    475  4185
    476  4185
    477  4185							; ManMode tells the player what it is currently doing.  State machine.
    478  4185
    479  4185					      if	1
    480  4185							; RESET to start next level
    481  4185
    482  4185		       ad 82 02 	      lda	SWCHB
    483  4188		       29 02		      and	#2
    484  418a		       d0 04		      bne	skipNextLevel
    485  418c		       a9 07		      lda	#MANMODE_NEXTLEVEL
    486  418e		       85 9f		      sta	ManMode
    487  4190				   skipNextLevel
    488  4190
    489  4190							; RESET to re-start current level
    490  4190
    491  4190		       ad 82 02 	      lda	SWCHB
    492  4193		       29 01		      and	#1
    493  4195		       d0 04		      bne	noReset
    494  4197		       a9 04		      lda	#MANMODE_WAITING2
    495  4199		       85 9f		      sta	ManMode
    496  419b				   noReset
    497  419b
    498  419b					      endif
    499  419b
    500  419b
    501  419b							; Check if all the boxes are on their target square
    502  419b
    503  419b		       a5 b8		      lda	targetsRequired
    504  419d		       d0 04		      bne	notComplete
    505  419f		       a9 07		      lda	#MANMODE_NEXTLEVEL
    506  41a1		       85 9f		      sta	ManMode
    507  41a3				   notComplete
    508  41a3
    509  41a3							;lda SWCHB
    510  41a3							;and #3
    511  41a3							;bne .skipReset	  ; BOTH select/reset = restart
    512  41a3
    513  41a3							;lsr SWCHB
    514  41a3							;bcs .skipReset
    515  41a3
    516  41a3
    517  41a3				   .skipReset
    518  41a3
    519  41a3							;sokldy ManMode
    520  41a3							;sok lda ManActionTimer,y
    521  41a3							;sok beq .skipTimer
    522  41a3		       20 cd f1 	      jsr	UpdateTimer
    523  41a6				   .skipTimer
    524  41a6		       a4 9f		      ldy	ManMode
    525  41a8		       b9 bd f1 	      lda	ManActionLO,y
    526  41ab		       85 d8		      sta	actionVector
    527  41ad		       b9 c5 f1 	      lda	ManActionHI,y
    528  41b0		       85 d9		      sta	actionVector+1
    529  41b2		       6c d8 00 	      jmp	(actionVector)
    530  41b5
    531  41b5				   ManActionTimer
    532  41b5		       00		      .byte.b	0	;<manStartup		 ; 0		 no timer
    533  41b6		       01		      .byte.b	1	;<normalMan		 ; 1		 timer
    534  41b7		       01		      .byte.b	1	;<deadMan		 ; 2		 timer
    535  41b8		       01		      .byte.b	1	;<waitingMan		 ; 3		 timer
    536  41b9		       01		      .byte.b	1	;<waitingManPress	 ; 4		 timer
    537  41ba		       00		      .byte.b	0	;<waitingManNoTim	 ; 5		 no timer
    538  41bb		       00		      .byte.b	0	;<waitingManPressNoTim  ; 6		 no timer
    539  41bc		       00		      .byte.b	0	;<nextLevelMan 	 ; 7		 no timer
    540  41bd				   ManActionLO
    541  41bd		       00		      .byte.b	<manStartup	; 0		 no timer
    542  41be		       2a		      .byte.b	<normalMan	; 1		 timer
    543  41bf		       2f		      .byte.b	<deadMan	; 2		 timer
    544  41c0		       23		      .byte.b	<waitingMan	; 3		 timer
    545  41c1		       23		      .byte.b	<waitingManPress	; 4		 timer
    546  41c2		       23		      .byte.b	<waitingMan	; 5		 no timer
    547  41c3		       23		      .byte.b	<waitingManPress	; 6		 no timer
    548  41c4		       be		      .byte.b	<nextLevelMan	; 7		 no timer
    549  41c5
    550  41c5				   ManActionHI
    551  41c5		       f2		      .byte.b	>manStartup	; no timer
    552  41c6		       f2		      .byte.b	>normalMan	; timer
    553  41c7		       f2		      .byte.b	>deadMan	; timer
    554  41c8		       f2		      .byte.b	>waitingMan	; timer
    555  41c9		       f2		      .byte.b	>waitingManPress	; timer
    556  41ca		       f2		      .byte.b	>waitingMan	; no timer
    557  41cb		       f2		      .byte.b	>waitingManPress	; no timer
    558  41cc		       fc		      .byte.b	>nextLevelMan	; no timer
    559  41cd
    560  41cd							;------------------------------------------------------------------------------
      0  41cd					      DEFINE_SUBROUTINE	UpdateTimer
      1  41cd		       00 08	   BANK_UpdateTimer =	_CURRENT_BANK
      2  41cd					      SUBROUTINE
      3  41cd				   UpdateTimer
    562  41cd
    563  41cd		       a9 09		      lda	#BANK_SCORING
    564  41cf		       20 08 f8 	      jsr	DrawTargetsRequiredFromROM
    565  41d2
    566  41d2
    567  41d2		       a2 03		      ldx	#3
    568  41d4		       a5 9f		      lda	ManMode
    569  41d6		       c9 09		      cmp	#MANMODE_BONUS_RUN
    570  41d8		       f0 0a		      beq	.setLoops
    571  41da
    572  41da		       a2 04		      ldx	#NUM_LEVELS-1	; intermissions run at full speed
    573  41dc		       24 b5		      bit	levelDisplay
    574  41de		       30 02		      bmi	.intermission2
    575  41e0		       a6 b4		      ldx	level
    576  41e2				   .intermission2
    577  41e2
    578  41e2		       a2 01		      ldx	#1
    579  41e4				   .setLoops
    580  41e4		       86 d9		      stx	timerLoops
    581  41e6		       d0 08		      bne	.notScoring
    582  41e8				   .loopTimer
    583  41e8		       a5 b4		      lda	level	; each second left adds 'level' to score
    584  41ea		       18		      clc
    585  41eb		       69 01		      adc	#1
    586  41ed		       20 b2 fc 	      jsr	ScoreAdd
    587  41f0				   .notScoring
    588  41f0							;		  sed
    589  41f0							;		  sec
    590  41f0							;		  lda moveCounter
    591  41f0							;		  sbc #1
    592  41f0							;		  sta moveCounter
    593  41f0							;		  cld
    594  41f0							;		  bcs .skipHi2a
    595  41f0							;		  dec moveCounterHi
    596  41f0							;.skipHi2a
    597  41f0							; check for running out of time sound:
    598  41f0							;		  lda moveCounterHi
    599  41f0							;		  bne .timeAbove9
    600  41f0							;		  lda #$09
    601  41f0							;		  sec
    602  41f0							;		  sbc moveCounter
    603  41f0							;		  bcc .timeAbove9
    604  41f0							; this assumes that SND_MASK_HI = %11110000
    605  41f0							;  and the time entries are ordered 9 to 0!
    606  41f0							;		  asl
    607  41f0							;		  asl
    608  41f0							;		  asl
    609  41f0							;		  asl
    610  41f0							;		  adc #SOUND_TIME_9
    611  41f0							;		  sta tmpSound
    612  41f0							;		  lda newSounds
    613  41f0							;		  and #<(~SND_MASK_HI)
    614  41f0							;		  ora tmpSound
    615  41f0							;		  sta newSounds
    616  41f0							;.skipTimeSound:
    617  41f0							;		  ldx moveCounter
    618  41f0							;		  bne .timeNotZero
    619  41f0							;		  stx AUDV0			  ; stop bonus sound
    620  41f0							;		  stx soundIdxLst
    621  41f0							;.contChannel1:
    622  41f0							;		  ldx #MANMODE_NEXTLEVEL	  ; time bonus
    623  41f0							;		  lda ManMode
    624  41f0							;		  cmp #MANMODE_BONUS_RUN
    625  41f0							;		  beq .nextLevel
    626  41f0							;		  ldx #MANMODE_WAITING_NT2	  ; time over
    627  41f0							;		  cmp #MANMODE_WAITING2 	  ; Man already dead?
    628  41f0							;		  beq .nextLevel
    629  41f0							;		  dex				  ; == MANMODE_WAITING_NT
    630  41f0							;.nextLevel
    631  41f0							;		  stx ManMode			  ; -> man dies
    632  41f0				   .timeNotZero
    633  41f0				   .forceTimeDraw
    634  41f0
    635  41f0
    636  41f0		       a9 09		      lda	#BANK_SCORING
    637  41f2		       4c 00 f8 	      jmp	DrawTimeFromROM	; Z-flag == 0!
    638  41f5
    639  41f5				   .timeAbove9
    640  41f5		       c6 d9		      dec	timerLoops
    641  41f7		       d0 ef		      bne	.loopTimer
    642  41f9		       f0 f5		      beq	.forceTimeDraw
    643  41fb
    644  41fb				   TimeFracTbl
    645  41fb		       1f		      .byte.b	31	; level 1, NTSC/PAL
    646  41fc		       1b		      .byte.b	27	; level 2, NTSC/PAL
    647  41fd		       18		      .byte.b	24	; level 3, NTSC/PAL
    648  41fe		       17		      .byte.b	23	; level 4, NTSC/PAL
    649  41ff		       16		      .byte.b	22	; level 5, NTSC/PAL
    650  4200							; calculate: level 5 throttle * level 5 time / level x throttle
    651  4200
    652  4200
    653  4200							;------------------------------------------------------------------------------
      0  4200					      DEFINE_SUBROUTINE	manStartup
      1  4200		       00 08	   BANK_manStartup =	_CURRENT_BANK
      2  4200					      SUBROUTINE
      3  4200				   manStartup
    655  4200
    656  4200				  -	      if	0
    657  4200				  -	      lda	POS_Type
    658  4200				  -	      pha
    659  4200				  -	      lda	#TYPE_CIRCLE
    660  4200				  -	      sta	POS_Type
    661  4200				  -	      jsr	InsertObjectStack
    662  4200				  -	      pla
    663  4200				  -	      sta	POS_Type
    664  4200					      endif
    665  4200
    666  4200		       a5 9b		      lda	ManX
    667  4202		       85 8c		      sta	POS_X_NEW	;NewX
    668  4204		       85 8a		      sta	POS_X
    669  4206		       a5 9c		      lda	ManY
    670  4208		       85 8d		      sta	POS_Y_NEW	;NewY
    671  420a		       85 8b		      sta	POS_Y
    672  420c
    673  420c		       e6 9a		      inc	manAnimationIndex
    674  420e		       a6 9a		      ldx	manAnimationIndex	; animation index
    675  4210		       bd 20 f2 	      lda	.ManStartup-1,x
    676  4213		       30 09		      bmi	CreateThePlayer
    677  4215		       85 8e		      sta	POS_Type
    678  4217
    679  4217		       a9 ff		      lda	#$FF
    680  4219		       85 a0		      sta	ManDelayCount	; anything, just non-0
    681  421b
    682  421b		       4c 3d f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    683  421e
    684  421e				   CreateThePlayer
    685  421e
    686  421e		       e6 9f		      inc	ManMode	; --> MANMODE_NORMAL
    687  4220				   RTS_CF
    688  4220		       60		      rts
    689  4221
    690  4221				   .ManStartup
    691  4221							;    .byte CHARACTER_NOGO
    692  4221							;    .byte CHARACTER_NOGO
    693  4221							;    .byte CHARACTER_STEEL
    694  4221							;    .byte CHARACTER_STEEL
    695  4221							;    .byte CHARACTER_NOGO
    696  4221							;    .byte CHARACTER_NOGO
    697  4221							;    .byte CHARACTER_STEEL
    698  4221							;    .byte CHARACTER_NOGO
    699  4221							;    .byte CHARACTER_STEEL
    700  4221							;    .byte CHARACTER_NOGO
    701  4221							;    .byte CHARACTER_STEEL
    702  4221							;    .byte CHARACTER_NOGO
    703  4221							;    .byte CHARACTER_STEEL
    704  4221							;    .byte CHARACTER_NOGO
    705  4221							;    .byte CHARACTER_STEEL
    706  4221							;    .byte CHARACTER_NOGO
    707  4221							;    .byte CHARACTER_STEEL
    708  4221							;.byte CHARACTER_NOGO
    709  4221		       05		      .byte.b	CHARACTER_MANOCCUPIED
    710  4222		       ff		      .byte.b	-1
    711  4223
    712  4223							;------------------------------------------------------------------------------
    713  4223
    714  4223				   waitingMan
    715  4223				   waitingManPress
    716  4223
    717  4223							;		  lda #50
    718  4223							;		  sta ColourTimer
    719  4223
    720  4223
    721  4223		       a5 c8		      lda	NextLevelTrigger
    722  4225		       09 40		      ora	#BIT_NEXTLIFE
    723  4227		       85 c8		      sta	NextLevelTrigger
    724  4229		       60		      rts
    725  422a
    726  422a				  -	      if	0
    727  422a				  -	      dec	ManDelayCount
    728  422a				  -
    729  422a				  -	      lda	#0
    730  422a				  -	      sta	LookingAround
    731  422a				  -	      sta	BGColour
    732  422a				  -
    733  422a				  -			; Wait for button to be RELEASED first!
    734  422a				  -
    735  422a				  -	      lda	BufferedButton
    736  422a				  -	      bpl	noChange
    737  422a				  -	      inc	ManMode
    738  422a				  -
    739  422a				  -			; Man loses a life and re-starts level if lives available
    740  422a				  -			; Special-case: Bonus levels go to next level.
    741  422a				  -
    742  422a				  -	      IF	NUM_LIVES != -1
    743  422a				  -	      dec	ManCount	; works for P1P2 format
    744  422a				  -			; display lives after a live is lost
    745  422a				  -	      lda	scoringFlags	;
    746  422a				  -	      and	#~DISPLAY_FLAGS
    747  422a				  -	      ora	#DISPLAY_LIVES
    748  422a				  -	      sta	scoringFlags	;
    749  422a				  -	      ENDIF
    750  422a				  -	      jsr	goGeneralScoringSetups	; update the life display. Roundabout way of doing it.
    751  422a				  -
    752  422a				  -
    753  422a				  -	      lda	#120	; something long.  anything.
    754  422a				  -	      sta	scoringTimer	; first time through we wait on the current display
    755  422a				  -
    756  422a				  -			;waitingManPress
    757  422a				  -
    758  422a				  -			; Cycle the score display, player display, level display based on timing
    759  422a				  -			; see "Scoring timer" reset stomp comment in bank_generic.
    760  422a				  -
    761  422a				  -	      lda	scoringTimer
    762  422a				  -	      cmp	#10	; non-zero so we don't get stomped on by the scoring reset in
    763  422a				  -	      bcs	stillKicking
    764  422a				  -	      lda	#90	; something long.  anything.
    765  422a				  -	      sta	scoringTimer
    766  422a				  -
    767  422a				  -	      lda	ManCount
    768  422a				  -	      and	#$0f
    769  422a				  -	      cmp	#$01
    770  422a				  -	      ldx	scoringFlags
    771  422a				  -	      inx
    772  422a				  -	      txa
    773  422a				  -			; if game over for current player, display alternate scoreboard
    774  422a				  -	      and	#$f3
    775  422a				  -	      bcc	gameOver
    776  422a				  -			; else display targets/time and move count
    777  422a				  -	      and	#$f1
    778  422a				  -gameOver   sta	scoringFlags	;
    779  422a				  -
    780  422a				  -	      jsr	goGeneralScoringSetups	; update the score display.
    781  422a				  -
    782  422a				  -stillKicking
    783  422a				  -
    784  422a				  -	      lda	BufferedButton	; button pressed?
    785  422a				  -	      bmi	noChange
    786  422a				  -
    787  422a				  -	      lda	NextLevelTrigger
    788  422a				  -	      ora	#BIT_NEXTLIFE
    789  422a				  -	      sta	NextLevelTrigger
    790  422a				  -
    791  422a				  -noChange   rts
    792  422a					      endif
    793  422a
    794  422a							;------------------------------------------------------------------------------
    795  422a							; Normal man state
    796  422a
    797  422a
    798  422a				   normalMan
    799  422a
    800  422a							; Timer is still running, so we see if the player is to die for any reason
    801  422a
    802  422a							;		  bit demoMode
    803  422a							;		  bmi stayAlive
    804  422a							; SELECT pressed?
    805  422a							;		  lda SWCHB
    806  422a							;		  eor #$FF
    807  422a							;		  and #3
    808  422a							;		  bne Time0			  ; EITHER select or reset are pressed
    809  422a							;		  lsr
    810  422a							;		  lsr
    811  422a							;		  bcc Time0			  ; suicide!
    812  422a				   stayAlive
    813  422a
    814  422a							;------------------------------------------------------------------------------
    815  422a
    816  422a							;ldx ManY
    817  422a							;ldy ManX
    818  422a
    819  422a							;lda BoardLineStartLO,x
    820  422a							;sta Board_AddressR
    821  422a							;lda BoardLineStartHiR,x
    822  422a							;sta Board_AddressR+1
    823  422a
    824  422a				  -	      IF	MULTI_BANK_BOARD = YES
    825  422a				  -			;lda BoardBank,x		  ;4
    826  422a				  -			;sta RAM_Bank			  ;3
    827  422a					      ELSE
    828  422a							;lda #BANK_BOARD		  ;2
    829  422a					      ENDIF
    830  422a							;jsr GetBoardCharacter 	  ;6+20(A)
    831  422a
    832  422a							;lda CharToType,x
    833  422a							;cmp #TYPE_MAN
    834  422a							;beq PlayerAlive
    835  422a		       4c 5e f2 	      jmp	PlayerAlive	;sok
    836  422d
    837  422d							; character he's on isn't a MAN character, so he dies...
    838  422d
    839  422d				   Time0
    840  422d
    841  422d		       e6 9f		      inc	ManMode	; #1 -- player dead!
    842  422f
    843  422f
    844  422f		       a5 9b	   deadMan    lda	ManX
    845  4231		       85 8a		      sta	POS_X
    846  4233		       a5 9c		      lda	ManY
    847  4235		       85 8b		      sta	POS_Y
    848  4237
    849  4237							;jsr BlankPlayerFrame
    850  4237
    851  4237							; and becomes a man waiting for resurrection...
    852  4237
    853  4237		       e6 9f		      inc	ManMode
    854  4239
    855  4239				   timeTooShortToDie
    856  4239		       60		      rts
    857  423a
    858  423a							;------------------------------------------------------------------------------
    859  423a
    860  423a							;lookColour	  .byte $b0,$02
    861  423a
      0  423a					      DEFINE_SUBROUTINE	LookAround	; in INITBANK
      1  423a		       00 08	   BANK_LookAround =	_CURRENT_BANK
      2  423a					      SUBROUTINE
      3  423a				   LookAround
    863  423a
    864  423a		       a9 ff		      lda	#$FF
    865  423c		       85 92		      sta	BufferedButton
    866  423e
    867  423e							;ldx Platform
    868  423e							;lda lookColour,x
    869  423e							;sta BGColour
    870  423e
    871  423e							; Use the joystick as a window-scroller to change the viewport
    872  423e
    873  423e		       a5 90		      lda	BufferedJoystick
    874  4240		       4a		      lsr
    875  4241		       4a		      lsr
    876  4242		       4a		      lsr
    877  4243		       4a		      lsr
    878  4244		       a8		      tay
    879  4245
    880  4245		       b9 ba f2 	      lda	JoyMoveX,y
    881  4248							;asl
    882  4248		       18		      clc
    883  4249		       65 97		      adc	BoardScrollX
    884  424b		       c5 94		      cmp	BoardEdge_Right
    885  424d		       b0 02		      bcs	AbandonX
    886  424f		       85 97		      sta	BoardScrollX
    887  4251
    888  4251		       b9 c6 f2    AbandonX   lda	JoyMoveY,y
    889  4254							;asl
    890  4254		       18		      clc
    891  4255		       65 96		      adc	BoardScrollY
    892  4257		       c5 95		      cmp	BoardEdge_Bottom
    893  4259		       b0 02		      bcs	AbandonY
    894  425b		       85 96		      sta	BoardScrollY
    895  425d
    896  425d		       60	   AbandonY   rts
    897  425e
    898  425e
    899  425e
    900  425e
    901  425e				   PlayerAlive
    902  425e
    903  425e							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    904  425e							; before exiting via (for example) look-around option :)
    905  425e
    906  425e		       a5 9b		      lda	ManX
    907  4260		       85 8c		      sta	POS_X_NEW
    908  4262		       a5 9c		      lda	ManY
    909  4264		       85 8d		      sta	POS_Y_NEW
    910  4266
    911  4266
    912  4266							;------------------------------------------------------------------------------
    913  4266							; Look around is triggered by holding down the fire button for a while, without any other
    914  4266							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    915  4266							; is active. Otherwise, it is counting down to the time where it will trigger.
    916  4266
    917  4266		       00 00	   LOOK_DELAY =	0
    918  4266
    919  4266		       a2 00		      ldx	#LOOK_DELAY
    920  4268		       a5 92		      lda	BufferedButton
    921  426a		       30 0d		      bmi	noLook	; button?
    922  426c		       a5 a6		      lda	LookingAround
    923  426e		       30 ca		      bmi	LookAround	; already looking
    924  4270		       a5 90		      lda	BufferedJoystick
    925  4272		       c9 f0		      cmp	#$F0
    926  4274		       90 03		      bcc	noLook	; must have no directions chosen
    927  4276		       a6 a6		      ldx	LookingAround
    928  4278		       ca		      dex
    929  4279		       86 a6	   noLook     stx	LookingAround
    930  427b
    931  427b
    932  427b							;------------------------------------------------------------------------------
    933  427b
    934  427b							; control the scrolling via the joystick
    935  427b
    936  427b		       a5 a4		      lda	ManLastDirection
    937  427d		       29 07		      and	#DIRECTION_BITS
    938  427f		       a8		      tay
    939  4280
    940  4280		       a5 90		      lda	BufferedJoystick	; joystick
    941  4282		       25 91		      and	BufferedJoystick+1
    942  4284
    943  4284		       a2 00		      ldx	#0
    944  4286		       0a	   .loopDirs  asl
    945  4287		       90 07		      bcc	.dirFound
    946  4289		       88		      dey
    947  428a		       e8		      inx
    948  428b		       e0 04		      cpx	#4
    949  428d		       d0 f7		      bne	.loopDirs
    950  428f		       18		      clc
    951  4290				   .dirFound
    952  4290		       a5 8c		      lda	POS_X_NEW	;NewX
    953  4292		       7d d3 f2 	      adc	JoyDirX,x
    954  4295		       85 8c		      sta	POS_X_NEW	;NewX
    955  4297		       a5 8d		      lda	POS_Y_NEW	;NewY
    956  4299		       18		      clc
    957  429a		       7d d1 f2 	      adc	JoyDirY,x
    958  429d		       85 8d		      sta	POS_Y_NEW	;NewY
    959  429f
    960  429f		       98		      tya
    961  42a0		       f0 12		      beq	noMovement	; animation OK
    962  42a2
    963  42a2		       8a		      txa
    964  42a3		       45 a4		      eor	ManLastDirection
    965  42a5		       29 07		      and	#DIRECTION_BITS
    966  42a7		       45 a4		      eor	ManLastDirection
    967  42a9		       85 a4		      sta	ManLastDirection
    968  42ab		       bd b5 f2 	      lda	ManAnimTblLo,x
    969  42ae		       85 a1		      sta	ManAnimation
    970  42b0							;lda ManAnimTblHi,x
    971  42b0							;sta ManAnimation+1
    972  42b0		       a9 00		      lda	#0
    973  42b2		       85 a0		      sta	ManDelayCount
    974  42b4				   phase0		;jsr MovePlayer
    975  42b4				   noMovement		;ldx MAN_Player
    976  42b4
    977  42b4		       60	   DFS_rts    rts
    978  42b5
    979  42b5
    980  42b5				   ManAnimTblLo
    981  42b5		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    982  42ba							;ManAnimTblHi
    983  42ba							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    984  42ba
    985  42ba
    986  42ba
    987  42ba		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    988  42c6		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    989  42d1
    990  42d1				   JoyDirY
    991  42d1		       00 00		      .byte.b	0,0	;,1,-1,0
    992  42d3				   JoyDirX
    993  42d3		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    994  42d8
    995  42d8
    996  42d8							;------------------------------------------------------------------------------
    997  42d8
    998  42d8
      0  42d8					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  42d8		       00 08	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  42d8					      SUBROUTINE
      3  42d8				   DrawFullScreen
   1000  42d8
   1001  42d8							; 83[-7] + 2484[-89] = 2567[-96]
   1002  42d8
   1003  42d8
   1004  42d8		       ad 84 02 	      lda	INTIM	; 4
   1005  42db		       c9 29		      cmp	#SEGTIME_BDF	; 2
   1006  42dd		       90 d5		      bcc	DFS_rts	; 2/3
      0  42df					      STRESS_TIME	SEGTIME_BDF
      1  42df				  -	      IF	TEST_SEGTIME_BDF = 1
      2  42df				  -
      3  42df				  -
      4  42df				  -
      5  42df				  -
      6  42df				  -
      7  42df				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  42df				  -	      bne	. - 7
      9  42df					      ENDIF
   1008  42df
   1009  42df		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
   1010  42e1		       85 d9		      sta	BDF_DrawFlagAddress+1	; 3
   1011  42e3		       85 db		      sta	BDF_DrawFlagAddress2+1	; 3
   1012  42e5
   1013  42e5		       ba		      tsx		; 2
   1014  42e6		       86 e2		      stx	DHS_Stack	; 3
   1015  42e8
   1016  42e8		       e6 89		      inc	ScreenDrawPhase	; 5
   1017  42ea
   1018  42ea		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
   1019  42eb		       a2 08		      ldx	#SCREEN_LINES	; 2
   1020  42ed		       8a		      txa		; 2 = 31
   1021  42ee
   1022  42ee							; fall through
   1023  42ee
   1024  42ee							;------------------------------------------------------------------------------
   1025  42ee
      0  42ee					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = 52[-7]
      1  42ee		       00 08	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  42ee					      SUBROUTINE
      3  42ee				   DrawScreenRowPreparation
   1027  42ee
   1028  42ee							;clc
   1029  42ee		       ca		      dex		; 2
   1030  42ef		       86 e1		      stx	DHS_Line	; 3
   1031  42f1		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
   1032  42f3		       a8		      tay		; 2 = 10
   1033  42f4
   1034  42f4							;clc
   1035  42f4		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
   1036  42f7		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
   1037  42f9		       85 dc		      sta	BDF_BoardAddress	; 3
   1038  42fb		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1039  42fd		       85 de		      sta	BDF_BoardAddress2	; 3
   1040  42ff
   1041  42ff		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
   1042  4302		       85 dd		      sta	BDF_BoardAddress+1	; 3
   1043  4304		       85 df		      sta	BDF_BoardAddress2+1	; 3 = 25
   1044  4306
   1045  4306		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
   1046  4309		       85 d8		      sta	BDF_DrawFlagAddress	; 3
   1047  430b		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1048  430d		       85 da		      sta	BDF_DrawFlagAddress2	; 3 = 12
   1049  430f
   1050  430f				  -	      IF	MULTI_BANK_BOARD = YES
   1051  430f				  -	      lda	BoardBank-1,y	; 4
   1052  430f				  -	      sta	BDF_BoardBank	; 3
   1053  430f					      ENDIF
   1054  430f		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
   1055  4311		       4c 8b fa 	      jmp	CopyRow2	; 3 = 12[-7]
   1056  4314
   1057  4314							;------------------------------------------------------------------------------
   1058  4314
      0  4314					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  4314		       00 08	   BANK_VectorProcess =	_CURRENT_BANK
      2  4314					      SUBROUTINE
      3  4314				   VectorProcess
   1060  4314
   1061  4314							;sta ROM_Bank			  ;3		  processors can assume bank is stored
   1062  4314
   1063  4314		       bd 24 f3 	      lda	OSPointerHI,x	;4
   1064  4317		       85 d9		      sta	POS_Vector+1	;3
   1065  4319		       bd 21 f3 	      lda	OSPointerLO,x	;4
   1066  431c		       85 d8		      sta	POS_Vector	;3
   1067  431e
   1068  431e		       6c d8 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
   1069  4321							;		 NOTE: Bank is either INITBANK or FIXED.
   1070  4321
   1071  4321
   1072  4321				   OBJTYPE    SET	0
   1073  4321					      MAC	define
   1074  4321				   TYPE_{1}   =	OBJTYPE
   1075  4321				   OBJTYPE    .SET	OBJTYPE + 1
   1076  4321					      ENDM
   1077  4321
   1078  4321							; If adding/removing types, the following must also be updated...
   1079  4321							;   InitialFace[...]		     in UnpackLevel.asm
   1080  4321							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
   1081  4321							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
   1082  4321							;   OSPointerLO[...]		     in BANK_INITBANK.asm
   1083  4321							;   OSPointerHI[...]		     in BANK_INITBANK.asm
   1084  4321							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1085  4321							;   Sortable[...]		     in BANK_FIXED.asm
   1086  4321
   1087  4321
      0  4321					      DEFINE	MAN
      1  4321		       00 00	   TYPE_MAN   =	OBJTYPE
      2  4321				   OBJTYPE    .SET	OBJTYPE + 1
      0  4321					      DEFINE	CIRCLE
      1  4321		       00 01	   TYPE_CIRCLE =	OBJTYPE
      2  4321				   OBJTYPE    .SET	OBJTYPE + 1
      0  4321					      DEFINE	CIRCLE_HELPER
      1  4321		       00 02	   TYPE_CIRCLE_HELPER =	OBJTYPE
      2  4321				   OBJTYPE    .SET	OBJTYPE + 1
      0  4321					      DEFINE	CIRCLE_DRAWER
      1  4321		       00 03	   TYPE_CIRCLE_DRAWER =	OBJTYPE
      2  4321				   OBJTYPE    .SET	OBJTYPE + 1
   1092  4321
      0  4321					      DEFINE	MAXIMUM
      1  4321		       00 04	   TYPE_MAXIMUM =	OBJTYPE
      2  4321				   OBJTYPE    .SET	OBJTYPE + 1
   1094  4321
   1095  4321
      0  4321					      DEFINE_SUBROUTINE	OSPointerLO
      1  4321		       00 08	   BANK_OSPointerLO =	_CURRENT_BANK
      2  4321					      SUBROUTINE
      3  4321				   OSPointerLO
   1097  4321		       41		      .byte.b	<PROCESS_MAN
   1098  4322		       db		      .byte.b	<PROCESS_CIRCLE
   1099  4323		       d1		      .byte.b	<PROCESS_CIRCLE_HELPER
   1100  4324
   1101  4324				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
   1102  4324				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
   1103  4324				  -	      ERR
   1104  4324					      ENDIF
   1105  4324
   1106  4324
      0  4324					      DEFINE_SUBROUTINE	OSPointerHI
      1  4324		       00 08	   BANK_OSPointerHI =	_CURRENT_BANK
      2  4324					      SUBROUTINE
      3  4324				   OSPointerHI
   1108  4324		       f9		      .byte.b	>PROCESS_MAN
   1109  4325		       f8		      .byte.b	>PROCESS_CIRCLE
   1110  4326		       f8		      .byte.b	>PROCESS_CIRCLE_HELPER
   1111  4327
   1112  4327				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
   1113  4327				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
   1114  4327				  -	      ERR
   1115  4327					      ENDIF
   1116  4327
   1117  4327							;------------------------------------------------------------------------------
   1118  4327
      0  4327					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  4327		       00 08	   BANK_MoveVecLO =	_CURRENT_BANK
      2  4327					      SUBROUTINE
      3  4327				   MoveVecLO
   1120  4327
   1121  4327		       f0		      .byte.b	<MOVE_BLANK
   1122  4328		       f0		      .byte.b	<MOVE_SOIL
   1123  4329		       23		      .byte.b	<MOVE_BOX
   1124  432a		       f0		      .byte.b	<MOVE_TARGET
   1125  432b		       f0		      .byte.b	<MOVE_TARGET
   1126  432c		       1e		      .byte.b	<MOVE_GENERIC	;man occupied
   1127  432d		       1e		      .byte.b	<MOVE_GENERIC	;steel
   1128  432e		       1e		      .byte.b	<MOVE_GENERIC	;wall
   1129  432f		       2e		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1130  4330		       1e		      .byte.b	<MOVE_GENERIC	;nogo
   1131  4331
   1132  4331				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1133  4331				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1134  4331				  -	      ERR
   1135  4331					      ENDIF
   1136  4331
   1137  4331
   1138  4331
      0  4331					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  4331		       00 08	   BANK_MoveVecHI =	_CURRENT_BANK
      2  4331					      SUBROUTINE
      3  4331				   MoveVecHI
   1140  4331
   1141  4331		       f9		      .byte.b	>MOVE_BLANK
   1142  4332		       f9		      .byte.b	>MOVE_SOIL
   1143  4333		       fa		      .byte.b	>MOVE_BOX
   1144  4334		       f9		      .byte.b	>MOVE_TARGET
   1145  4335		       f9		      .byte.b	>MOVE_TARGET
   1146  4336		       fa		      .byte.b	>MOVE_GENERIC	;man occupied
   1147  4337		       fa		      .byte.b	>MOVE_GENERIC	;steel
   1148  4338		       fa		      .byte.b	>MOVE_GENERIC	;wall
   1149  4339		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1150  433a		       fa		      .byte.b	>MOVE_GENERIC	;nogo
   1151  433b
   1152  433b				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1153  433b				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1154  433b				  -	      EXIT
   1155  433b					      ENDIF
   1156  433b
   1157  433b
      0  433b					      CHECK_BANK_SIZE	"INITBANK"
      1  433b		       03 3b	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $33b , FREE= $4c5
      2  433b					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  433b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  433b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  433b				  -	      ERR
      6  433b					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  433b					      include	"BANK_FIXED.asm"
      1  433b							;    Sokoboo - a Sokoban implementation
      2  433b							;    using a generic tile-based display engine for the Atari 2600
      3  433b							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  433b							;
      5  433b							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  433b							;
      7  433b							;    Code related to the generic tile-based display engine was developed by
      8  433b							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  433b							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  433b							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  433b							;
     12  433b							;    Code related to music and sound effects uses the TIATracker music player
     13  433b							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  433b							;    directory for Apache licensing details.
     15  433b							;
     16  433b							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  433b							;    See the copyright notices in the License directory for a list of level
     18  433b							;    contributors.
     19  433b							;
     20  433b							;    Except where otherwise indicated, this software is released under the
     21  433b							;    following licensing arrangement...
     22  433b							;
     23  433b							;    This program is free software: you can redistribute it and/or modify
     24  433b							;    it under the terms of the GNU General Public License as published by
     25  433b							;    the Free Software Foundation, either version 3 of the License, or
     26  433b							;    (at your option) any later version.
     27  433b							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  433b
     29  433b							;    This program is distributed in the hope that it will be useful,
     30  433b							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  433b							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  433b							;    GNU General Public License for more details.
     33  433b
     34  433b							;------------------------------------------------------------------------------
     35  433b							;###############################  FIXED BANK  #################################
     36  433b							;------------------------------------------------------------------------------
     37  433b
     38  433b
     39  433b				   ORIGIN     SET	FIXED_BANK
     40  433b
      0  433b					      NEWBANK	THE_FIXED_BANK
      1  7f75 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       85 3e		      sta	SET_BANK_RAM
     51  7802		       20 f5 f2 	      jsr	DrawTime
     52  7805		       85 3f		      sta	SET_BANK
     53  7807		       60		      rts
     54  7808
      0  7808					      DEFINE_SUBROUTINE	DrawTargetsRequiredFromROM
      1  7808		       00 0f	   BANK_DrawTargetsRequiredFromROM =	_CURRENT_BANK
      2  7808					      SUBROUTINE
      3  7808				   DrawTargetsRequiredFromROM
     56  7808
     57  7808		       85 3e		      sta	SET_BANK_RAM
     58  780a		       20 e0 f2 	      jsr	DrawTargetsRequired
     59  780d		       a5 c2		      lda	ROM_Bank
     60  780f		       85 3f		      sta	SET_BANK
     61  7811		       60		      rts
     62  7812
     63  7812							;------------------------------------------------------------------------------
     64  7812
      0  7812					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  7812		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  7812					      SUBROUTINE
      3  7812				   GetROMByte
     66  7812
     67  7812							; a = ROM bank to retrieve
     68  7812							; y = page index
     69  7812							; ROM_Bank = bank to return to
     70  7812							; (Board_AddressR) = page
     71  7812							; out a = byte from (Board_AddressR)
     72  7812
     73  7812		       85 3f		      sta	SET_BANK	;3
     74  7814		       4c 19 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     75  7817
     76  7817							;------------------------------------------------------------------------------
     77  7817
      0  7817					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7817		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7817					      SUBROUTINE
      3  7817				   GetBoardCharacter
     79  7817
     80  7817							; call from ROM bank
     81  7817							; switches back to ROM_Bank on exit
     82  7817
     83  7817							; pass A = bank containing character
     84  7817							; Y = x character position
     85  7817							; (Board_AddressR) points to character position
     86  7817							; returns character from board
     87  7817
     88  7817
     89  7817		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     90  7819
     91  7819				   GetBoardCharacter2		;=17(A)
     92  7819
     93  7819		       b3 be		      lax	(Board_AddressR),y	;5
     94  781b		       a4 c2		      ldy	ROM_Bank	;3
     95  781d		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     96  781f		       60		      rts		;6   and go back
     97  7820
     98  7820							;---------------------------------------------------------------------------
     99  7820
      0  7820					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  7820		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  7820					      SUBROUTINE
      3  7820				   PutBoardCharacter
    101  7820
    102  7820		       86 3e		      stx	SET_BANK_RAM	; 3
    103  7822
    104  7822				   PutBoardCharacterSB		; =18
    105  7822		       91 c0		      sta	(Board_AddressW),y	; 6
    106  7824		       a5 c2		      lda	ROM_Bank	; 3
    107  7826		       85 3f		      sta	SET_BANK	; 3
    108  7828		       60		      rts		; 6 = 21
    109  7829
    110  7829							;---------------------------------------------------------------------------
    111  7829
      0  7829					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7829		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7829					      SUBROUTINE
      3  7829				   GetBoardCharacter__CALL_FROM_RAM__
    113  7829
    114  7829		       a4 8b		      ldy	POS_Y	;3
    115  782b
    116  782b		       a9 08		      lda	#BANK_GetBoardAddressR	;
    117  782d		       85 3f		      sta	SET_BANK	;
    118  782f		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    119  7832
    120  7832
      0  7832					      DEFINE_SUBROUTINE	PartialGetBoardCharacter	;=23
      1  7832		       00 0f	   BANK_PartialGetBoardCharacter =	_CURRENT_BANK
      2  7832					      SUBROUTINE
      3  7832				   PartialGetBoardCharacter
    122  7832
    123  7832
    124  7832		       85 3e		      sta	SET_BANK_RAM	;3
    125  7834		       a4 8a		      ldy	POS_X	;3
    126  7836		       b3 be		      lax	(Board_AddressR),y	;5
    127  7838		       a4 c3		      ldy	RAM_Bank	;3
    128  783a		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    129  783c		       60		      rts		;6		 and go back
    130  783d
    131  783d							;---------------------------------------------------------------------------
    132  783d
      0  783d					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783d		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783d					      SUBROUTINE
      3  783d				   PutBoardCharacterFromRAM
    134  783d
    135  783d							; POS_Y  = row
    136  783d							; POS_Type = character to write
    137  783d							; POS_X     = column
    138  783d							; RAM_Bank = caller's bank
    139  783d
    140  783d		       a4 8b		      ldy	POS_Y	;3
    141  783f
    142  783f		       a9 08		      lda	#BANK_GetBoardAddressW	;
    143  7841		       85 3f		      sta	SET_BANK	;
    144  7843		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    145  7846
    146  7846		       86 3e		      stx	SET_BANK_RAM	;3
    147  7848
    148  7848		       a4 8a		      ldy	POS_X	;3
    149  784a		       a5 8e		      lda	POS_Type	;3
    150  784c		       91 c0		      sta	(Board_AddressW),y	;6
    151  784e		       a4 c3		      ldy	RAM_Bank	;3
    152  7850		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    153  7852		       60		      rts		;6
    154  7853
    155  7853
    156  7853							;---------------------------------------------------------------------------
    157  7853
      0  7853					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  7853		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7853					      SUBROUTINE
      3  7853				   ProcessObjStack
    159  7853
    160  7853		       ad 84 02 	      lda	INTIM	;4
    161  7856		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    162  7858		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  785a					      STRESS_TIME	MINIMUM_SEGTIME
      1  785a				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  785a				  -
      3  785a				  -
      4  785a				  -
      5  785a				  -
      6  785a				  -
      7  785a				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  785a				  -	      bne	. - 7
      9  785a					      ENDIF
    164  785a
    165  785a		       a5 85		      lda	ObjStackNum	;3
    166  785c		       49 01		      eor	#1	;2
    167  785e		       aa		      tax		;2
    168  785f
    169  785f		       a5 cb		      lda	ObjIterator	;3
    170  7861		       d5 86		      cmp	ObjStackPtr,x	;5
    171  7863		       b0 2e		      bcs	nextPhase	;2/3
    172  7865
    173  7865
    174  7865							; Process an object...
    175  7865							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    176  7865
    177  7865		       bc c2 f9 	      ldy	BankObjStack,x	;4
    178  7868		       84 3e		      sty	SET_BANK_RAM	;3
    179  786a
    180  786a		       aa		      tax		;2
    181  786b		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    182  786e
    183  786e		       b9 00 10 	      lda	ObjStackX,y	;4
    184  7871		       85 8a		      sta	POS_X	;3
    185  7873		       b9 80 10 	      lda	ObjStackY,y	;4
    186  7876		       85 8b		      sta	POS_Y	;3
    187  7878		       b9 00 11 	      lda	ObjStackVar,y	;4
    188  787b		       85 8f		      sta	POS_VAR	;3
    189  787d		       be 00 12 	      ldx	ObjStackType,y	;4
    190  7880		       86 8e		      stx	POS_Type	;3
    191  7882
    192  7882		       a9 08		      lda	#BANK_VectorProcess	;2
    193  7884		       85 3f		      sta	SET_BANK	;3
    194  7886
    195  7886		       bd 24 f3 	      lda	OSPointerHI,x	;4
    196  7889		       85 d9		      sta	POS_Vector+1	;3
    197  788b		       bd 21 f3 	      lda	OSPointerLO,x	;4
    198  788e		       85 d8		      sta	POS_Vector	;3
    199  7890
    200  7890		       6c d8 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    201  7893
    202  7893
    203  7893							;---------------------------------------------------------------------------
    204  7893							; Now process the blank stack.  This stack holds all the recently blanked squares
    205  7893							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    206  7893							; by these objects are added again to the blank stack.
    207  7893
    208  7893				   nextPhase
    209  7893
    210  7893							;clc
    211  7893							;lda circle_d
    212  7893							;adc #255
    213  7893							;sta circle_d
    214  7893							;bcc nocirc
    215  7893
    216  7893
    217  7893
    218  7893				   nocirc
    219  7893
    220  7893		       e6 89		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    221  7895		       60	   EarlyAbort rts		;6
    222  7896
    223  7896							;---------------------------------------------------------------------------
    224  7896
      0  7896					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  7896		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7896					      SUBROUTINE
      3  7896				   SwitchObjects
    226  7896
    227  7896							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    228  7896							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    229  7896							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    230  7896
    231  7896		       ad 84 02 	      lda	INTIM	; 4
    232  7899		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    233  789b		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  789d					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  789d				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  789d				  -
      3  789d				  -
      4  789d				  -
      5  789d				  -
      6  789d				  -
      7  789d				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  789d				  -	      bne	. - 7
      9  789d					      ENDIF
    235  789d
    236  789d							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    237  789d							; we're at the throttle cutoff do we switch game-frames.
    238  789d
    239  789d							;sec
    240  789d		       a5 b6		      lda	Throttle	;3
    241  789f		       e9 a0		      sbc	#MAX_THROTTLE	;2
    242  78a1		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    243  78a3
    244  78a3							; Time is up. But we may be in a level which requires perfect sorting
    245  78a3							; So we check for these levels, and wait for the sort to complete for those.
    246  78a3
    247  78a3		       24 b5		      bit	levelDisplay	;3
    248  78a5		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    249  78a7
    250  78a7							; We have a level which requires the sort to go to completion
    251  78a7							; Check to see if the sort is finished...
    252  78a7
    253  78a7		       a4 ca		      ldy	sortPtr	;3
    254  78a9		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    255  78ab		       a4 c9		      ldy	sortRequired	;3
    256  78ad		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    257  78af
    258  78af		       85 b6	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    259  78b1
    260  78b1							; Pause the game with B/W switch:
    261  78b1
    262  78b1		       a5 80		      lda	gameMode
    263  78b3		       30 14		      bmi	.paused	; pause flag set
    264  78b5
    265  78b5							; Now that we have completed processing the object stack, we switch
    266  78b5							; the stack bank pointers for the next time around.
    267  78b5
    268  78b5		       a5 85		      lda	ObjStackNum	;3
    269  78b7		       49 01		      eor	#1	;2
    270  78b9		       aa		      tax		;2
    271  78ba		       86 85		      stx	ObjStackNum	;3		 swap stacks @here
    272  78bc
    273  78bc							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    274  78bc							; this code is finished, so we don't want it to do something unexpected!
    275  78bc
    276  78bc		       a0 ff		      ldy	#<(-1)	;2
    277  78be		       84 c9		      sty	sortRequired	;3
    278  78c0		       c8		      iny		;2		 Y==0
    279  78c1		       84 ca		      sty	sortPtr	;3
    280  78c3
    281  78c3							; Initialise the iterator and stack pointer for next time around.
    282  78c3							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    283  78c3							; necessary to initialise both.
    284  78c3
    285  78c3		       84 cb		      sty	ObjIterator	;3		 Y==0
    286  78c5		       94 86		      sty	ObjStackPtr,x	;4
    287  78c7
    288  78c7		       84 89		      sty	ScreenDrawPhase	;3
    289  78c9				   .paused
    290  78c9		       60	   quickExit  rts		;6
    291  78ca
    292  78ca							;---------------------------------------------------------------------------
    293  78ca
      0  78ca					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
      1  78ca		       00 0f	   BANK_PROCESS_CIRCLE_DRAWER =	_CURRENT_BANK
      2  78ca					      SUBROUTINE
      3  78ca				   PROCESS_CIRCLE_DRAWER
    295  78ca
    296  78ca		       a0 00		      ldy	#CHARACTER_BLANK
    297  78cc		       a5 aa		      lda	circle_d+1
    298  78ce							;jsr DrawCircle
    299  78ce							;bcc finCircle
    300  78ce							;lda #TYPE_CIRCLE_DRAWER
    301  78ce							;sta POS_Type
    302  78ce							;jsr InsertObjectStack
    303  78ce		       4c 87 f9    finCircle  jmp	NextObject
    304  78d1
      0  78d1					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
      1  78d1		       00 0f	   BANK_PROCESS_CIRCLE_HELPER =	_CURRENT_BANK
      2  78d1					      SUBROUTINE
      3  78d1				   PROCESS_CIRCLE_HELPER
    306  78d1
    307  78d1		       ad 84 02 	      lda	INTIM
    308  78d4		       c9 0a		      cmp	#SEGTIME_CIRCLE_HELPER
    309  78d6		       90 bd		      bcc	EarlyAbort
    310  78d8
    311  78d8
    312  78d8		       4c 87 f9 	      jmp	NextObject	; and die
    313  78db
    314  78db
      0  78db					      DEFINE_SUBROUTINE	PROCESS_CIRCLE
      1  78db		       00 0f	   BANK_PROCESS_CIRCLE =	_CURRENT_BANK
      2  78db					      SUBROUTINE
      3  78db				   PROCESS_CIRCLE
    316  78db
    317  78db		       ad 84 02 	      lda	INTIM
    318  78de		       c9 0a		      cmp	#SEGTIME_CIRCLE
    319  78e0		       90 b3		      bcc	EarlyAbort
    320  78e2
    321  78e2		       18		      clc
    322  78e3		       a5 a9		      lda	circle_d
    323  78e5		       69 19		      adc	#25
    324  78e7		       85 a9		      sta	circle_d
    325  78e9		       90 4b		      bcc	inactiveCircle
    326  78eb
    327  78eb		       e6 aa		      inc	circle_d+1
    328  78ed		       a5 aa		      lda	circle_d+1
    329  78ef		       c9 14		      cmp	#20
    330  78f1		       f0 4a		      beq	circleComplete
    331  78f3							; time to fire off another "ring" of the clearing circle
    332  78f3
    333  78f3							;sta POS_VAR		    ; diameter for helper to use
    334  78f3							;lda #TYPE_CIRCLE_HELPER
    335  78f3							;sta POS_Type
    336  78f3							;jsr InsertObjectStack
    337  78f3
    338  78f3
    339  78f3							; a = radius
    340  78f3
    341  78f3		       a0 00		      ldy	#CHARACTER_BLANK
    342  78f5		       84 ad		      sty	circ_char
    343  78f7
    344  78f7		       a5 aa		      lda	circle_d+1
    345  78f9		       38		      sec
    346  78fa		       e9 01		      sbc	#1
    347  78fc		       85 ab		      sta	circ_x
    348  78fe		       49 ff		      eor	#255
    349  7900		       18		      clc
    350  7901		       69 01		      adc	#1
    351  7903		       85 ae		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    352  7905
    353  7905		       a9 00		      lda	#0
    354  7907		       85 ac		      sta	circ_y
    355  7909
    356  7909		       a5 aa		      lda	circle_d+1	; radius
    357  790b		       a9 03		      lda	#TYPE_CIRCLE_DRAWER
    358  790d		       85 8e		      sta	POS_Type
    359  790f							;jsr InsertObjectStack
    360  790f
    361  790f		       a0 00		      ldy	#CHARACTER_BLANK
    362  7911		       a5 aa		      lda	circle_d+1
    363  7913		       38		      sec
    364  7914		       e9 01		      sbc	#1
    365  7916		       20 fa fd 	      jsr	DrawCircle
    366  7919
    367  7919		       a0 06		      ldy	#CHARACTER_STEEL
    368  791b		       84 ad		      sty	circ_char
    369  791d		       a5 aa		      lda	circle_d+1
    370  791f		       85 ab		      sta	circ_x
    371  7921		       49 ff		      eor	#255
    372  7923		       18		      clc
    373  7924		       69 01		      adc	#1
    374  7926		       85 ae		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    375  7928
    376  7928		       a9 00		      lda	#0
    377  792a		       85 ac		      sta	circ_y
    378  792c
    379  792c		       a5 aa		      lda	circle_d+1	; radius
    380  792e		       a9 03		      lda	#TYPE_CIRCLE_DRAWER
    381  7930		       85 8e		      sta	POS_Type
    382  7932							;jsr InsertObjectStack
    383  7932
    384  7932		       a0 00		      ldy	#CHARACTER_BLANK
    385  7934		       a5 aa		      lda	circle_d+1
    386  7936							;jsr DrawCircle
    387  7936
    388  7936
    389  7936
    390  7936							;			      inc circle_d+1
    391  7936							;			      ldy #CHARACTER_STEEL
    392  7936							;			      lda circle_d+1
    393  7936							;			      jsr DrawCircle
    394  7936
    395  7936		       a9 01	   inactiveCircle lda	#TYPE_CIRCLE
    396  7938		       85 8e		      sta	POS_Type
    397  793a		       20 94 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    398  793d
    399  793d		       4c 87 f9    circleComplete jmp	NextObject
    400  7940
    401  7940							;---------------------------------------------------------------------------
    402  7940
    403  7940		       60	   EarlyAbort4 rts
    404  7941
      0  7941					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  7941		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  7941					      SUBROUTINE
      3  7941				   PROCESS_MAN
    406  7941
    407  7941		       ad 84 02 	      lda	INTIM
    408  7944		       c9 18		      cmp	#SEGTIME_MAN
    409  7946		       90 f8		      bcc	EarlyAbort4
      0  7948					      STRESS_TIME	SEGTIME_MAN
      1  7948				  -	      IF	TEST_SEGTIME_MAN = 1
      2  7948				  -
      3  7948				  -
      4  7948				  -
      5  7948				  -
      6  7948				  -
      7  7948				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7948				  -	      bne	. - 7
      9  7948					      ENDIF
    411  7948
    412  7948		       a9 08		      lda	#BANK_ManProcess
    413  794a		       85 c2		      sta	ROM_Bank
    414  794c		       85 3f		      sta	SET_BANK
    415  794e		       20 85 f1 	      jsr	ManProcess
    416  7951
    417  7951		       20 c4 f9 	      jsr	MovePlayer	; 6+{}
    418  7954
    419  7954		       a9 03		      lda	#BANK_TrackPlayer	;
    420  7956		       85 3f		      sta	SET_BANK	;
    421  7958		       20 0e f4 	      jsr	TrackPlayer	;11+145
    422  795b
    423  795b		       a9 00		      lda	#TYPE_MAN	; 2
    424  795d		       85 8e		      sta	POS_Type	; 3
    425  795f
    426  795f		       20 94 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    427  7962		       4c 87 f9    gnobj      jmp	NextObject
    428  7965
    429  7965							;---------------------------------------------------------------------------
    430  7965
      0  7965					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  7965		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  7965					      SUBROUTINE
      3  7965				   RestoreOriginalCharacter
    432  7965
    433  7965		       a6 8b		      ldx	POS_Y	;3
    434  7967		       a4 8a		      ldy	POS_X	;3
    435  7969
    436  7969		       a9 08		      lda	#BANK_BoardLineStartLO	;2
    437  796b		       85 3f		      sta	SET_BANK	;3
    438  796d
    439  796d		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    440  7970		       85 c0		      sta	Board_AddressW	;3
    441  7972		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    442  7975		       85 c1		      sta	Board_AddressW+1	;3 WRITE address
    443  7977				  -	      IF	MULTI_BANK_BOARD = YES
    444  7977				  -	      lda	BoardBank,x	;4 switch this on return
    445  7977					      ELSE
    446  7977		       a9 0d		      lda	#BANK_BOARD	;2
    447  7979					      ENDIF
    448  7979		       85 3e		      sta	SET_BANK_RAM	;3
    449  797b
    450  797b		       a5 8f		      lda	POS_VAR
    451  797d		       91 c0		      sta	(Board_AddressW),y	;6 clear vacated board position
    452  797f
    453  797f		       a5 c2		      lda	ROM_Bank	;3
    454  7981		       85 3f		      sta	SET_BANK	;3
    455  7983		       60	   EarlyAbortBOX rts		;6
    456  7984
    457  7984
    458  7984							;---------------------------------------------------------------------------
    459  7984
    460  7984							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    461  7984							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    462  7984
    463  7984							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    464  7984
    465  7984							; if the creature dies then jump NextObject
    466  7984
    467  7984
    468  7984		       20 94 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    469  7987
    470  7987		       e6 cb	   NextObject inc	ObjIterator	; 5
    471  7989							;		  dec ObjStackPtr,x		  ; 6
    472  7989		       4c 53 f8 	      jmp	ProcessObjStack	; 3 = 16
    473  798c
    474  798c							;---------------------------------------------------------------------------
    475  798c
      0  798c					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  798c		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  798c					      SUBROUTINE
      3  798c				   InsertObjectStackFromRAM
    477  798c
    478  798c		       20 94 f9 	      jsr	InsertObjectStack	;6+76(B)
    479  798f		       a5 c3		      lda	RAM_Bank	;3
    480  7991		       85 3e		      sta	SET_BANK_RAM	;3
    481  7993
    482  7993		       60	   NotEnoughTime rts		;6
    483  7994
    484  7994							;---------------------------------------------------------------------------
    485  7994
      0  7994					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7994		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7994					      SUBROUTINE
      3  7994				   InsertObjectStack
    487  7994							; POS_X     x position
    488  7994							; POS_Y     y position
    489  7994							; POS_VAR   direction or other variable
    490  7994							; POS_Type  type of object
    491  7994
    492  7994		       a6 85		      ldx	ObjStackNum	; 3
    493  7996		       bc c2 f9 	      ldy	BankObjStack,x	; 4
    494  7999		       84 3e		      sty	SET_BANK_RAM	; 3
    495  799b		       b4 86		      ldy	ObjStackPtr,x	; 4 = 14
    496  799d
    497  799d
    498  799d		       a5 8b		      lda	POS_Y	; 3
    499  799f		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    500  79a2		       a5 8a		      lda	POS_X	; 3
    501  79a4		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    502  79a7		       a5 8f		      lda	POS_VAR	; 3
    503  79a9		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    504  79ac		       a5 8e		      lda	POS_Type	; 3
    505  79ae		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    506  79b1
    507  79b1							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    508  79b1							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    509  79b1							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    510  79b1
    511  79b1
    512  79b1				  -	      IF	TYPE_MAN != 0
    513  79b1				  -	      cmp	#TYPE_MAN	; 2
    514  79b1					      ENDIF
    515  79b1		       f0 04		      beq	alwaysAllowMan	; 2/3
    516  79b3
    517  79b3		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    518  79b5		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    519  79b7				   alwaysAllowMan
    520  79b7
    521  79b7		       98		      tya		; 2
    522  79b8		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    523  79bb
    524  79bb		       f6 86		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    525  79bd
    526  79bd		       a4 c2	   insertDone ldy	ROM_Bank	; 3
    527  79bf		       84 3f		      sty	SET_BANK	; 3
    528  79c1
    529  79c1				   ManIsDead2
    530  79c1
    531  79c1
    532  79c1
    533  79c1		       60		      rts		; 6 = 29
    534  79c2
    535  79c2							;---------------------------------------------------------------------------
    536  79c2
    537  79c2		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    538  79c4
    539  79c4							;---------------------------------------------------------------------------
    540  79c4
    541  79c4				   MovePlayer
    542  79c4		       a5 9f		      lda	ManMode
    543  79c6		       c9 02		      cmp	#MANMODE_DEAD
    544  79c8		       b0 f7		      bcs	ManIsDead2
    545  79ca
    546  79ca		       a4 8d		      ldy	POS_Y_NEW
    547  79cc
    548  79cc		       a9 08		      lda	#BANK_GetBoardAddressRW	;2
    549  79ce		       85 3f		      sta	SET_BANK	;3
    550  79d0		       85 c2		      sta	ROM_Bank	;3
    551  79d2		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    552  79d5				  -	      IF	MULTI_BANK_BOARD = YES
    553  79d5				  -	      stx	RAM_Bank
    554  79d5					      ENDIF
    555  79d5		       86 3e		      stx	SET_BANK_RAM	; 3
    556  79d7
    557  79d7		       a4 8c		      ldy	POS_X_NEW
    558  79d9		       b3 be		      lax	(Board_AddressR),y
    559  79db
    560  79db		       a9 08		      lda	#BANK_MoveVecLO
    561  79dd		       85 3f		      sta	SET_BANK
    562  79df
    563  79df		       bd 27 f3 	      lda	MoveVecLO,x
    564  79e2		       85 d8		      sta	MAN_Move
    565  79e4		       bd 31 f3 	      lda	MoveVecHI,x
    566  79e7		       85 d9		      sta	MAN_Move+1
    567  79e9
    568  79e9				  -	      IF	MULTI_BANK_BOARD = YES
    569  79e9				  -	      lda	RAM_Bank
    570  79e9					      ELSE
    571  79e9		       a9 0d		      lda	#BANK_BOARD
    572  79eb					      ENDIF
    573  79eb		       85 3e		      sta	SET_BANK_RAM
    574  79ed		       6c d8 00 	      jmp	(MAN_Move)
    575  79f0
    576  79f0							;---------------------------------------------------------------------------
    577  79f0
      0  79f0					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  79f0		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  79f0					      SUBROUTINE
      3  79f0				   MOVE_BLANK
      0  79f0					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  79f0		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  79f0					      SUBROUTINE
      3  79f0				   MOVE_SOIL
      0  79f0					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  79f0		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  79f0					      SUBROUTINE
      3  79f0				   MOVE_TARGET
    581  79f0
    582  79f0		       a4 8c		      ldy	POS_X_NEW
    583  79f2		       b1 be		      lda	(Board_AddressR),y	; what's on the board under man?
    584  79f4		       48		      pha
    585  79f5
    586  79f5		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    587  79f7		       91 c0		      sta	(Board_AddressW),y
    588  79f9
    589  79f9		       a6 9c		      ldx	ManY
    590  79fb		       86 8b		      stx	POS_Y
    591  79fd		       a4 9b		      ldy	ManX
    592  79ff		       84 8a		      sty	POS_X
    593  7a01
    594  7a01		       20 65 f9 	      jsr	RestoreOriginalCharacter
    595  7a04
    596  7a04		       68		      pla
    597  7a05		       85 8f		      sta	POS_VAR	; save 'restore' characte
    598  7a07
    599  7a07		       a5 8c		      lda	POS_X_NEW
    600  7a09		       85 9b		      sta	ManX
    601  7a0b		       a5 8d		      lda	POS_Y_NEW
    602  7a0d		       85 9c		      sta	ManY	; actually MOVE!
    603  7a0f
    604  7a0f							; Move counter..
    605  7a0f
    606  7a0f		       f8		      sed
    607  7a10		       18		      clc
    608  7a11		       a5 b9		      lda	moveCounter
    609  7a13		       69 01		      adc	#1
    610  7a15		       85 b9		      sta	moveCounter
    611  7a17		       a5 ba		      lda	moveCounter+1
    612  7a19		       69 00		      adc	#0
    613  7a1b		       85 ba		      sta	moveCounter+1
    614  7a1d		       d8		      cld
    615  7a1e
    616  7a1e		       a9 00	   MOVE_GENERIC lda	#0	; 2
    617  7a20		       85 a5		      sta	ManPushCounter	; 3
    618  7a22
    619  7a22		       60	   timeExit   rts		; 6 = 11
    620  7a23
    621  7a23							;---------------------------------------------------------------------------
    622  7a23
      0  7a23					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7a23		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7a23					      SUBROUTINE
      3  7a23				   MOVE_BOX
    624  7a23
    625  7a23		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    626  7a25		       a9 08		      lda	#BANK_PushBox
    627  7a27		       85 c2		      sta	ROM_Bank
    628  7a29		       85 3f		      sta	SET_BANK
    629  7a2b		       4c f5 f0 	      jmp	PushBox
    630  7a2e
      0  7a2e					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a2e		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a2e					      SUBROUTINE
      3  7a2e				   MOVE_BOX_ON_TARGET
    632  7a2e
    633  7a2e		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    634  7a30		       a9 08		      lda	#BANK_PushBox
    635  7a32		       85 c2		      sta	ROM_Bank
    636  7a34		       85 3f		      sta	SET_BANK
    637  7a36		       4c f5 f0 	      jmp	PushBox
    638  7a39
    639  7a39							;---------------------------------------------------------------------------
    640  7a39
      0  7a39					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a39		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a39					      SUBROUTINE
      3  7a39				   StealCharDraw
    642  7a39
    643  7a39		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    644  7a3b		       85 3e		      sta	SET_BANK_RAM	; 3
    645  7a3d		       a4 84		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    646  7a3f		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    647  7a41
    648  7a41				   ExitStealCharDraw
    649  7a41
    650  7a41							; fall through...
    651  7a41
    652  7a41							;---------------------------------------------------------------------------
    653  7a41
      0  7a41					      DEFINE_SUBROUTINE	TimeSlice
      1  7a41		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a41					      SUBROUTINE
      3  7a41				   TimeSlice
    655  7a41
    656  7a41							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    657  7a41							; going ahead if there's insufficient time. This allows the previous character drawing to
    658  7a41							; be much smaller in time, as they don't have to include the timeslice code overhead.
    659  7a41
    660  7a41		       ad 84 02 	      lda	INTIM	; 4
    661  7a44		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    662  7a46		       90 da		      bcc	timeExit	; 2(3)
    663  7a48
    664  7a48							; Uses the phase variable to vector to the correct processing code for the given timeslice
    665  7a48							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    666  7a48							; it should increment ScreenDrawPhase.
    667  7a48
    668  7a48							; Switched-in bank(s) are undefined after this function is called!
    669  7a48
    670  7a48		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    671  7a4a		       85 3f		      sta	SET_BANK	; 3
    672  7a4c
    673  7a4c		       a6 89		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    674  7a4e		       bd 95 f4 	      lda	TS_PhaseVectorLO,x	; 4
    675  7a51		       85 d8		      sta	TS_Vector	; 3
    676  7a53		       bd 9a f4 	      lda	TS_PhaseVectorHI,x	; 4
    677  7a56		       85 d9		      sta	TS_Vector+1	; 3
    678  7a58
    679  7a58		       bd 9f f4 	      lda	TS_PhaseBank,x	; 4
    680  7a5b		       85 3f		      sta	SET_BANK	; 3		 switch bank
    681  7a5d
    682  7a5d		       6c d8 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    683  7a60
    684  7a60							; = 55 minimum return time (if segtime abort)
    685  7a60
    686  7a60							;---------------------------------------------------------------------------
    687  7a60
    688  7a60
    689  7a60				   DrawAnother
    690  7a60
    691  7a60		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    692  7a62		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    693  7a64
    694  7a64		       a4 84		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    695  7a66
    696  7a66		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    697  7a69		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    698  7a6c		       29 7f		      and	#~128	; 2
    699  7a6e		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    700  7a71
    701  7a71		       88		      dey		; 2
    702  7a72		       84 84		      sty	DrawStackPointer	; 3	     one less to draw
    703  7a74		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    704  7a76
    705  7a76				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    706  7a76
    707  7a76		       ad 84 02 	      lda	INTIM	; 4
    708  7a79		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
    709  7a7b		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    710  7a7d
    711  7a7d		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    712  7a80		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    713  7a83
    714  7a83		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    715  7a86		       85 3e		      sta	SET_BANK_RAM	; 3
    716  7a88		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    717  7a8b
    718  7a8b
    719  7a8b
    720  7a8b
      0  7a8b					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7a8b		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7a8b					      SUBROUTINE
      3  7a8b				   DrawFullScreenMain
    722  7a8b
    723  7a8b							; Check the screen for all those characters that need to be redrawn
    724  7a8b							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    725  7a8b							; the drawflags array is different to the ScreenBuffer array entry, then the
    726  7a8b							; screenbuffer will need redrawing.
    727  7a8b
    728  7a8b				   CopyRow2
    729  7a8b
    730  7a8b				  -	      IF	MULTI_BANK_BOARD = YES
    731  7a8b				  -	      lda	BDF_BoardBank	; 3
    732  7a8b					      ELSE
    733  7a8b		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    734  7a8d					      ENDIF
    735  7a8d		       85 3e		      sta	SET_BANK_RAM	; 3
    736  7a8f		       b3 dc		      lax	(BDF_BoardAddress),y	; 5
    737  7a91		       9a		      txs		; 2
    738  7a92		       b3 de		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
    739  7a94
    740  7a94		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    741  7a96		       85 3e		      sta	SET_BANK_RAM	; 3
    742  7a98		       bd d1 f1 	      lda	CharReplacement,x	; 4
    743  7a9b		       91 da		      sta	(BDF_DrawFlagAddress2),y	; 6
    744  7a9d		       ba		      tsx		; 2
    745  7a9e		       bd d1 f1 	      lda	CharReplacement,x	; 4
    746  7aa1		       91 d8		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
    747  7aa3
    748  7aa3		       88		      dey		; 2
    749  7aa4		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
    750  7aa6							; total: 5*49[-1]-1 = 244[-5]
    751  7aa6
    752  7aa6		       a7 e1		      lax	DHS_Line	; 3
    753  7aa8		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    754  7aaa
    755  7aaa		       a0 08		      ldy	#BANK_DrawScreenRowPreparation	;2
    756  7aac		       84 3f		      sty	SET_BANK	; 3
    757  7aae		       4c ee f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
    758  7ab1
    759  7ab1							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    760  7ab1
    761  7ab1
      0  7ab1					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7ab1					      LIST	ON
    763  7ab1
    764  7ab1		       a6 e2	   .exitCopy  ldx	DHS_Stack	; 3
    765  7ab3		       9a		      txs		; 2
    766  7ab4
    767  7ab4							; fall through
    768  7ab4
      0  7ab4					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7ab4		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7ab4					      SUBROUTINE
      3  7ab4				   BuildDrawStack
    770  7ab4
    771  7ab4		       a9 08		      lda	#BANK_DRAW_BUFFERS
    772  7ab6		       85 3e		      sta	SET_BANK_RAM
    773  7ab8		       4c f1 f0 	      jmp	DrawStackUpdate
    774  7abb
    775  7abb							;---------------------------------------------------------------------------
    776  7abb
      0  7abb					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7abb		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7abb					      SUBROUTINE
      3  7abb				   DrawAIntoStack
    778  7abb
    779  7abb		       a9 08		      lda	#BANK_DRAW_BUFFERS
    780  7abd		       85 3e		      sta	SET_BANK_RAM
    781  7abf		       4c 1c f1 	      jmp	DrawIntoStack
    782  7ac2
    783  7ac2
    784  7ac2							;---------------------------------------------------------------------------
    785  7ac2
    786  7ac2
    787  7ac2				   Reset
      0  7ac2					      CLEAN_START
      1  7ac2		       78		      sei
      2  7ac3		       d8		      cld
      3  7ac4
      4  7ac4		       a2 00		      ldx	#0
      5  7ac6		       8a		      txa
      6  7ac7		       a8		      tay
      7  7ac8		       ca	   .CLEAR_STACK dex
      8  7ac9		       9a		      txs
      9  7aca		       48		      pha
     10  7acb		       d0 fb		      bne	.CLEAR_STACK
     11  7acd
    789  7acd
    790  7acd							; Scoring bank is copied once (not per game, not per level...)
    791  7acd							; otherwise non-SaveKey high score gets zapped
    792  7acd
    793  7acd		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
    794  7acf		       a0 09		      ldy	#BANK_SCORING
    795  7ad1		       20 dd fc 	      jsr	CopyROM2RAM_F000
    796  7ad4
    797  7ad4				   Restart		; go here on RESET + SELECT
    798  7ad4
    799  7ad4
    800  7ad4				   Title
    801  7ad4		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
    802  7ad6		       9a		      txs
    803  7ad7
    804  7ad7							; temporary vars from title screen are used to init level
    805  7ad7		       a9 03		      lda	#BANK_Cart_Init	; 2
    806  7ad9		       85 3f		      sta	SET_BANK	; 3
    807  7adb		       20 19 f3 	      jsr	Cart_Init	; 6+x
    808  7ade
    809  7ade
    810  7ade							;---------------------------------------------------------------------------
    811  7ade
    812  7ade
    813  7ade		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
    814  7ade
    815  7ade		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
    816  7ae0		       a0 0a		      ldy	#BANK_DECODE_LEVEL
    817  7ae2		       20 dd fc 	      jsr	CopyROM2RAM_F000
    818  7ae5
    819  7ae5
    820  7ae5							;---------------------------------------------------------------------------
    821  7ae5							; Once-only game initialisation goes here...
    822  7ae5							; now we have two players so things get a bit tricky
    823  7ae5
    824  7ae5		       a9 09		      lda	#BANK_SCORING
    825  7ae7		       85 3e		      sta	SET_BANK_RAM
    826  7ae9		       20 82 f3 	      jsr	GameInitialise
    827  7aec
    828  7aec
    829  7aec							;---------------------------------------------------------------------------
    830  7aec
    831  7aec				   RestartLevelNextPlayer
    832  7aec
    833  7aec
    834  7aec							; a player has lost a life.
    835  7aec							; store his vars, swap to other player, continue
    836  7aec
    837  7aec							;lda #BANK_SCORING
    838  7aec							;sta SET_BANK_RAM
    839  7aec							;jsr SwapPlayers
    840  7aec
    841  7aec		       a9 03		      lda	#BANK_SwapPlayersGeneric
    842  7aee		       85 3f		      sta	SET_BANK
    843  7af0		       20 70 f3 	      jsr	SwapPlayersGeneric
    844  7af3
    845  7af3				   NextLevelLevel
    846  7af3				   skipDemoCheck
    847  7af3
    848  7af3							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
    849  7af3							; including those for general systems function. But NOT those which do not need re-initialising between
    850  7af3							; levels.
    851  7af3		       a9 03		      lda	#BANK_LevelInit	; 2
    852  7af5		       85 3f		      sta	SET_BANK	; 3
    853  7af7		       20 bf f3 	      jsr	LevelInit	; 6+x
    854  7afa
    855  7afa		       a9 00		      lda	#0
    856  7afc		       85 d8		      sta	base_x
    857  7afe		       85 d9		      sta	base_y
    858  7b00
    859  7b00		       a9 0a		      lda	#BANK_DECODE_LEVEL
    860  7b02		       85 3e		      sta	SET_BANK_RAM
    861  7b04		       20 ab f1 	      jsr	UnpackLevel
    862  7b07
    863  7b07							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
    864  7b07
    865  7b07		       a9 28		      lda	#SIZE_BOARD_X
    866  7b09		       85 94		      sta	BoardLimit_Width
    867  7b0b		       a9 16		      lda	#SIZE_BOARD_Y
    868  7b0d		       85 95		      sta	BoardLimit_Height
    869  7b0f
    870  7b0f							; Setup player animation and scroll limits.
    871  7b0f							; Mangle the board colours based on level
    872  7b0f
    873  7b0f		       a9 03		      lda	#BANK_CreateCreatures	; 2
    874  7b11		       85 3f		      sta	SET_BANK	; 3
    875  7b13		       20 88 f3 	      jsr	CreateCreatures	; 6+x
    876  7b16
    877  7b16
    878  7b16							; Setup the various digit and display pointers
    879  7b16							; Grab current player's score/level from backup
    880  7b16
    881  7b16		       20 d1 fc 	      jsr	goGeneralScoringSetups
    882  7b19
    883  7b19							; copy the screen draw ROM shadow to RAM
    884  7b19
    885  7b19		       a0 07		      ldy	#SCREEN_LINES-1
    886  7b1b		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
    887  7b1d		       20 dd fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
    888  7b20		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
    889  7b23		       88		      dey
    890  7b24		       10 f5		      bpl	CopyScreenBanks
    891  7b26
    892  7b26		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    893  7b28		       a0 08		      ldy	#BANK_DRAW_BUFFERS
    894  7b2a		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
    895  7b2d
    896  7b2d							;---------------------------------------------------------------------------
    897  7b2d
    898  7b2d		       a9 03		      lda	#BANK_Resync	; 2
    899  7b2f		       85 3f		      sta	SET_BANK	; 3
    900  7b31		       20 ea f3 	      jsr	Resync	; 6+x
    901  7b34
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7b34					      include	"sound/intro1_init.asm"
      1  7b34							; TIATracker music player
      2  7b34							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b34							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b34							; Email: andre.wichmann@gmx.de
      5  7b34							;
      6  7b34							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b34							; you may not use this file except in compliance with the License.
      8  7b34							; You may obtain a copy of the License at
      9  7b34							;
     10  7b34							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b34							;
     12  7b34							; Unless required by applicable law or agreed to in writing, software
     13  7b34							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b34							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b34							; See the License for the specific language governing permissions and
     16  7b34							; limitations under the License.
     17  7b34
     18  7b34							; Song author: 
     19  7b34							; Song name: 
     20  7b34
     21  7b34							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b34
     23  7b34							; =====================================================================
     24  7b34							; Initialize music.
     25  7b34							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7b34							; tt_SequenceTable for each channel.
     27  7b34							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7b34							; All other variables can start with any value.
     29  7b34							; =====================================================================
     30  7b34		       a9 00		      lda	#0
     31  7b36		       85 ce		      sta	tt_cur_pat_index_c0
     32  7b38		       a9 05		      lda	#5
     33  7b3a		       85 cf		      sta	tt_cur_pat_index_c1
     34  7b3c							; the rest should be 0 already from startup code. If not,
     35  7b3c							; set the following variables to 0 manually:
     36  7b3c							; - tt_timer
     37  7b3c							; - tt_cur_pat_index_c0
     38  7b3c							; - tt_cur_pat_index_c1
     39  7b3c							; - tt_cur_note_index_c0
     40  7b3c							; - tt_cur_note_index_c1
     41  7b3c
------- FILE BANK_FIXED.asm
    903  7b3c
    904  7b3c				   NewFrameStart
    905  7b3c
    906  7b3c		       24 c8		      bit	NextLevelTrigger
    907  7b3e		       10 b3		      bpl	NextLevelLevel	; game-triggered next level
    908  7b40		       70 aa		      bvs	RestartLevelNextPlayer	; loss of life
    909  7b42
    910  7b42							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
    911  7b42
    912  7b42		       a9 0e		      lda	#%1110	; VSYNC ON
    913  7b44		       85 42	   .loopVSync sta	WSYNC
    914  7b46		       85 40		      sta	VSYNC
    915  7b48		       4a		      lsr
    916  7b49		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
    917  7b4b
    918  7b4b							; moved *after* the loop since this allows to *increase* timer values by 1!
    919  7b4b
    920  7b4b		       a6 81		      ldx	Platform
    921  7b4d		       bc 71 fc 	      ldy	VBlankTime,x
    922  7b50		       8c 96 02 	      sty	TIM64T
    923  7b53
    924  7b53
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  7b53					      include	"sound/intro1_player.asm"
      1  7b53							; TIATracker music player
      2  7b53							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b53							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b53							; Email: andre.wichmann@gmx.de
      5  7b53							;
      6  7b53							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b53							; you may not use this file except in compliance with the License.
      8  7b53							; You may obtain a copy of the License at
      9  7b53							;
     10  7b53							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b53							;
     12  7b53							; Unless required by applicable law or agreed to in writing, software
     13  7b53							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b53							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b53							; See the License for the specific language governing permissions and
     16  7b53							; limitations under the License.
     17  7b53
     18  7b53							; Song author: 
     19  7b53							; Song name: 
     20  7b53
     21  7b53							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b53
     23  7b53							; =====================================================================
     24  7b53							; TIATracker Player
     25  7b53							; =====================================================================
     26  7b53				   tt_PlayerStart
     27  7b53
     28  7b53							; PLANNED PLAYER VARIANTS:
     29  7b53							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7b53							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7b53							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7b53							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7b53							;	 pattern size and max ADSR size
     34  7b53							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7b53							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7b53							;	 (saves table and decode routine)
     37  7b53							; - Speed: Inline tt_CalcInsIndex
     38  7b53							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7b53							;	 Might also save the need for cur_note_index
     40  7b53
     41  7b53
     42  7b53							; ---------------------------------------------------------------------
     43  7b53							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7b53							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7b53							; ---------------------------------------------------------------------
     46  7b53					      MAC	tt_fetch_current_note
     47  7b53							; construct ptr to pattern
     48  7b53				   .constructPatPtr
     49  7b53					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7b53					      lda	tt_SequenceTable,y
     51  7b53					      IF	TT_USE_GOTO = 1
     52  7b53					      bpl	.noPatternGoto
     53  7b53					      and	#%01111111	; mask out goto bit to get pattern number
     54  7b53					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7b53					      bpl	.constructPatPtr	; unconditional
     56  7b53				   .noPatternGoto
     57  7b53					      ENDIF
     58  7b53					      tay
     59  7b53					      lda	tt_PatternPtrLo,y
     60  7b53					      sta	tt_ptr
     61  7b53					      lda	tt_PatternPtrHi,y
     62  7b53					      sta	tt_ptr+1
     63  7b53							; get new note
     64  7b53					      IF	TT_USE_OVERLAY = 0
     65  7b53					      ldy	tt_cur_note_index_c0,x
     66  7b53					      ELSE
     67  7b53							; If the V flag is set and if the new note is an instrument,
     68  7b53							; it means it got pre-fetched by an overlay percussion, it has
     69  7b53							; to remain in sustain.
     70  7b53					      clv
     71  7b53							; check if note had been pre-fetched by overlay perc already
     72  7b53					      lda	tt_cur_note_index_c0,x
     73  7b53					      bpl	.notPrefetched
     74  7b53							; If so, remove flag
     75  7b53					      and	#%01111111
     76  7b53					      sta	tt_cur_note_index_c0,x
     77  7b53							; Set V flag for later
     78  7b53					      bit	tt_Bit6Set
     79  7b53				   .notPrefetched
     80  7b53					      tay
     81  7b53					      ENDIF
     82  7b53					      lda	(tt_ptr),y
     83  7b53							; pre-process new note
     84  7b53							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7b53							; 0/0: End of pattern
     86  7b53					      bne	.noEndOfPattern
     87  7b53							; End of pattern: Advance to next pattern
     88  7b53					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7b53					      inc	tt_cur_pat_index_c0,x
     90  7b53					      bne	.constructPatPtr	; unconditional
     91  7b53				   .noEndOfPattern
     92  7b53					      ENDM
     93  7b53
     94  7b53
     95  7b53							; ---------------------------------------------------------------------
     96  7b53							; Music player entry. Call once per frame.
     97  7b53							; ---------------------------------------------------------------------
     98  7b53				   tt_Player  SUBROUTINE
     99  7b53							; ==================== Sequencer ====================
    100  7b53							; Decrease speed timer
    101  7b53		       c6 cd		      dec	tt_timer
    102  7b55		       10 6e		      bpl	.noNewNote
    103  7b57
    104  7b57							; Timer ran out: Do sequencer
    105  7b57							; Advance to next note
    106  7b57		       a2 01		      ldx	#1	; 2 channels
    107  7b59				   .advanceLoop
    108  7b59					      IF	TT_USE_OVERLAY = 1
    109  7b59		       20 6f fb 	      jsr	tt_FetchNote
    110  7b5c				  -	      ELSE
    111  7b5c				  -	      TT_FETCH_CURRENT_NOTE
    112  7b5c					      ENDIF
    113  7b5c							; Parse new note from pattern
    114  7b5c		       c9 10		      cmp	#TT_INS_PAUSE
    115  7b5e					      IF	TT_USE_SLIDE = 0
    116  7b5e		       90 55		      bcc	.finishedNewNote
    117  7b60		       d0 3d		      bne	.newNote
    118  7b62				  -	      ELSE
    119  7b62				  -	      beq	.pause
    120  7b62				  -	      bcs	.newNote
    121  7b62				  -
    122  7b62				  -			; --- slide/hold ---
    123  7b62				  -			; Adjust frequency and hold note in sustain.
    124  7b62				  -			; composer/tracker has to make sure that no unwanted
    125  7b62				  -			; under/overflow happens.
    126  7b62				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7b62				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7b62				  -	      sec
    129  7b62				  -	      sbc	#8
    130  7b62				  -	      sta	tt_cur_ins_c0,x
    131  7b62				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7b62					      ENDIF
    133  7b62
    134  7b62							; --- pause ---
    135  7b62				   .pause
    136  7b62							; Get release index for current instrument. Since a pause can
    137  7b62							; only follow an instrument, we don't need to handle percussion
    138  7b62							; or commands.
    139  7b62		       b5 d4		      lda	tt_cur_ins_c0,x
    140  7b64		       20 fd fb 	      jsr	tt_CalcInsIndex
    141  7b67		       b9 58 fe 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7b6a							; Put it into release. Skip junk byte so index no longer indicates
    143  7b6a							; sustain phase.
    144  7b6a		       18		      clc
    145  7b6b		       69 01		      adc	#1
    146  7b6d		       90 44		      bcc	.storeADIndex	; unconditional
    147  7b6f
    148  7b6f							; ---------------------------------------------------------------------
    149  7b6f							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7b6f							; TT_USE_OVERLAY is not used.
    151  7b6f							; Interleaved here so player can be inlined.
    152  7b6f							; ---------------------------------------------------------------------
    153  7b6f					      IF	TT_USE_OVERLAY = 1
    154  7b6f				   tt_FetchNote
      0  7b6f					      TT_FETCH_CURRENT_NOTE
      1  7b6f
      2  7b6f				   .constructPatPtr
      3  7b6f		       b4 ce		      ldy	tt_cur_pat_index_c0,x
      4  7b71		       b9 6b ff 	      lda	tt_SequenceTable,y
      5  7b74					      IF	TT_USE_GOTO = 1
      6  7b74		       10 06		      bpl	.noPatternGoto
      7  7b76		       29 7f		      and	#%01111111
      8  7b78		       95 ce		      sta	tt_cur_pat_index_c0,x
      9  7b7a		       10 f3		      bpl	.constructPatPtr
     10  7b7c				   .noPatternGoto
     11  7b7c					      ENDIF
     12  7b7c		       a8		      tay
     13  7b7d		       b9 61 ff 	      lda	tt_PatternPtrLo,y
     14  7b80		       85 d6		      sta	tt_ptr
     15  7b82		       b9 66 ff 	      lda	tt_PatternPtrHi,y
     16  7b85		       85 d7		      sta	tt_ptr+1
     17  7b87
     18  7b87				  -	      IF	TT_USE_OVERLAY = 0
     19  7b87				  -	      ldy	tt_cur_note_index_c0,x
     20  7b87					      ELSE
     21  7b87
     22  7b87
     23  7b87
     24  7b87		       b8		      clv
     25  7b88
     26  7b88		       b5 d0		      lda	tt_cur_note_index_c0,x
     27  7b8a		       10 07		      bpl	.notPrefetched
     28  7b8c
     29  7b8c		       29 7f		      and	#%01111111
     30  7b8e		       95 d0		      sta	tt_cur_note_index_c0,x
     31  7b90
     32  7b90		       2c 03 fc 	      bit	tt_Bit6Set
     33  7b93				   .notPrefetched
     34  7b93		       a8		      tay
     35  7b94					      ENDIF
     36  7b94		       b1 d6		      lda	(tt_ptr),y
     37  7b96
     38  7b96
     39  7b96
     40  7b96		       d0 06		      bne	.noEndOfPattern
     41  7b98
     42  7b98		       95 d0		      sta	tt_cur_note_index_c0,x
     43  7b9a		       f6 ce		      inc	tt_cur_pat_index_c0,x
     44  7b9c		       d0 d1		      bne	.constructPatPtr
     45  7b9e				   .noEndOfPattern
    156  7b9e		       60		      rts
    157  7b9f					      ENDIF
    158  7b9f
    159  7b9f
    160  7b9f							; --- start instrument or percussion ---
    161  7b9f				   .newNote
    162  7b9f		       95 d4		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7ba1							; Instrument or percussion?
    164  7ba1		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7ba3		       b0 06		      bcs	.startInstrument
    166  7ba5
    167  7ba5							; --- start percussion ---
    168  7ba5							; Get index of envelope
    169  7ba5		       a8		      tay
    170  7ba6							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7ba6		       b9 7c fe 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7ba9		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7bab
    174  7bab							; --- start instrument ---
    175  7bab				   .startInstrument
    176  7bab					      IF	TT_USE_OVERLAY = 1
    177  7bab							; If V flag is set, this note had been pre-fetched. That means
    178  7bab							; it should remain in sustain.
    179  7bab		       70 08		      bvs	.finishedNewNote
    180  7bad					      ENDIF
    181  7bad							; Put note into attack/decay
    182  7bad		       20 fd fb 	      jsr	tt_CalcInsIndex
    183  7bb0		       b9 4e fe 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7bb3				   .storeADIndex
    185  7bb3		       95 d2		      sta	tt_envelope_index_c0,x
    186  7bb5
    187  7bb5							; --- Finished parsing new note ---
    188  7bb5				   .finishedNewNote
    189  7bb5							; increase note index into pattern
    190  7bb5		       f6 d0		      inc	tt_cur_note_index_c0,x
    191  7bb7							; loop over channels
    192  7bb7				   .sequencerNextChannel
    193  7bb7		       ca		      dex
    194  7bb8		       10 9f		      bpl	.advanceLoop
    195  7bba
    196  7bba							; Reset timer value
    197  7bba				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7bba				  -			; Get timer value for current pattern in channel 0
    199  7bba				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7bba				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7bba				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7bba				  -	      lda	tt_PatternSpeeds,y
    203  7bba				  -	      sta	tt_timer
    204  7bba				  -	      ELSE
    205  7bba				  -			; Test for odd/even frame
    206  7bba				  -	      lda	tt_cur_note_index_c0
    207  7bba				  -	      lsr
    208  7bba				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7bba				  -	      bcc	.evenFrame
    210  7bba				  -	      and	#$0f	; does not affect carry flag
    211  7bba				  -	      bcs	.storeFunkTempo
    212  7bba				  -.evenFrame
    213  7bba				  -	      lsr
    214  7bba				  -	      lsr
    215  7bba				  -	      lsr
    216  7bba				  -	      lsr
    217  7bba				  -.storeFunkTempo
    218  7bba				  -	      sta	tt_timer
    219  7bba				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7bba				  -
    221  7bba					      ELSE
    222  7bba							; Global tempo
    223  7bba		       a2 04		      ldx	#TT_SPEED-1
    224  7bbc					      IF	TT_USE_FUNKTEMPO = 1
    225  7bbc		       a5 d0		      lda	tt_cur_note_index_c0
    226  7bbe		       4a		      lsr
    227  7bbf		       90 02		      bcc	.noOddFrame
    228  7bc1		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7bc3				   .noOddFrame
    230  7bc3					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7bc3		       86 cd		      stx	tt_timer
    232  7bc5					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7bc5
    234  7bc5							; No new note to process
    235  7bc5				   .noNewNote
    236  7bc5
    237  7bc5							; ==================== Update registers ====================
    238  7bc5		       a2 01		      ldx	#1	; 2 channels
    239  7bc7				   .updateLoop
    240  7bc7							; Percussion or melodic instrument?
    241  7bc7		       b5 d4		      lda	tt_cur_ins_c0,x
    242  7bc9				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7bc9				  -			; This branch can be removed if track starts with a note in each channel
    244  7bc9				  -	      beq	.afterAudioUpdate
    245  7bc9					      ENDIF
    246  7bc9		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7bcb		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7bcd
    249  7bcd							; --- Percussion: Get envelope index ---
    250  7bcd		       b4 d2		      ldy	tt_envelope_index_c0,x
    251  7bcf							; Set AUDC and AUDV value from envelope
    252  7bcf		       b9 a5 fe 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7bd2		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7bd4		       f6 d2		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7bd6				   .endOfPercussion
    256  7bd6		       95 59		      sta	AUDV0,x
    257  7bd8		       4a		      lsr
    258  7bd9		       4a		      lsr
    259  7bda		       4a		      lsr
    260  7bdb		       4a		      lsr
    261  7bdc		       95 55		      sta	AUDC0,x
    262  7bde							; Set AUDF
    263  7bde		       b9 8f fe 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7be1							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7be1		       95 57		      sta	AUDF0,x
    266  7be3					      IF	TT_USE_OVERLAY = 1
    267  7be3		       10 48		      bpl	.afterAudioUpdate
    268  7be5							; Overlay percussion: Fetch next note out of order
    269  7be5		       20 6f fb 	      jsr	tt_FetchNote
    270  7be8							; Only do something if it's a melodic instrument
    271  7be8		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7bea		       90 41		      bcc	.afterAudioUpdate
    273  7bec							; Instrument: Put into sustain
    274  7bec		       95 d4		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7bee		       20 fd fb 	      jsr	tt_CalcInsIndex
    276  7bf1		       b9 53 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7bf4		       95 d2		      sta	tt_envelope_index_c0,x
    278  7bf6							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7bf6		       16 d0		      asl	tt_cur_note_index_c0,x
    280  7bf8		       38		      sec
    281  7bf9		       76 d0		      ror	tt_cur_note_index_c0,x
    282  7bfb		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7bfd				  -	      ELSE
    284  7bfd				  -	      jmp	.afterAudioUpdate
    285  7bfd					      ENDIF
    286  7bfd
    287  7bfd
    288  7bfd							; ---------------------------------------------------------------------
    289  7bfd							; Helper subroutine to minimize ROM footprint.
    290  7bfd							; Interleaved here so player routine can be inlined.
    291  7bfd							; ---------------------------------------------------------------------
    292  7bfd				   tt_CalcInsIndex
    293  7bfd							; move upper 3 bits to lower 3
    294  7bfd		       4a		      lsr
    295  7bfe		       4a		      lsr
    296  7bff		       4a		      lsr
    297  7c00		       4a		      lsr
    298  7c01		       4a		      lsr
    299  7c02		       a8		      tay
    300  7c03				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7c03		       60		      rts
    302  7c04
    303  7c04
    304  7c04				   .instrument
    305  7c04							; --- Melodic instrument ---
    306  7c04							; Compute index into ADSR indexes and master Ctrl tables
    307  7c04		       20 fd fb 	      jsr	tt_CalcInsIndex
    308  7c07							; Set AUDC with master value for this instrument, while we are at it
    309  7c07		       b9 49 fe 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7c0a		       95 55		      sta	AUDC0,x
    311  7c0c							; advance ADSR counter and compare to end of Sustain
    312  7c0c		       b5 d2		      lda	tt_envelope_index_c0,x
    313  7c0e		       d9 58 fe 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7c11		       d0 03		      bne	.noEndOfSustain
    315  7c13							; End of sustain: Go back to start of sustain
    316  7c13		       b9 53 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7c16				   .noEndOfSustain
    318  7c16		       a8		      tay
    319  7c17							; Set volume from envelope
    320  7c17		       b9 5e fe 	      lda	tt_InsFreqVolTable,y
    321  7c1a		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7c1c		       c8		      iny		; advance index otherwise
    323  7c1d				   .endOfEnvelope
    324  7c1d		       94 d2		      sty	tt_envelope_index_c0,x
    325  7c1f		       95 59		      sta	AUDV0,x
    326  7c21							; Now adjust frequency with ADSR value from envelope
    327  7c21		       4a		      lsr
    328  7c22		       4a		      lsr
    329  7c23		       4a		      lsr
    330  7c24		       4a		      lsr
    331  7c25		       18		      clc
    332  7c26		       75 d4		      adc	tt_cur_ins_c0,x
    333  7c28		       38		      sec
    334  7c29		       e9 08		      sbc	#8
    335  7c2b		       95 57		      sta	AUDF0,x
    336  7c2d
    337  7c2d				   .afterAudioUpdate
    338  7c2d							; loop over channels
    339  7c2d		       ca		      dex
    340  7c2e		       10 97		      bpl	.updateLoop
    341  7c30
 Music player size:  $dd
    342  7c30					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
    926  7c30
    927  7c30		       20 39 fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
    928  7c33
    929  7c33							;---------------------------------------------------------------------------
    930  7c33							; START OF DISPLAY
    931  7c33
    932  7c33		       a9 09		      lda	#BANK_SCORING	; 2
    933  7c35		       85 3e		      sta	SET_BANK_RAM	; 3
    934  7c37		       20 d3 f1 	      jsr	DrawDigits	; 6 = 11
    935  7c3a
    936  7c3a							;---------------------------------------------------------------------------
    937  7c3a							; A 42-cycle timing window in the screen draw code.  Perform any general
    938  7c3a							; per-frame code here, provided it takes exactly 42 cycles to execute.
    939  7c3a							; TJ: Well, not exactly 42 cycles, but it works! :)
    940  7c3a							;	 @09
    941  7c3a		       85 49		      sta	COLUBK	; 3	 value comes from subroutine
    942  7c3c							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
    943  7c3c
    944  7c3c
    945  7c3c							;		  inc Throttle		      ; 5     speed limiter
      0  7c3c					      SLEEP	5	;	 TODO: optimize for space
      1  7c3c				   .CYCLES    SET	5
      2  7c3c
      3  7c3c				  -	      IF	.CYCLES < 2
      4  7c3c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c3c				  -	      ERR
      6  7c3c					      ENDIF
      7  7c3c
      8  7c3c					      IF	.CYCLES & 1
      9  7c3c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c3c		       04 00		      nop	0
     11  7c3e				  -	      ELSE
     12  7c3e				  -	      bit	VSYNC
     13  7c3e					      ENDIF
     14  7c3e				   .CYCLES    SET	.CYCLES - 3
     15  7c3e					      ENDIF
     16  7c3e
     17  7c3e					      REPEAT	.CYCLES / 2
     18  7c3e		       ea		      nop
     19  7c3f					      REPEND
    947  7c3f
    948  7c3f		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
    949  7c41		       ca		      dex		; 2	 = $6f, stars effect!
    950  7c42		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
    951  7c44
    952  7c44		       85 44		      sta	NUSIZ0	; 3
    953  7c46		       84 65		      sty	VDELP0	; 3	 y = 0!
    954  7c48
      0  7c48					      SLEEP	10
      1  7c48				   .CYCLES    SET	10
      2  7c48
      3  7c48				  -	      IF	.CYCLES < 2
      4  7c48				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c48				  -	      ERR
      6  7c48					      ENDIF
      7  7c48
      8  7c48				  -	      IF	.CYCLES & 1
      9  7c48				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c48				  -	      nop	0
     11  7c48				  -	      ELSE
     12  7c48				  -	      bit	VSYNC
     13  7c48				  -	      ENDIF
     14  7c48				  -.CYCLES    SET	.CYCLES - 3
     15  7c48					      ENDIF
     16  7c48
     17  7c48					      REPEAT	.CYCLES / 2
     18  7c48		       ea		      nop
     17  7c48					      REPEND
     18  7c49		       ea		      nop
     17  7c49					      REPEND
     18  7c4a		       ea		      nop
     17  7c4a					      REPEND
     18  7c4b		       ea		      nop
     17  7c4b					      REPEND
     18  7c4c		       ea		      nop
     19  7c4d					      REPEND
    956  7c4d							;iny			      ; 2     this relies on Y == 0 before...
    957  7c4d							;cpy extraLifeTimer	      ; 3     ..,and bit 0 is set in A
    958  7c4d							;adc #2		      ; 2
    959  7c4d							;sta ENAM0		      ; 3     dis/enable Cosmic Ark star effect
    960  7c4d
    961  7c4d		       a5 a4		      lda	ManLastDirection	; 3
    962  7c4f		       85 4b		      sta	REFP0	; 3
    963  7c51
    964  7c51		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
    965  7c53		       85 3e		      sta	SET_BANK_RAM	; 3
    966  7c55		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
    967  7c58							;	 @66
    968  7c58		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
    969  7c5a		       85 3f		      sta	SET_BANK	; 3
    970  7c5c		       20 ac f4 	      jsr	PostScreenCleanup	; 6+x
    971  7c5f
    972  7c5f		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
    973  7c61		       85 3f		      sta	SET_BANK	; 3
    974  7c63		       20 db f2 	      jsr	SelfModDrawPlayers	; 6+x
    975  7c66
    976  7c66		       20 39 fa 	      jsr	StealCharDraw
    977  7c69
    978  7c69		       ad 84 02    OverscanBD lda	INTIM	;4
    979  7c6c		       d0 fb		      bne	OverscanBD	;2/3
    980  7c6e		       4c 3c fb 	      jmp	NewFrameStart
    981  7c71				   VBlankTime
    982  7c71		       3e 3e		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
    983  7c73		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
    984  7c75
    985  7c75							;---------------------------------------------------------------------------
    986  7c75
    987  7c75				   CharacterDataVecLO
    988  7c75
    989  7c75							; Two entries per character.  2nd is ptr to mirrored character
    990  7c75							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    991  7c75
    992  7c75		       05		      .byte.b	<CHARACTERSHAPE_BLANK
    993  7c76		       05		      .byte.b	<CHARACTERSHAPE_BLANK
    994  7c77		       2f		      .byte.b	<CHARACTERSHAPE_SOIL
    995  7c78		       2f		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    996  7c79		       e6		      .byte.b	<CHARACTERSHAPE_BOX
    997  7c7a		       00		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    998  7c7b		       54		      .byte.b	<CHARACTERSHAPE_TARGET
    999  7c7c		       3f		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
   1000  7c7d		       53		      .byte.b	<CHARACTERSHAPE_TARGET2
   1001  7c7e		       3e		      .byte.b	<CHARACTERSHAPE_TARGET2_MIRRORED
   1002  7c7f		       05		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
   1003  7c80		       05		      .byte.b	<CHARACTERSHAPE_BLANK
   1004  7c81		       3f		      .byte.b	<CHARACTERSHAPE_STEEL
   1005  7c82		       3f		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
   1006  7c83		       20		      .byte.b	<CHARACTERSHAPE_WALL
   1007  7c84		       35		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
   1008  7c85		       15		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
   1009  7c86		       2a		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
   1010  7c87		       05		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1011  7c88		       05		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1012  7c89
   1013  7c89				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
   1014  7c89				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
   1015  7c89				  -	      ERR
   1016  7c89					      ENDIF
   1017  7c89
   1018  7c89							;---------------------------------------------------------------------------
   1019  7c89
   1020  7c89				   CharacterDataVecHI
   1021  7c89							; TJ: used by:
   1022  7c89							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1023  7c89
   1024  7c89		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1025  7c8a		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1026  7c8b		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
   1027  7c8c		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
   1028  7c8d		       fc		      .byte.b	>CHARACTERSHAPE_BOX
   1029  7c8e		       fd		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
   1030  7c8f		       f2		      .byte.b	>CHARACTERSHAPE_TARGET
   1031  7c90		       f2		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
   1032  7c91		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2
   1033  7c92		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2_MIRRORED
   1034  7c93		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
   1035  7c94		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1036  7c95		       fd		      .byte.b	>CHARACTERSHAPE_STEEL
   1037  7c96		       fd		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
   1038  7c97		       fe		      .byte.b	>CHARACTERSHAPE_WALL
   1039  7c98		       fe		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
   1040  7c99		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
   1041  7c9a		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
   1042  7c9b		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1043  7c9c		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1044  7c9d
   1045  7c9d				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
   1046  7c9d				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
   1047  7c9d				  -	      ERR
   1048  7c9d					      ENDIF
   1049  7c9d
   1050  7c9d							;---------------------------------------------------------------------------
   1051  7c9d
      0  7c9d					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  7c9d		       00 0f	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  7c9d					      SUBROUTINE
      3  7c9d				   AnimateCharReplacements2
   1053  7c9d
   1054  7c9d							; This manages character animation on a per-object basis.  Morph/animate these
   1055  7c9d							; characters individually or as required.  Change will affect all characters
   1056  7c9d							; of the same type in the visible display.
   1057  7c9d
   1058  7c9d							; -------------------------------------------
   1059  7c9d
   1060  7c9d							; handle the non-mandatory animating things
   1061  7c9d
   1062  7c9d		       a5 b1		      lda	timer	;3
   1063  7c9f		       29 03		      and	#%11	;2
   1064  7ca1		       d0 0c		      bne	nothingAnimates	;2/3
   1065  7ca3
   1066  7ca3		       a5 98		      lda	scrollBits	;3
   1067  7ca5		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
   1068  7ca7
   1069  7ca7		       ad d4 f1 	      lda	ANIM_TARGET	;4
   1070  7caa		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
   1071  7cac		       8d d4 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 15	 TARGET
   1072  7caf
   1073  7caf		       4c 16 f1    nothingAnimates jmp	retAnim	;3
   1074  7cb2
   1075  7cb2							;---------------------------------------------------------------------------
   1076  7cb2
      0  7cb2					      DEFINE_SUBROUTINE	ScoreAdd
      1  7cb2		       00 0f	   BANK_ScoreAdd =	_CURRENT_BANK
      2  7cb2					      SUBROUTINE
      3  7cb2				   ScoreAdd
   1078  7cb2							; TJ: used by:
   1079  7cb2							; - BANK_INITBANK.asm
   1080  7cb2		       a2 09		      ldx	#BANK_SCORING
   1081  7cb4		       86 3e		      stx	SET_BANK_RAM
   1082  7cb6		       20 0f f2 	      jsr	UpdateScore
   1083  7cb9		       a5 c2	   rbret      lda	ROM_Bank
   1084  7cbb		       85 3f		      sta	SET_BANK
   1085  7cbd		       60		      rts
   1086  7cbe
   1087  7cbe							;---------------------------------------------------------------------------
   1088  7cbe
      0  7cbe					      DEFINE_SUBROUTINE	nextLevelMan
      1  7cbe		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7cbe					      SUBROUTINE
      3  7cbe				   nextLevelMan
   1090  7cbe
   1091  7cbe							;lda #BANK_NextLevelX
   1092  7cbe							;sta SET_BANK
   1093  7cbe							;jmp NextLevelX
   1094  7cbe
   1095  7cbe							; Now do the actual switching
   1096  7cbe
   1097  7cbe		       a5 c8		      lda	NextLevelTrigger
   1098  7cc0		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1099  7cc2		       85 c8		      sta	NextLevelTrigger
   1100  7cc4
   1101  7cc4							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1102  7cc4							; then increment the level number. This is completely circular, so we eventually wrap
   1103  7cc4							; the level back to 0 and start afresh.
   1104  7cc4
   1105  7cc4		       e6 b3		      inc	levelX
   1106  7cc6		       a5 b3		      lda	levelX
   1107  7cc8		       c9 64		      cmp	#NUMBEROFLEVELS
   1108  7cca		       90 02		      bcc	.level_ok
   1109  7ccc		       a9 00		      lda	#0
   1110  7cce		       85 b3	   .level_ok  sta	levelX
   1111  7cd0		       60		      rts
   1112  7cd1
   1113  7cd1							;---------------------------------------------------------------------------
   1114  7cd1
      0  7cd1					      DEFINE_SUBROUTINE	goGeneralScoringSetups
      1  7cd1		       00 0f	   BANK_goGeneralScoringSetups =	_CURRENT_BANK
      2  7cd1					      SUBROUTINE
      3  7cd1				   goGeneralScoringSetups
   1116  7cd1
   1117  7cd1		       a9 09		      lda	#BANK_SCORING
   1118  7cd3		       85 3e		      sta	SET_BANK_RAM
   1119  7cd5		       20 8f f2 	      jsr	GeneralScoringSetups
   1120  7cd8		       a5 c2		      lda	ROM_Bank
   1121  7cda		       85 3f		      sta	SET_BANK
   1122  7cdc		       60		      rts
   1123  7cdd							;---------------------------------------------------------------------------
   1124  7cdd
      0  7cdd					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7cdd		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7cdd					      SUBROUTINE
      3  7cdd				   CopyROM2RAM_F000
   1126  7cdd
   1127  7cdd		       a9 08		      lda	#BANK_CopyROMShadowToRAM
   1128  7cdf		       85 3f		      sta	SET_BANK
   1129  7ce1		       85 c2		      sta	ROM_Bank
   1130  7ce3		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1131  7ce6
   1132  7ce6
   1133  7ce6							;---------------------------------------------------------------------------
   1134  7ce6
------- FILE characterset/BOX.asm LEVEL 3 PASS 3
      0  7ce6					      include	"characterset/BOX.asm"	; 2 * LINES_PER_CHAR bytes
      1  7ce6							;    Sokoboo - a Sokoban implementation
      2  7ce6							;    using a generic tile-based display engine for the Atari 2600
      3  7ce6							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7ce6							;
      5  7ce6							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7ce6							;
      7  7ce6							;    Code related to the generic tile-based display engine was developed by
      8  7ce6							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7ce6							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7ce6							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7ce6							;
     12  7ce6							;    Code related to music and sound effects uses the TIATracker music player
     13  7ce6							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7ce6							;    directory for Apache licensing details.
     15  7ce6							;
     16  7ce6							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7ce6							;    See the copyright notices in the License directory for a list of level
     18  7ce6							;    contributors.
     19  7ce6							;
     20  7ce6							;    Except where otherwise indicated, this software is released under the
     21  7ce6							;    following licensing arrangement...
     22  7ce6							;
     23  7ce6							;    This program is free software: you can redistribute it and/or modify
     24  7ce6							;    it under the terms of the GNU General Public License as published by
     25  7ce6							;    the Free Software Foundation, either version 3 of the License, or
     26  7ce6							;    (at your option) any later version.
     27  7ce6							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7ce6
     29  7ce6							;    This program is distributed in the hope that it will be useful,
     30  7ce6							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7ce6							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7ce6							;    GNU General Public License for more details.
     33  7ce6
      0  7ce6					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7ce6					      LIST	ON
     35  7ce6				   CHARACTERSHAPE_BOX
     36  7ce6				  -	      if	MIRRORED_BOX = NO
     37  7ce6				  -CHARACTERSHAPE_BOX_MIRRORED
     38  7ce6					      endif
     39  7ce6		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     40  7ced		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     41  7cf4		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0	;B
     42  7cfb
     43  7cfb							;--------------------------------------------------------------------------
     44  7cfb					      if	MIRRORED_BOX = YES
      0  7cfb					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_BOX_MIRRORED
 REQUESTED SIZE =  $15
 WASTED SPACE =  $5
 PAGEBREAK LOCATION =  $fd00
     10  7d00					      LIST	ON
     46  7d00				   CHARACTERSHAPE_BOX_MIRRORED
     47  7d00		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     48  7d07		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     49  7d0e		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0	;B
     50  7d15					      endif
     51  7d15
      0  7d15					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7d15					      LIST	ON
     53  7d15				   CHARACTERSHAPE_BOX_ON_TARGET
     54  7d15				  -	      if	MIRRORED_BOX = NO
     55  7d15				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     56  7d15					      endif
     57  7d15		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     58  7d1c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     59  7d23		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     60  7d2a
     61  7d2a							;--------------------------------------------------------------------------
     62  7d2a					      if	MIRRORED_BOX = YES
      0  7d2a					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7d2a					      LIST	ON
     64  7d2a				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     65  7d2a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     66  7d31		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     67  7d38		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     68  7d3f					      endif
------- FILE BANK_FIXED.asm
------- FILE characterset/Steel_Wall.asm LEVEL 3 PASS 3
      0  7d3f					      include	"characterset/Steel_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7d3f							;    Sokoboo - a Sokoban implementation
      2  7d3f							;    using a generic tile-based display engine for the Atari 2600
      3  7d3f							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7d3f							;
      5  7d3f							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7d3f							;
      7  7d3f							;    Code related to the generic tile-based display engine was developed by
      8  7d3f							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7d3f							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7d3f							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7d3f							;
     12  7d3f							;    Code related to music and sound effects uses the TIATracker music player
     13  7d3f							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7d3f							;    directory for Apache licensing details.
     15  7d3f							;
     16  7d3f							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7d3f							;    See the copyright notices in the License directory for a list of level
     18  7d3f							;    contributors.
     19  7d3f							;
     20  7d3f							;    Except where otherwise indicated, this software is released under the
     21  7d3f							;    following licensing arrangement...
     22  7d3f							;
     23  7d3f							;    This program is free software: you can redistribute it and/or modify
     24  7d3f							;    it under the terms of the GNU General Public License as published by
     25  7d3f							;    the Free Software Foundation, either version 3 of the License, or
     26  7d3f							;    (at your option) any later version.
     27  7d3f							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7d3f
     29  7d3f							;    This program is distributed in the hope that it will be useful,
     30  7d3f							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7d3f							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7d3f							;    GNU General Public License for more details.
     33  7d3f
     34  7d3f							;--------------------------------------------------------------------------
      0  7d3f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7d3f					      LIST	ON
     36  7d3f				   CHARACTERSHAPE_STEEL
     37  7d3f				   CHARACTERSHAPE_EXITDOOR
     38  7d3f				  -	      if	MIRRORED_STEEL = NO
     39  7d3f				  -CHARACTERSHAPE_STEEL_MIRRORED
     40  7d3f				  -CHARACTERSHAPE_EXITDOOR_MIRRORED
     41  7d3f				  -	      .byte	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     42  7d3f				  -	      .byte	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     43  7d3f				  -	      .byte	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     44  7d3f					      endif
     45  7d3f
     46  7d3f							;--------------------------------------------------------------------------
     47  7d3f					      if	MIRRORED_STEEL = YES
      0  7d3f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7d3f					      LIST	ON
     49  7d3f				   CHARACTERSHAPE_STEEL_MIRRORED
     50  7d3f				   CHARACTERSHAPE_EXITDOOR_MIRRORED
     51  7d3f		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     52  7d46		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     53  7d4d		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
     54  7d54					      endif
------- FILE BANK_FIXED.asm
   1137  7d54							;---------------------------------------------------------------------------
   1138  7d54
------- FILE circle.asm LEVEL 3 PASS 3
      0  7d54					      include	"circle.asm"
      1  7d54							;    Sokoboo - a Sokoban implementation
      2  7d54							;    using a generic tile-based display engine for the Atari 2600
      3  7d54							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7d54							;
      5  7d54							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7d54							;
      7  7d54							;    Code related to the generic tile-based display engine was developed by
      8  7d54							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7d54							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7d54							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7d54							;
     12  7d54							;    Code related to music and sound effects uses the TIATracker music player
     13  7d54							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7d54							;    directory for Apache licensing details.
     15  7d54							;
     16  7d54							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7d54							;    See the copyright notices in the License directory for a list of level
     18  7d54							;    contributors.
     19  7d54							;
     20  7d54							;    Except where otherwise indicated, this software is released under the
     21  7d54							;    following licensing arrangement...
     22  7d54							;
     23  7d54							;    This program is free software: you can redistribute it and/or modify
     24  7d54							;    it under the terms of the GNU General Public License as published by
     25  7d54							;    the Free Software Foundation, either version 3 of the License, or
     26  7d54							;    (at your option) any later version.
     27  7d54							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7d54
     29  7d54							;    This program is distributed in the hope that it will be useful,
     30  7d54							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7d54							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7d54							;    GNU General Public License for more details.
     33  7d54
     34  7d54							;Begin {Circle}
     35  7d54							;x := r;
     36  7d54							;y := 0;
     37  7d54							;d := 1 - r;
     38  7d54							;Repeat
     39  7d54							;Circle_Points(x,y);
     40  7d54							;y := y + 1;
     41  7d54							;if d < 0 Then
     42  7d54							;    d := d + 2*y + 1
     43  7d54							;Else Begin
     44  7d54							;    x := x - 1;
     45  7d54							;    d := d + 2*(y-x) + 1
     46  7d54							;    End
     47  7d54							;Until x < y
     48  7d54							;End; {Circle}
     49  7d54
     50  7d54
      0  7d54					      DEFINE_SUBROUTINE	PlotChar
      1  7d54		       00 0f	   BANK_PlotChar =	_CURRENT_BANK
      2  7d54					      SUBROUTINE
      3  7d54				   PlotChar
     52  7d54
     53  7d54							; a = x pos
     54  7d54							; y = y pos
     55  7d54
     56  7d54		       c5 94		      cmp	BoardLimit_Width
     57  7d56		       b0 14		      bcs	off1x
     58  7d58		       c4 95		      cpy	BoardLimit_Height
     59  7d5a		       b0 10		      bcs	off1x
     60  7d5c
     61  7d5c		       48		      pha
     62  7d5d		       a9 08		      lda	#BANK_GetBoardAddressW	;
     63  7d5f		       85 3f		      sta	SET_BANK	;
     64  7d61		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
     65  7d64
     66  7d64		       86 3e		      stx	SET_BANK_RAM	;3
     67  7d66
     68  7d66		       68		      pla
     69  7d67		       a8		      tay
     70  7d68		       a5 ad		      lda	circ_char	;3
     71  7d6a		       91 c0		      sta	(Board_AddressW),y	;6
     72  7d6c		       60	   off1x      rts
     73  7d6d
     74  7d6d							;x	       Plot(x,y);
     75  7d6d							;x	       Plot(y,x);
     76  7d6d							;x	      Plot(y,-x);
     77  7d6d							;x	      Plot(x,-y);
     78  7d6d							;x	      Plot(-x,-y);
     79  7d6d							;x	      Plot(-y,-x);
     80  7d6d							;x	       Plot(-y,x);
     81  7d6d							;x	       Plot(-x,y)
     82  7d6d
      0  7d6d					      DEFINE_SUBROUTINE	PlotCirclePoints
      1  7d6d		       00 0f	   BANK_PlotCirclePoints =	_CURRENT_BANK
      2  7d6d					      SUBROUTINE
      3  7d6d				   PlotCirclePoints
     84  7d6d
     85  7d6d							; +x+y
     86  7d6d		       18		      clc
     87  7d6e		       a5 ac		      lda	circ_y
     88  7d70		       4a		      lsr
     89  7d71		       65 9c		      adc	ManY	; "origin"
     90  7d73		       a8		      tay
     91  7d74		       18		      clc
     92  7d75		       a5 ab		      lda	circ_x
     93  7d77		       4a		      lsr
     94  7d78		       65 9b		      adc	ManX
     95  7d7a		       c5 95		      cmp	BoardLimit_Height
     96  7d7c		       b0 ee		      bcs	off1x
     97  7d7e		       20 54 fd 	      jsr	PlotChar
     98  7d81
     99  7d81							;+y+x
    100  7d81		       18		      clc
    101  7d82		       a5 ab		      lda	circ_x
    102  7d84		       4a		      lsr
    103  7d85		       65 9c		      adc	ManY	; "origin"
    104  7d87		       a8		      tay
    105  7d88		       18		      clc
    106  7d89		       a5 ac		      lda	circ_y
    107  7d8b		       4a		      lsr
    108  7d8c		       65 9b		      adc	ManX
    109  7d8e		       20 54 fd 	      jsr	PlotChar
    110  7d91
    111  7d91							; y,-x
    112  7d91		       38		      sec
    113  7d92		       a5 9c		      lda	ManY
    114  7d94		       0a		      asl
    115  7d95		       e5 ab		      sbc	circ_x
    116  7d97		       4a		      lsr
    117  7d98		       a8		      tay
    118  7d99		       18		      clc
    119  7d9a		       a5 ac		      lda	circ_y
    120  7d9c		       4a		      lsr
    121  7d9d		       65 9b		      adc	ManX	; "origin"
    122  7d9f		       20 54 fd 	      jsr	PlotChar
    123  7da2
    124  7da2							; x,-y
    125  7da2		       a5 9c		      lda	ManY
    126  7da4		       0a		      asl
    127  7da5		       38		      sec
    128  7da6		       e5 ac		      sbc	circ_y	; "origin"
    129  7da8		       4a		      lsr
    130  7da9		       a8		      tay
    131  7daa		       a5 ab		      lda	circ_x
    132  7dac		       4a		      lsr
    133  7dad		       18		      clc
    134  7dae		       65 9b		      adc	ManX
    135  7db0		       20 54 fd 	      jsr	PlotChar
    136  7db3
    137  7db3							; -x,-y
    138  7db3		       a5 9c		      lda	ManY
    139  7db5		       0a		      asl
    140  7db6		       38		      sec
    141  7db7		       e5 ac		      sbc	circ_y	; "origin"
    142  7db9		       4a		      lsr
    143  7dba		       a8		      tay
    144  7dbb		       a5 9b		      lda	ManX
    145  7dbd		       0a		      asl
    146  7dbe		       38		      sec
    147  7dbf		       e5 ab		      sbc	circ_x
    148  7dc1		       4a		      lsr
    149  7dc2		       20 54 fd 	      jsr	PlotChar
    150  7dc5
    151  7dc5							; -y,-x
    152  7dc5		       a5 9c		      lda	ManY
    153  7dc7		       0a		      asl
    154  7dc8		       38		      sec
    155  7dc9		       e5 ab		      sbc	circ_x	; "origin"
    156  7dcb		       4a		      lsr
    157  7dcc		       a8		      tay
    158  7dcd		       a5 9b		      lda	ManX
    159  7dcf		       0a		      asl
    160  7dd0		       38		      sec
    161  7dd1		       e5 ac		      sbc	circ_y
    162  7dd3		       4a		      lsr
    163  7dd4		       20 54 fd 	      jsr	PlotChar
    164  7dd7
    165  7dd7							; -y,x
    166  7dd7		       a5 ab		      lda	circ_x
    167  7dd9		       4a		      lsr
    168  7dda		       18		      clc
    169  7ddb		       65 9c		      adc	ManY	; "origin"
    170  7ddd		       a8		      tay
    171  7dde		       a5 9b		      lda	ManX
    172  7de0		       0a		      asl
    173  7de1		       38		      sec
    174  7de2		       e5 ac		      sbc	circ_y
    175  7de4		       4a		      lsr
    176  7de5		       20 54 fd 	      jsr	PlotChar
    177  7de8
    178  7de8							; -x,y
    179  7de8		       a5 ac		      lda	circ_y
    180  7dea		       4a		      lsr
    181  7deb		       d8		      cld
    182  7dec		       65 9c		      adc	ManY	; "origin"
    183  7dee		       a8		      tay
    184  7def		       a5 9b		      lda	ManX
    185  7df1		       0a		      asl
    186  7df2		       38		      sec
    187  7df3		       e5 ab		      sbc	circ_x
    188  7df5		       4a		      lsr
    189  7df6		       20 54 fd 	      jsr	PlotChar
    190  7df9
    191  7df9
    192  7df9		       60		      rts		;6
    193  7dfa
    194  7dfa
    195  7dfa
      0  7dfa					      DEFINE_SUBROUTINE	DrawCircle
      1  7dfa		       00 0f	   BANK_DrawCircle =	_CURRENT_BANK
      2  7dfa					      SUBROUTINE
      3  7dfa				   DrawCircle
    197  7dfa							; a = radius
    198  7dfa							;		    sty circ_char
    199  7dfa							;		    sta circ_x
    200  7dfa							;		    eor #255
    201  7dfa							;		    clc
    202  7dfa							;		    adc #1
    203  7dfa							;		    sta circ_scratch	 ; "d" --> "1-r" in unit terms
    204  7dfa
    205  7dfa							;		    lda #0
    206  7dfa							;		    sta circ_y
    207  7dfa
    208  7dfa				   CircleRepeat
    209  7dfa
    210  7dfa
    211  7dfa
    212  7dfa		       20 6d fd 	      jsr	PlotCirclePoints
    213  7dfd		       e6 ac		      inc	circ_y
    214  7dff		       a5 ae		      lda	circ_scratch
    215  7e01		       10 09		      bpl	positiveD
    216  7e03
    217  7e03		       a5 ac		      lda	circ_y
    218  7e05		       0a		      asl
    219  7e06		       38		      sec		; "+1"
    220  7e07		       65 ae		      adc	circ_scratch
    221  7e09		       4c 17 fe 	      jmp	CCont
    222  7e0c
    223  7e0c		       c6 ab	   positiveD  dec	circ_x
    224  7e0e
    225  7e0e		       38		      sec
    226  7e0f		       a5 ac		      lda	circ_y
    227  7e11		       e5 ab		      sbc	circ_x
    228  7e13		       0a		      asl
    229  7e14		       38		      sec		; "+1"
    230  7e15		       65 ae		      adc	circ_scratch
    231  7e17
    232  7e17		       85 ae	   CCont      sta	circ_scratch
    233  7e19
    234  7e19		       a5 ab		      lda	circ_x
    235  7e1b		       c5 ac		      cmp	circ_y
    236  7e1d		       b0 db		      bcs	CircleRepeat	; circleDie
    237  7e1f
    238  7e1f		       60	   circleDie  rts
------- FILE BANK_FIXED.asm
------- FILE characterset/Brick_Wall.asm LEVEL 3 PASS 3
      0  7e20					      include	"characterset/Brick_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7e20							;    Sokoboo - a Sokoban implementation
      2  7e20							;    using a generic tile-based display engine for the Atari 2600
      3  7e20							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7e20							;
      5  7e20							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7e20							;
      7  7e20							;    Code related to the generic tile-based display engine was developed by
      8  7e20							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7e20							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7e20							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7e20							;
     12  7e20							;    Code related to music and sound effects uses the TIATracker music player
     13  7e20							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7e20							;    directory for Apache licensing details.
     15  7e20							;
     16  7e20							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7e20							;    See the copyright notices in the License directory for a list of level
     18  7e20							;    contributors.
     19  7e20							;
     20  7e20							;    Except where otherwise indicated, this software is released under the
     21  7e20							;    following licensing arrangement...
     22  7e20							;
     23  7e20							;    This program is free software: you can redistribute it and/or modify
     24  7e20							;    it under the terms of the GNU General Public License as published by
     25  7e20							;    the Free Software Foundation, either version 3 of the License, or
     26  7e20							;    (at your option) any later version.
     27  7e20							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7e20
     29  7e20							;    This program is distributed in the hope that it will be useful,
     30  7e20							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7e20							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7e20							;    GNU General Public License for more details.
     33  7e20
      0  7e20					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7e20					      LIST	ON
     35  7e20
     36  7e20		       00 00	   BRICK_WALL_DEF =	0
     37  7e20
     38  7e20				   CHARACTERSHAPE_WALL
     39  7e20				   CHARACTERSHAPE_WALL0
     40  7e20
     41  7e20
     42  7e20
     43  7e20				  -	      if	MIRRORED_WALL = NO
     44  7e20				  -CHARACTERSHAPE_WALL_MIRRORED
     45  7e20				  -CHARACTERSHAPE_WALL0_MIRRORED
     46  7e20					      endif
     47  7e20
     48  7e20					      if	BRICK_WALL_DEF = 0
     49  7e20		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
     50  7e27		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
     51  7e2e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     52  7e35					      endif
     53  7e35
     54  7e35
     55  7e35
     56  7e35							;--------------------------------------------------------------------------
     57  7e35					      if	MIRRORED_WALL = YES
      0  7e35					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7e35					      LIST	ON
     59  7e35				   CHARACTERSHAPE_WALL_MIRRORED
     60  7e35				   CHARACTERSHAPE_WALL0_MIRRORED
     61  7e35
     62  7e35					      if	BRICK_WALL_DEF = 0
     63  7e35		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     64  7e3c		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     65  7e43		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     66  7e4a					      endif
     67  7e4a
     68  7e4a
     69  7e4a					      endif
------- FILE BANK_FIXED.asm
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  7e4a					      include	"sound/intro1_trackdata.asm"
      1  7e4a							; TIATracker music player
      2  7e4a							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7e4a							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7e4a							; Email: andre.wichmann@gmx.de
      5  7e4a							;
      6  7e4a							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7e4a							; you may not use this file except in compliance with the License.
      8  7e4a							; You may obtain a copy of the License at
      9  7e4a							;
     10  7e4a							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7e4a							;
     12  7e4a							; Unless required by applicable law or agreed to in writing, software
     13  7e4a							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7e4a							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7e4a							; See the License for the specific language governing permissions and
     16  7e4a							; limitations under the License.
     17  7e4a
     18  7e4a							; Song author: 
     19  7e4a							; Song name: 
     20  7e4a
     21  7e4a							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7e4a
     23  7e4a							; =====================================================================
     24  7e4a							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7e4a							; data.
     26  7e4a							; =====================================================================
     27  7e4a				   tt_TrackDataStart
     28  7e4a
     29  7e4a							; =====================================================================
     30  7e4a							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7e4a							; the index values into these tables for the current instruments played
     32  7e4a							; in channel 0 and 1.
     33  7e4a							; 
     34  7e4a							; Each instrument is defined by:
     35  7e4a							; - tt_InsCtrlTable: the AUDC value
     36  7e4a							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7e4a							;	 defined in tt_InsFreqVolTable
     38  7e4a							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7e4a							;	 of the envelope
     40  7e4a							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7e4a							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7e4a							;	 the envelope
     43  7e4a							; =====================================================================
     44  7e4a
     45  7e4a							; Instrument master CTRL values
     46  7e4a				   tt_InsCtrlTable
     47  7e4a		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7e4f
     49  7e4f
     50  7e4f							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7e4f				   tt_InsADIndexes
     52  7e4f		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7e54
     54  7e54
     55  7e54							; Instrument Sustain start indexes into ADSR tables
     56  7e54				   tt_InsSustainIndexes
     57  7e54		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7e59
     59  7e59
     60  7e59							; Instrument Release start indexes into ADSR tables
     61  7e59							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7e59							; real index, add 1.
     63  7e59				   tt_InsReleaseIndexes
     64  7e59		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7e5e
     66  7e5e
     67  7e5e							; AUDVx and AUDFx ADSR envelope values.
     68  7e5e							; Each byte encodes the frequency and volume:
     69  7e5e							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7e5e							;	 8 means no change. Bit 7 is the sign bit.
     71  7e5e							; - Bits 3..0: Volume
     72  7e5e							; Between sustain and release is one byte that is not used and
     73  7e5e							; can be any value.
     74  7e5e							; The end of the release phase is encoded by a 0.
     75  7e5e				   tt_InsFreqVolTable
     76  7e5e							; 0: Pizzicato bassb
     77  7e5e		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7e66		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7e6c							; 1+2: Square2
     80  7e6c		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7e74		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7e7c							; 3+4: Square
     83  7e7c		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7e84		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7e8c		       00		      dc.b	$00
     86  7e8d
     87  7e8d
     88  7e8d
     89  7e8d							; =====================================================================
     90  7e8d							; Percussion instrument definitions (up to 15)
     91  7e8d							;
     92  7e8d							; Each percussion instrument is defined by:
     93  7e8d							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7e8d							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7e8d							; - tt_PercFreqTable: The AUDF frequency value
     96  7e8d							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7e8d							; =====================================================================
     98  7e8d
     99  7e8d							; Indexes into percussion definitions signifying the first frame for
    100  7e8d							; each percussion in tt_PercFreqTable.
    101  7e8d							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7e8d							; real index, subtract 1.
    103  7e8d				   tt_PercIndexes
    104  7e8d		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7e90
    106  7e90
    107  7e90							; The AUDF frequency values for the percussion instruments.
    108  7e90							; If the second to last value is negative (>=128), it means it's an
    109  7e90							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7e90							; immediately and starts it in the sustain phase next frame. (Needs
    111  7e90							; TT_USE_OVERLAY)
    112  7e90				   tt_PercFreqTable
    113  7e90							; 0: Kick
    114  7e90		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7e98		       00		      dc.b	$00
    116  7e99							; 1: HH
    117  7e99		       80 00		      dc.b	$80, $00
    118  7e9b							; 2: Snare
    119  7e9b		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7ea3		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7ea6
    122  7ea6
    123  7ea6							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7ea6							; - Bits 7..4: AUDC value
    125  7ea6							; - Bits 3..0: AUDV value
    126  7ea6							; 0 means end of percussion data.
    127  7ea6				   tt_PercCtrlVolTable
    128  7ea6							; 0: Kick
    129  7ea6		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7eae		       00		      dc.b	$00
    131  7eaf							; 1: HH
    132  7eaf		       87 00		      dc.b	$87, $00
    133  7eb1							; 2: Snare
    134  7eb1		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7eb9		       87 86 00 	      dc.b	$87, $86, $00
    136  7ebc
    137  7ebc
    138  7ebc
    139  7ebc							; =====================================================================
    140  7ebc							; Track definition
    141  7ebc							; The track is defined by:
    142  7ebc							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7ebc							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7ebc							;	 as index values
    145  7ebc							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7ebc							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7ebc							;	 for all channels and sub-tracks. The variables
    148  7ebc							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7ebc							;	 each channel.
    150  7ebc							;
    151  7ebc							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7ebc							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7ebc							; to play are specified.
    154  7ebc							; =====================================================================
    155  7ebc
    156  7ebc							; ---------------------------------------------------------------------
    157  7ebc							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7ebc							; hold the index values into these tables for the current pattern
    159  7ebc							; played in channel 0 and 1.
    160  7ebc							;
    161  7ebc							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7ebc							; A note can be either:
    163  7ebc							; - Pause: Put melodic instrument into release. Must only follow a
    164  7ebc							;	 melodic instrument.
    165  7ebc							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7ebc							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7ebc							;	 by -7..+7 and keep playing it
    168  7ebc							; - Play new note with melodic instrument
    169  7ebc							; - Play new note with percussion instrument
    170  7ebc							; - End of pattern
    171  7ebc							;
    172  7ebc							; A note is defined by:
    173  7ebc							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7ebc							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7ebc							;	 defined as:
    176  7ebc							;	 - 0: End of pattern
    177  7ebc							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7ebc							;	 - 8: Hold
    179  7ebc							;	 - 16: Pause
    180  7ebc							;	 - [17..31]: Play percussion instrument 1..15
    181  7ebc							;
    182  7ebc							; The tracker must ensure that a pause only follows a melodic
    183  7ebc							; instrument or a hold/slide.
    184  7ebc							; ---------------------------------------------------------------------
    185  7ebc		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7ebc		       00 08	   TT_INS_HOLD =	8
    187  7ebc		       00 10	   TT_INS_PAUSE =	16
    188  7ebc		       00 11	   TT_FIRST_PERC =	17
    189  7ebc
    190  7ebc							; Intro left
    191  7ebc				   tt_pattern0
    192  7ebc		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7ec4		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7ecc		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7ed4		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7edc		       00		      dc.b	$00
    197  7edd
    198  7edd							; Intro2 L
    199  7edd				   tt_pattern1
    200  7edd		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7ee5		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7eed		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7ef5		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7efd		       00		      dc.b	$00
    205  7efe
    206  7efe							; Intro2-fill L
    207  7efe				   tt_pattern2
    208  7efe		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7f06		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7f0e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7f16		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7f1e		       00		      dc.b	$00
    213  7f1f
    214  7f1f							; Intro right
    215  7f1f				   tt_pattern3
    216  7f1f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7f27		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7f2f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7f37		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7f3f		       00		      dc.b	$00
    221  7f40
    222  7f40							; Intro2 R
    223  7f40				   tt_pattern4
    224  7f40		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7f48		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7f50		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7f58		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7f60		       00		      dc.b	$00
    229  7f61
    230  7f61
    231  7f61
    232  7f61
    233  7f61							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7f61							; Each byte encodes the speed of one pattern in the order
    235  7f61							; of the tt_PatternPtr tables below.
    236  7f61							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7f61							; the even speed and the high nibble the odd speed.
    238  7f61				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7f61				  -tt_PatternSpeeds
    240  7f61				  -%%PATTERNSPEEDS%%
    241  7f61					      ENDIF
    242  7f61
    243  7f61
    244  7f61							; ---------------------------------------------------------------------
    245  7f61							; Pattern pointers look-up table.
    246  7f61							; ---------------------------------------------------------------------
    247  7f61				   tt_PatternPtrLo
    248  7f61		       bc dd fe 1f	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7f65		       40		      dc.b	<tt_pattern4
    250  7f66				   tt_PatternPtrHi
    251  7f66		       fe fe fe ff	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7f6a		       ff		      dc.b	>tt_pattern4
    253  7f6b
    254  7f6b
    255  7f6b							; ---------------------------------------------------------------------
    256  7f6b							; Pattern sequence table. Each byte is an index into the
    257  7f6b							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7f6b							; definitions can be found. When a pattern has been played completely,
    259  7f6b							; the next byte from this table is used to get the address of the next
    260  7f6b							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7f6b							; into this table for channels 0 and 1.
    262  7f6b							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7f6b							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7f6b							; ---------------------------------------------------------------------
    265  7f6b				   tt_SequenceTable
    266  7f6b							; ---------- Channel 0 ----------
    267  7f6b		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7f70
    269  7f70
    270  7f70							; ---------- Channel 1 ----------
    271  7f70		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7f75
    273  7f75
 Track size:  $12b
    274  7f75					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1142  7f75
 FREE BYTES IN FIXED BANK =  $86
   1143  7f75					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1144  7f75
   1145  7f75							;---------------------------------------------------------------------------
   1146  7f75							; The reset vectors
   1147  7f75							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1148  7f75
   1149  8000 ????				      SEG	InterruptVectors
   1150  7ffc					      ORG	FIXED_BANK + $7FC
   1151  7ffc					      RORG	$7ffC
   1152  7ffc
   1153  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1154  7ffc		       c2 fa		      .word.w	Reset	; RESET
   1155  7ffe		       c2 fa		      .word.w	Reset	; IRQ	      (not used)
   1156  8000
   1157  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    862  8000
    863  8000					      END
